{"version":3,"sources":["node_modules/browserify/node_modules/browser-pack/_prelude.js","src/index","pixi-lights.min.js","src/lightSpriteMixin.js","src/lights/WireframeShader.js","src/lights/ambientLight/AmbientLight.js","src/lights/ambientLight/AmbientLightShader.js","src/lights/light/Light.js","src/lights/light/LightShader.js","src/lights/pointLight/PointLight.js","src/lights/pointLight/PointLightShader.js","src/renderers/LightRenderer.js","src/renderers/WebGLDeferredRenderer.js","src/shapeMeshMixin.js"],"names":["e","t","n","r","s","o","u","a","require","i","f","Error","code","l","exports","call","length",1,"module","PIXI","lights","Light","LightShader","AmbientLight","AmbientLightShader","PointLight","PointLightShader","LightRenderer","WebGLDeferredRenderer","WireframeShader","./lightSpriteMixin","./lights/WireframeShader","./lights/ambientLight/AmbientLight","./lights/ambientLight/AmbientLightShader","./lights/light/Light","./lights/light/LightShader","./lights/pointLight/PointLight","./lights/pointLight/PointLightShader","./renderers/LightRenderer","./renderers/WebGLDeferredRenderer","./shapeMeshMixin",2,"Sprite","prototype","_renderWebGL","renderer","this","_originalTexture","_texture","renderingNormals","normalTexture","setObjectRenderer","plugins","sprite","render",3,"shaderManager","Shader","join","translationMatrix","type","value","Float32Array","projectionMatrix","aVertexPosition","Object","create","constructor","ShaderManager","registerPlugin",4,"color","brightness","shaderName","renderWebGL","vertices","width","height","../light/Light",5,"../light/LightShader",6,"indices","DisplayObject","Uint16Array","blendMode","BLEND_MODES","ADD","drawMode","DRAW_MODES","TRIANGLES","needsUpdate","falloff","_vertexBuffer","_indexBuffer","_color","_colorRgba","defineProperties","get","set","val","utils","hex2rgb","syncShader","shader","uniforms","uLightColor","uLightHeight","uLightFalloff","destroy",7,"vertexSrc","fragmentSrc","customUniforms","customAttributes","uSampler","uNormalSampler","uViewSize","attributes","defaultVertexSrc",8,"radius","decay","shape","math","Circle","mesh","getMesh","_syncShader","TRIANGLE_FAN","uLightRadius",9,10,"ObjectRenderer","numIndices","MAX_LIGHTS","j","currentBatchSize","WebGLRenderer","light","flush","gl","diffuseTexture","normalsTexture","lastShader","_initWebGL","setShader","blendModeManager","setBlendMode","worldTransform","toArray","currentRenderTarget","syncUniforms","uniform1i","_location","bindBuffer","ARRAY_BUFFER","bufferData","STATIC_DRAW","vertexAttribPointer","FLOAT","activeTexture","TEXTURE0","bindTexture","TEXTURE_2D","baseTexture","_glTextures","id","TEXTURE1","ELEMENT_ARRAY_BUFFER","bufferSubData","drawElements","UNSIGNED_SHORT","createBuffer","DYNAMIC_DRAW",11,"options","assign","_initContext","RenderTexture","resolution","object","setRenderTarget","renderTarget",12,"totalSegments","seg","Math","PI","indicesIndex","index","angle","cos","sin"],"mappings":"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","file":"pixi-lights.min.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","module.exports = PIXI.lights = {\r\n//    LitSprite: require('./light_1/LitSprite'),\r\n//    LightingRenderer: require('./light_1/webgl/LightingRenderer')\r\n\r\n    Light:                  require('./lights/light/Light'),\r\n    LightShader:            require('./lights/light/LightShader'),\r\n\r\n    AmbientLight:           require('./lights/ambientLight/AmbientLight'),\r\n    AmbientLightShader:     require('./lights/ambientLight/AmbientLightShader'),\r\n\r\n    PointLight:             require('./lights/pointLight/PointLight'),\r\n    PointLightShader:       require('./lights/pointLight/PointLightShader'),\r\n\r\n    LightRenderer:          require('./renderers/LightRenderer'),\r\n    WebGLDeferredRenderer:  require('./renderers/WebGLDeferredRenderer'),\r\n\r\n    WireframeShader:        require('./lights/WireframeShader')\r\n};\r\n\r\nrequire('./lightSpriteMixin');\r\nrequire('./shapeMeshMixin');\r\n",null,"var tempTexture = null;\r\n\r\n /**\r\n * Renders the object using the WebGL renderer\r\n *\r\n * @param renderer {WebGLRenderer}\r\n * @private\r\n */\r\nPIXI.Sprite.prototype._renderWebGL = function (renderer)\r\n{\r\n    if (!this._originalTexture) {\r\n        this._originalTexture = this._texture;\r\n    }\r\n\r\n    if (renderer.renderingNormals && this.normalTexture)\r\n    {\r\n        this._texture = this.normalTexture;\r\n    }\r\n    else\r\n    {\r\n        this._texture = this._originalTexture;\r\n    }\r\n\r\n    renderer.setObjectRenderer(renderer.plugins.sprite);\r\n    renderer.plugins.sprite.render(this);\r\n};\r\n","\r\n\r\n/**\r\n * @class\r\n * @extends PIXI.Shader\r\n * @memberof PIXI.lights\r\n * @param shaderManager {ShaderManager} The WebGL shader manager this shader works for.\r\n */\r\nfunction WireframeShader(shaderManager) {\r\n    PIXI.Shader.call(this,\r\n        shaderManager,\r\n        // vertex shader\r\n        [\r\n            'precision lowp float;',\r\n\r\n            'attribute vec2 aVertexPosition;',\r\n\r\n            'uniform mat3 projectionMatrix;',\r\n\r\n            'void main(void) {',\r\n            '    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);',\r\n            '}'\r\n        ].join('\\n'),\r\n        // fragment shader\r\n        [\r\n            'void main() {',\r\n            '    gl_FragColor = vec4(0, 0, 0, 1);',\r\n            '}'\r\n        ].join('\\n'),\r\n        // uniforms\r\n        {\r\n            translationMatrix:  { type: 'mat3', value: new Float32Array(9) },\r\n            projectionMatrix:   { type: 'mat3', value: new Float32Array(9) }\r\n        },\r\n        // attributes\r\n        {\r\n            aVertexPosition: 0\r\n        }\r\n    );\r\n}\r\n\r\nWireframeShader.prototype = Object.create(PIXI.Shader.prototype);\r\nWireframeShader.prototype.constructor = WireframeShader;\r\nmodule.exports = WireframeShader;\r\n\r\nPIXI.ShaderManager.registerPlugin('wireframeShader', WireframeShader);\r\n","var Light = require('../light/Light');\r\n\r\n/**\r\n * @class\r\n * @extends PIXI.lights.Light\r\n * @memberof PIXI.lights\r\n *\r\n * @param [color=0xFFFFFF] {number} The color of the light.\r\n * @param [brightness=0.5] {number} The brightness of the light.\r\n */\r\nfunction AmbientLight(color, brightness) {\r\n    Light.call(this, color, brightness);\r\n\r\n    this.shaderName = 'ambientLightShader';\r\n}\r\n\r\nAmbientLight.prototype = Object.create(Light.prototype);\r\nAmbientLight.prototype.constructor = AmbientLight;\r\nmodule.exports = AmbientLight;\r\n\r\nAmbientLight.prototype.renderWebGL = function (renderer)\r\n{\r\n    // add lights to their renderer on the normals pass\r\n    if (!renderer.renderingNormals) {\r\n        return;\r\n    }\r\n\r\n    // update verts to ensure it is a fullscreen quad even if the renderer is resized. This should be optimized\r\n    this.vertices[2] = this.vertices[4] = renderer.width;\r\n    this.vertices[5] = this.vertices[7] = renderer.height;\r\n\r\n//    this.needsUpdate = true;\r\n\r\n    // I actually don't want to interrupt the current batch, so don't set light as the current object renderer.\r\n    // Light renderer works a bit differently in that lights are draw individually on flush (called by WebGLDeferredRenderer).\r\n    //renderer.setObjectRenderer(renderer.plugins.lights);\r\n\r\n    renderer.plugins.lights.render(this);\r\n};\r\n","var LightShader = require('../light/LightShader');\r\n\r\n\r\n/**\r\n * @class\r\n * @extends PIXI.Shader\r\n * @memberof PIXI.lights\r\n * @param shaderManager {ShaderManager} The WebGL shader manager this shader works for.\r\n */\r\nfunction AmbientLightShader(shaderManager) {\r\n    LightShader.call(this,\r\n        shaderManager,\r\n        // vertex shader\r\n        null,\r\n        // fragment shader\r\n        \"#define GLSLIFY 1\\n\\nprecision lowp float;\\r\\n\\r\\nuniform sampler2D uSampler;\\r\\nuniform sampler2D uNormalSampler;\\r\\n\\r\\nuniform mat3 translationMatrix;\\r\\n\\r\\nuniform vec2 uViewSize;\\r\\n\\r\\nuniform vec4 uAmbientColor; // ambient color, alpha channel used for intensity.\\r\\n\\r\\nuniform vec4 uLightColor;   // light color, alpha channel used for intensity.\\r\\nuniform vec3 uLightFalloff; // light attenuation coefficients (constant, linear, quadratic)\\r\\nuniform float uLightHeight; // light height above the viewport\\r\\n\\n\\r\\nvoid main(void)\\r\\n{\\r\\nvec2 texCoord = gl_FragCoord.xy / uViewSize;\\r\\ntexCoord.y = 1.0 - texCoord.y; // FBOs are flipped.\\r\\n\\r\\nvec4 diffuseColor = texture2D(uSampler, texCoord);\\r\\nvec4 normalColor = texture2D(uNormalSampler, texCoord);\\r\\n\\r\\n// if no normal color here, just discard\\r\\nif (normalColor.a == 0.0) discard;\\r\\n\\n\\r\\n    // simplified lambert shading that makes assumptions for ambient color\\r\\n\\r\\n    // compute Distance\\r\\n//    float D = length(lightVector);\\r\\n    float D = 1.0;\\r\\n    \\r\\n    // normalize vectors\\r\\n    vec3 N = normalize(normalColor.xyz * 2.0 - 1.0);\\r\\n//    vec3 L = normalize(lightVector);\\r\\n    vec3 L = vec3(1.0, 1.0, 1.0);\\r\\n    \\r\\n    // pre-multiply light color with intensity\\r\\n    // then perform \\\"N dot L\\\" to determine our diffuse\\r\\n    vec3 diffuse = (uLightColor.rgb * uLightColor.a) * max(dot(N, L), 0.0);\\r\\n    \\r\\n    // pre-multiply ambient color with intensity\\r\\n//    vec3 ambient = uAmbientColor.rgb * uAmbientColor.a;\\r\\n    \\r\\n    // calculate attenuation\\r\\n//    float attenuation = 1.0 / (uLightFalloff.x + (uLightFalloff.y * D) + (uLightFalloff.z * D * D));\\r\\n    \\r\\n    // calculate final intesity and color, then combine\\r\\n//    vec3 intensity = ambient + diffuse * attenuation;\\r\\n//    vec3 finalColor = diffuseColor.rgb * intensity;\\r\\n    vec3 finalColor = diffuseColor.rgb * diffuse;\\r\\n\\r\\n    // calculate just ambient light color, most lights will override this frag\\r\\n//    vec3 ambientColor = uLightColor.rgb * uLightColor.a;\\r\\n//    gl_FragColor = vec4(diffuseColor.rgb * ambientColor, diffuseColor.a);\\r\\n    gl_FragColor = vec4(finalColor, diffuseColor.a);\\r\\n}\\r\\n\"\r\n    );\r\n}\r\n\r\nAmbientLightShader.prototype = Object.create(LightShader.prototype);\r\nAmbientLightShader.prototype.constructor = AmbientLightShader;\r\nmodule.exports = AmbientLightShader;\r\n\r\nPIXI.ShaderManager.registerPlugin('ambientLightShader', AmbientLightShader);\r\n","/**\r\n * Excuse the mess, haven't cleaned this up yet!\r\n */\r\n\r\n\r\n\r\n/**\r\n * @class\r\n * @extends PIXI.DisplayObject\r\n * @memberof PIXI.lights\r\n *\r\n * @param [color=0xFFFFFF] {number} The color of the light.\r\n * @param [brightness=1] {number} The brightness of the light, in range [0, 1].\r\n */\r\nfunction Light(color, brightness, vertices, indices) {\r\n    if (this.constructor === Light) {\r\n        throw new Error('Light is an abstract base class, it should not be created directly!');\r\n    }\r\n    \r\n    PIXI.DisplayObject.call(this);\r\n\r\n    /**\r\n     * An array of vertices\r\n     *\r\n     * @member {Float32Array}\r\n     */\r\n    this.vertices = vertices || new Float32Array(8);\r\n\r\n    /**\r\n     * An array containing the indices of the vertices\r\n     *\r\n     * @member {Uint16Array}\r\n     */\r\n    this.indices = indices || new Uint16Array([0,1,2, 0,2,3]);\r\n\r\n    /**\r\n     * The blend mode to be applied to the light.\r\n     *\r\n     * @member {number}\r\n     * @default CONST.BLEND_MODES.ADD;\r\n     */\r\n    this.blendMode = PIXI.BLEND_MODES.ADD;\r\n\r\n    /**\r\n     * The draw mode to be applied to the light geometry.\r\n     *\r\n     * @member {number}\r\n     * @default CONST.DRAW_MODES.TRIANGLES;\r\n     */\r\n    this.drawMode = PIXI.DRAW_MODES.TRIANGLES;\r\n\r\n    /**\r\n     * When set, the renderer will reupload the geometry data.\r\n     * \r\n     * @member {boolean}\r\n     */\r\n    this.needsUpdate = true;\r\n\r\n    /**\r\n     * The height of the light from the viewport.\r\n     *\r\n     * @member {number}\r\n     * @default 0.075\r\n     */\r\n    this.height = 0.075;\r\n\r\n    /**\r\n     * The falloff attenuation coeficients.\r\n     *\r\n     * @member {number[]}\r\n     * @default [0.75, 3, 7]\r\n     */\r\n    this.falloff = [0.75, 3, 7];\r\n\r\n    /**\r\n     * The name of the shader plugin to use.\r\n     *\r\n     * @member {string}\r\n     */\r\n    this.shaderName = null;\r\n\r\n    // webgl buffers\r\n    this._vertexBuffer = null;\r\n    this._indexBuffer = null;\r\n\r\n    // color and brightness are exposed through setters\r\n    this._color = 0x4d4d59;\r\n    this._colorRgba = [0.3, 0.3, 0.35, 0.8];\r\n\r\n    // run the color setter\r\n    if (color || color === 0) {\r\n        this.color = color;\r\n    }\r\n    \r\n    // run the brightness setter\r\n    if (brightness || brightness === 0) {\r\n        this.brightness = brightness;\r\n    }\r\n}\r\n\r\nLight.prototype = Object.create(PIXI.DisplayObject.prototype);\r\nLight.prototype.constructor = Light;\r\nmodule.exports = Light;\r\n\r\nObject.defineProperties(Light.prototype, {\r\n    /**\r\n     * The color of the lighting.\r\n     *\r\n     * @member {number}\r\n     * @memberof Light#\r\n     */\r\n    color: {\r\n        get: function ()\r\n        {\r\n            return this._color;\r\n        },\r\n        set: function (val)\r\n        {\r\n            this._color = val;\r\n            PIXI.utils.hex2rgb(val, this._colorRgba);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * The brightness of this lighting. Normalized in the range [0, 1].\r\n     *\r\n     * @member {number}\r\n     * @memberof Light#\r\n     */\r\n    brightness: {\r\n        get: function ()\r\n        {\r\n            return this._colorRgba[3];\r\n        },\r\n        set: function (val)\r\n        {\r\n            this._colorRgba[3] = val;\r\n        }\r\n    }\r\n});\r\n\r\nLight.prototype.syncShader = function (shader) {\r\n    shader.uniforms.uLightColor.value[0] = this._colorRgba[0];\r\n    shader.uniforms.uLightColor.value[1] = this._colorRgba[1];\r\n    shader.uniforms.uLightColor.value[2] = this._colorRgba[2];\r\n    shader.uniforms.uLightColor.value[3] = this._colorRgba[3];\r\n\r\n    shader.uniforms.uLightHeight.value = this.height;\r\n\r\n    shader.uniforms.uLightFalloff.value[0] = this.falloff[0];\r\n    shader.uniforms.uLightFalloff.value[1] = this.falloff[1];\r\n    shader.uniforms.uLightFalloff.value[2] = this.falloff[2];\r\n};\r\n\r\nLight.prototype.renderWebGL = function (renderer)\r\n{\r\n    // add lights to their renderer on the normals pass\r\n    if (!renderer.renderingNormals) {\r\n        return;\r\n    }\r\n\r\n    // I actually don't want to interrupt the current batch, so don't set light as the current object renderer.\r\n    // Light renderer works a bit differently in that lights are draw individually on flush (called by WebGLDeferredRenderer).\r\n    //renderer.setObjectRenderer(renderer.plugins.lights);\r\n\r\n    renderer.plugins.lights.render(this);\r\n};\r\n\r\nLight.prototype.destroy = function ()\r\n{\r\n    PIXI.DisplayObject.prototype.destroy.call(this);\r\n\r\n    // TODO: Destroy buffers!\r\n};\r\n\r\nLight.DRAW_MODES = {\r\n    \r\n};\r\n","\r\n\r\n/**\r\n * @class\r\n * @extends PIXI.Shader\r\n * @memberof PIXI.lights\r\n * @param shaderManager {ShaderManager} The WebGL shader manager this shader works for.\r\n */\r\nfunction LightShader(shaderManager, vertexSrc, fragmentSrc, customUniforms, customAttributes) {\r\n    var uniforms = {\r\n        translationMatrix:  { type: 'mat3', value: new Float32Array(9) },\r\n        projectionMatrix:   { type: 'mat3', value: new Float32Array(9) },\r\n\r\n        // textures from the previously rendered FBOs\r\n        uSampler:       { type: 'sampler2D', value: null },\r\n        uNormalSampler: { type: 'sampler2D', value: null },\r\n\r\n        // size of the renderer viewport\r\n        uViewSize:      { type: '2f', value: new Float32Array(2) },\r\n\r\n        // light color, alpha channel used for intensity.\r\n        uLightColor:    { type: '4f', value: new Float32Array([1, 1, 1, 1]) },\r\n\r\n        // light falloff attenuation coefficients\r\n        uLightFalloff:  { type: '3f', value: new Float32Array([0, 0, 0]) },\r\n\r\n        // height of the light above the viewport\r\n        uLightHeight: { type: '1f', value: 0.075 }\r\n    };\r\n\r\n    if (customUniforms)\r\n    {\r\n        for (var u in customUniforms)\r\n        {\r\n            uniforms[u] = customUniforms[u];\r\n        }\r\n    }\r\n\r\n    var attributes = {\r\n        aVertexPosition: 0\r\n    };\r\n\r\n    if (customAttributes)\r\n    {\r\n        for (var a in customAttributes)\r\n        {\r\n            attributes[a] = customAttributes[a];\r\n        }\r\n    }\r\n\r\n    PIXI.Shader.call(this, shaderManager, vertexSrc || LightShader.defaultVertexSrc, fragmentSrc, uniforms, attributes);\r\n}\r\n\r\nLightShader.prototype = Object.create(PIXI.Shader.prototype);\r\nLightShader.prototype.constructor = LightShader;\r\nmodule.exports = LightShader;\r\n\r\nLightShader.defaultVertexSrc = \"#define GLSLIFY 1\\n\\nprecision lowp float;\\r\\n\\r\\nattribute vec2 aVertexPosition;\\r\\n\\r\\nuniform mat3 translationMatrix;\\r\\nuniform mat3 projectionMatrix;\\r\\n\\r\\nvoid main(void) {\\r\\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\\r\\n}\\r\\n\";\r\n","var Light = require('../light/Light');\r\n\r\n/**\r\n * @class\r\n * @extends PIXI.lights.Light\r\n * @memberof PIXI.lights\r\n *\r\n * @param [color=0xFFFFFF] {number} The color of the light.\r\n * @param [brightness=1] {number} The intensity of the light.\r\n * @param [radius=256] {number} The distance the light reaches.\r\n * @param [decay=1] {number} The decay factor of the light. Physically correct lights should be 2.\r\n */\r\nfunction PointLight(color, brightness, radius, decay) {\r\n    var shape = new PIXI.math.Circle(200, 200, radius || 256),\r\n        mesh = shape.getMesh();\r\n\r\n    Light.call(this, color, brightness, mesh.vertices, mesh.indices);\r\n\r\n    this._syncShader = Light.prototype.syncShader;\r\n\r\n    this.radius = shape.radius;\r\n    this.decay = decay || 0;\r\n    this.drawMode = PIXI.DRAW_MODES.TRIANGLE_FAN;\r\n    this.shaderName = 'pointLightShader';\r\n}\r\n\r\nPointLight.prototype = Object.create(Light.prototype);\r\nPointLight.prototype.constructor = PointLight;\r\nmodule.exports = PointLight;\r\n\r\nPointLight.prototype.syncShader = function (shader) {\r\n    this._syncShader(shader);\r\n\r\n    shader.uniforms.uLightRadius.value = this.radius;\r\n}\r\n","var LightShader = require('../light/LightShader');\r\n\r\n\r\n/**\r\n * @class\r\n * @extends PIXI.Shader\r\n * @memberof PIXI.lights\r\n * @param shaderManager {ShaderManager} The WebGL shader manager this shader works for.\r\n */\r\nfunction PointLightShader(shaderManager) {\r\n    LightShader.call(this,\r\n        shaderManager,\r\n        // vertex shader\r\n        null,\r\n        // fragment shader\r\n        \"#define GLSLIFY 1\\n\\nprecision lowp float;\\r\\n\\r\\n// imports the common uniforms like samplers, and ambient color\\r\\nuniform sampler2D uSampler;\\r\\nuniform sampler2D uNormalSampler;\\r\\n\\r\\nuniform mat3 translationMatrix;\\r\\n\\r\\nuniform vec2 uViewSize;\\r\\n\\r\\nuniform vec4 uAmbientColor; // ambient color, alpha channel used for intensity.\\r\\n\\r\\nuniform vec4 uLightColor;   // light color, alpha channel used for intensity.\\r\\nuniform vec3 uLightFalloff; // light attenuation coefficients (constant, linear, quadratic)\\r\\nuniform float uLightHeight; // light height above the viewport\\r\\n\\n\\r\\nuniform float uLightRadius;\\r\\n\\r\\nvoid main()\\r\\n{\\r\\n    vec2 texCoord = gl_FragCoord.xy / uViewSize;\\r\\n    texCoord.y = 1.0 - texCoord.y; // FBOs positions are flipped.\\r\\n\\r\\n    vec4 normalColor = texture2D(uNormalSampler, texCoord);\\r\\n    normalColor.g = 1.0 - normalColor.g; // Green layer is flipped Y coords.\\r\\n\\r\\n    // bail out early when normal has no data\\r\\n    if (normalColor.a == 0.0) discard;\\r\\n\\r\\n    vec2 lightPosition = translationMatrix[2].xy / uViewSize;\\r\\n\\r\\n    // the directional vector of the light\\r\\n    vec3 lightVector = vec3(lightPosition - texCoord, uLightHeight);\\r\\n\\r\\n    // correct for aspect ratio\\r\\n    lightVector.x *= uViewSize.x / uViewSize.y;\\r\\n\\r\\n    // compute Distance\\r\\n    float D = length(lightVector);\\r\\n\\r\\n    // bail out early when pixel outside of light sphere\\r\\n    if (D > uLightRadius) discard;\\r\\n\\r\\n    // normalize vectors\\r\\n    vec3 N = normalize(normalColor.xyz * 2.0 - 1.0);\\r\\n    vec3 L = normalize(lightVector);\\r\\n    \\r\\n    // pre-multiply light color with intensity\\r\\n    // then perform \\\"N dot L\\\" to determine our diffuse\\r\\n    vec3 diffuse = (uLightColor.rgb * uLightColor.a) * max(dot(N, L), 0.0);\\r\\n\\r\\n    // calculate attenuation\\r\\n    float attenuation = 1.0 / (uLightFalloff.x + (uLightFalloff.y * D) + (uLightFalloff.z * D * D));\\r\\n    \\r\\n    // calculate final intesity and color, then combine\\r\\n    vec3 intensity = diffuse * attenuation;\\r\\n    vec4 diffuseColor = texture2D(uSampler, texCoord);\\r\\n    vec3 finalColor = diffuseColor.rgb * intensity;\\r\\n\\r\\n    gl_FragColor = vec4(finalColor, diffuseColor.a);\\r\\n}\",\r\n        // custom uniforms\r\n        {\r\n            // height of the light above the viewport\r\n            uLightRadius:   { type: '1f', value: 1 }\r\n        }\r\n    );\r\n}\r\n\r\nPointLightShader.prototype = Object.create(LightShader.prototype);\r\nPointLightShader.prototype.constructor = PointLightShader;\r\nmodule.exports = PointLightShader;\r\n\r\nPIXI.ShaderManager.registerPlugin('pointLightShader', PointLightShader);\r\n","/**\r\n *\r\n * @class\r\n * @private\r\n * @memberof PIXI.lights\r\n * @extends PIXI.ObjectRenderer\r\n * @param renderer {WebGLRenderer} The renderer this sprite batch works for.\r\n */\r\nfunction LightRenderer(renderer)\r\n{\r\n    PIXI.ObjectRenderer.call(this, renderer);\r\n\r\n    // the total number of indices in our batch, there are 6 points per quad.\r\n    var numIndices = LightRenderer.MAX_LIGHTS * 6;\r\n\r\n    /**\r\n     * Holds the indices\r\n     *\r\n     * @member {Uint16Array}\r\n     */\r\n    this.indices = new Uint16Array(numIndices);\r\n\r\n    //TODO this could be a single buffer shared amongst all renderers as we reuse this set up in most renderers\r\n    for (var i = 0, j = 0; i < numIndices; i += 6, j += 4)\r\n    {\r\n        this.indices[i + 0] = j + 0;\r\n        this.indices[i + 1] = j + 1;\r\n        this.indices[i + 2] = j + 2;\r\n        this.indices[i + 3] = j + 0;\r\n        this.indices[i + 4] = j + 2;\r\n        this.indices[i + 5] = j + 3;\r\n    }\r\n\r\n    /**\r\n     * The current size of the batch, each render() call adds to this number.\r\n     *\r\n     * @member {number}\r\n     */\r\n    this.currentBatchSize = 0;\r\n\r\n    /**\r\n     * The current lights in the batch.\r\n     *\r\n     * @member {Light[]}\r\n     */\r\n    this.lights = [];\r\n}\r\n\r\nLightRenderer.MAX_LIGHTS = 500;\r\n\r\nLightRenderer.prototype = Object.create(PIXI.ObjectRenderer.prototype);\r\nLightRenderer.prototype.constructor = LightRenderer;\r\nmodule.exports = LightRenderer;\r\n\r\nPIXI.WebGLRenderer.registerPlugin('lights', LightRenderer);\r\n\r\n/**\r\n * Renders the light object.\r\n *\r\n * @param light {Light} the light to render\r\n */\r\nLightRenderer.prototype.render = function (light)\r\n{\r\n    this.lights[this.currentBatchSize++] = light;\r\n};\r\n\r\nLightRenderer.prototype.flush = function ()\r\n{\r\n    var renderer = this.renderer,\r\n        gl = renderer.gl,\r\n        diffuseTexture = renderer.diffuseTexture,\r\n        normalsTexture = renderer.normalsTexture,\r\n        lastShader = null;\r\n\r\n    for (var i = 0; i < this.currentBatchSize; ++i)\r\n    {\r\n        var light = this.lights[i],\r\n            shader = light.shader || this.renderer.shaderManager.plugins[light.shaderName];\r\n\r\n        if (!light._vertexBuffer)\r\n        {\r\n            this._initWebGL(light);\r\n        }\r\n\r\n        // set shader if needed\r\n        if (shader !== lastShader) {\r\n            lastShader = shader;\r\n            renderer.shaderManager.setShader(shader);\r\n        }\r\n\r\n        renderer.blendModeManager.setBlendMode(light.blendMode);\r\n\r\n        // set uniforms, can do some optimizations here.\r\n        shader.uniforms.uViewSize.value[0] = renderer.width;\r\n        shader.uniforms.uViewSize.value[1] = renderer.height;\r\n\r\n        light.worldTransform.toArray(true, shader.uniforms.translationMatrix.value);\r\n        renderer.currentRenderTarget.projectionMatrix.toArray(true, shader.uniforms.projectionMatrix.value);\r\n\r\n        light.syncShader(shader);\r\n\r\n        shader.syncUniforms();\r\n\r\n        // have to set these manually due to the way pixi base shader makes assumptions about texture units\r\n        gl.uniform1i(shader.uniforms.uSampler._location, 0);\r\n        gl.uniform1i(shader.uniforms.uNormalSampler._location, 1);\r\n\r\n        if (!light.needsUpdate)\r\n        {\r\n            // update vertex data\r\n            gl.bindBuffer(gl.ARRAY_BUFFER, light._vertexBuffer);\r\n            gl.bufferSubData(gl.ARRAY_BUFFER, 0, light.vertices);\r\n            gl.vertexAttribPointer(shader.attributes.aVertexPosition, 2, gl.FLOAT, false, 0, 0);\r\n\r\n            // bind diffuse texture\r\n            gl.activeTexture(gl.TEXTURE0);\r\n            gl.bindTexture(gl.TEXTURE_2D, diffuseTexture.baseTexture._glTextures[gl.id]);\r\n\r\n            // bind normal texture\r\n            gl.activeTexture(gl.TEXTURE1);\r\n            gl.bindTexture(gl.TEXTURE_2D, normalsTexture.baseTexture._glTextures[gl.id]);\r\n\r\n            // update indices\r\n            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, light._indexBuffer);\r\n            gl.bufferSubData(gl.ELEMENT_ARRAY_BUFFER, 0, light.indices);\r\n        }\r\n        else\r\n        {\r\n            light.needsUpdate = false;\r\n\r\n            // upload vertex data\r\n            gl.bindBuffer(gl.ARRAY_BUFFER, light._vertexBuffer);\r\n            gl.bufferData(gl.ARRAY_BUFFER, light.vertices, gl.STATIC_DRAW);\r\n            gl.vertexAttribPointer(shader.attributes.aVertexPosition, 2, gl.FLOAT, false, 0, 0);\r\n\r\n            // bind diffuse texture\r\n            gl.activeTexture(gl.TEXTURE0);\r\n            gl.bindTexture(gl.TEXTURE_2D, diffuseTexture.baseTexture._glTextures[gl.id]);\r\n\r\n            // bind normal texture\r\n            gl.activeTexture(gl.TEXTURE1);\r\n            gl.bindTexture(gl.TEXTURE_2D, normalsTexture.baseTexture._glTextures[gl.id]);\r\n\r\n            // static upload of index buffer\r\n            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, light._indexBuffer);\r\n            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, light.indices, gl.STATIC_DRAW);\r\n        }\r\n\r\n        gl.drawElements(gl.TRIANGLE_FAN, light.indices.length, gl.UNSIGNED_SHORT, 0);\r\n    }\r\n\r\n    this.currentBatchSize = 0;\r\n};\r\n\r\n/**\r\n * Prepares all the buffers to render this light.\r\n *\r\n * @param light {Light} The light object to prepare for rendering.\r\n */\r\nLightRenderer.prototype._initWebGL = function (light)\r\n{\r\n    var gl = this.renderer.gl;\r\n\r\n    // create the buffers\r\n    light._vertexBuffer = gl.createBuffer();\r\n    light._indexBuffer = gl.createBuffer();\r\n\r\n    gl.bindBuffer(gl.ARRAY_BUFFER, light._vertexBuffer);\r\n    gl.bufferData(gl.ARRAY_BUFFER, light.vertices, gl.DYNAMIC_DRAW);\r\n\r\n    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, light._indexBuffer);\r\n    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, light.indices, gl.STATIC_DRAW);\r\n};\r\n\r\nLightRenderer.prototype.destroy = function ()\r\n{\r\n    \r\n};\r\n","/**\r\n * The WebGLDeferredRenderer draws the scene and all its content onto a webGL enabled canvas. This renderer\r\n * should be used for browsers that support webGL. This Render works by automatically managing webGLBatchs.\r\n * So no need for Sprite Batches or Sprite Clouds.\r\n * Don't forget to add the view to your DOM or you will not see anything :)\r\n *\r\n * @class\r\n * @memberof PIXI.lights\r\n * @extends PIXI.SystemRenderer\r\n * @param [width=0] {number} the width of the canvas view\r\n * @param [height=0] {number} the height of the canvas view\r\n * @param [options] {object} The optional renderer parameters\r\n * @param [options.view] {HTMLCanvasElement} the canvas to use as a view, optional\r\n * @param [options.transparent=false] {boolean} If the render view is transparent, default false\r\n * @param [options.autoResize=false] {boolean} If the render view is automatically resized, default false\r\n * @param [options.antialias=false] {boolean} sets antialias. If not available natively then FXAA antialiasing is used\r\n * @param [options.forceFXAA=false] {boolean} forces FXAA antialiasing to be used over native. FXAA is faster, but may not always lok as great\r\n * @param [options.resolution=1] {number} the resolution of the renderer retina would be 2\r\n * @param [options.clearBeforeRender=true] {boolean} This sets if the CanvasRenderer will clear the canvas or\r\n *      not before the new render pass.\r\n * @param [options.preserveDrawingBuffer=false] {boolean} enables drawing buffer preservation, enable this if\r\n *      you need to call toDataUrl on the webgl context.\r\n */\r\nfunction WebGLDeferredRenderer(width, height, options)\r\n{\r\n    options = options || {};\r\n\r\n    this.renderingNormals = false;\r\n\r\n    PIXI.WebGLRenderer.call(this, width, height, options);\r\n}\r\n\r\nWebGLDeferredRenderer.prototype = Object.create(PIXI.WebGLRenderer.prototype);\r\nWebGLDeferredRenderer.prototype.constructor = WebGLDeferredRenderer;\r\nmodule.exports = WebGLDeferredRenderer;\r\n\r\n/** @lends PIXI.DisplayObject# */\r\nObject.assign(WebGLDeferredRenderer.prototype, {\r\n    /**\r\n     * Initializes the context and necessary framebuffers.\r\n     */\r\n    _initContext: function ()\r\n    {\r\n        // call parent init\r\n        PIXI.WebGLRenderer.prototype._initContext.call(this);\r\n\r\n        // first create our render targets.\r\n        this.diffuseTexture = new PIXI.RenderTexture(this, this.width, this.height, null, this.resolution);\r\n        this.normalsTexture = new PIXI.RenderTexture(this, this.width, this.height, null, this.resolution);\r\n    },\r\n\r\n    render: function (object)\r\n    {\r\n        // render diffuse\r\n        this.renderingNormals = false;\r\n        this.diffuseTexture.render(object);\r\n\r\n        // render normals\r\n        this.renderingNormals = true;\r\n        this.normalsTexture.render(object);\r\n\r\n        // render lights\r\n        this.setRenderTarget(this.renderTarget);\r\n        this.setObjectRenderer(this.plugins.lights);\r\n        this.plugins.lights.flush();\r\n    }\r\n});\r\n","/**\r\n * Creates vertices and indices arrays to describe this circle.\r\n * \r\n * @param [totalSegments=40] {number} Total segments to build for the circle mesh.\r\n * @param [verticesOutput] {Float32Array} An array to output the vertices into. Length must be\r\n *  `((totalSegments + 2) * 2)` or more. If not passed it is created for you.\r\n * @param [indicesOutput] {Uint16Array} An array to output the indices into, in gl.TRIANGLE_FAN format. Length must\r\n *  be `(totalSegments + 3)` or more. If not passed it is created for you.\r\n */\r\nPIXI.math.Circle.prototype.getMesh = function (totalSegments, vertices, indices)\r\n{\r\n    totalSegments = totalSegments || 40;\r\n\r\n    vertices = vertices || new Float32Array((totalSegments + 1) * 2);\r\n    indices = indices || new Uint16Array(totalSegments + 1);\r\n\r\n    var seg = (Math.PI * 2) / totalSegments,\r\n        indicesIndex = -1;\r\n\r\n    indices[++indicesIndex] = indicesIndex;\r\n\r\n    for (var i = 0; i <= totalSegments; ++i)\r\n    {\r\n        var index = i*2;\r\n        var angle = seg * i;\r\n\r\n        vertices[index] = Math.cos(angle) * this.radius;\r\n        vertices[index+1] = Math.sin(angle) * this.radius;\r\n\r\n        indices[++indicesIndex] = indicesIndex;\r\n    }\r\n\r\n    indices[indicesIndex] = 1;\r\n\r\n    return {\r\n        vertices: vertices,\r\n        indices: indices\r\n    };\r\n};\r\n"],"sourceRoot":"./"}