!function t(e,i,r){function o(a,l){if(!i[a]){if(!e[a]){var s="function"==typeof require&&require;if(!l&&s)return s(a,!0);if(n)return n(a,!0);var h=new Error("Cannot find module '"+a+"'");throw h.code="MODULE_NOT_FOUND",h}var u=i[a]={exports:{}};e[a][0].call(u.exports,function(t){var i=e[a][1][t];return o(i?i:t)},u,u.exports,t,e,i,r)}return i[a].exports}for(var n="function"==typeof require&&require,a=0;a<r.length;a++)o(r[a]);return o}({1:[function(t,e,i){e.exports=PIXI.lights={Light:t("./lights/light/Light"),LightShader:t("./lights/light/LightShader"),AmbientLight:t("./lights/ambientLight/AmbientLight"),AmbientLightShader:t("./lights/ambientLight/AmbientLightShader"),PointLight:t("./lights/pointLight/PointLight"),PointLightShader:t("./lights/pointLight/PointLightShader"),DirectionalLight:t("./lights/directionalLight/DirectionalLight"),DirectionalLightShader:t("./lights/directionalLight/DirectionalLightShader"),LightRenderer:t("./renderers/LightRenderer"),WebGLDeferredRenderer:t("./renderers/WebGLDeferredRenderer"),WireframeShader:t("./lights/WireframeShader")},t("./lightSpriteMixin"),t("./shapeMeshMixin")},{"./lightSpriteMixin":2,"./lights/WireframeShader":3,"./lights/ambientLight/AmbientLight":4,"./lights/ambientLight/AmbientLightShader":5,"./lights/directionalLight/DirectionalLight":6,"./lights/directionalLight/DirectionalLightShader":7,"./lights/light/Light":8,"./lights/light/LightShader":9,"./lights/pointLight/PointLight":10,"./lights/pointLight/PointLightShader":11,"./renderers/LightRenderer":12,"./renderers/WebGLDeferredRenderer":13,"./shapeMeshMixin":14}],2:[function(t,e,i){PIXI.Sprite.prototype._renderWebGL=function(t){this._originalTexture||(this._originalTexture=this._texture),this._texture=t.renderingNormals&&this.normalTexture?this.normalTexture:this._originalTexture,t.setObjectRenderer(t.plugins.sprite),t.plugins.sprite.render(this)}},{}],3:[function(t,e,i){function r(t){PIXI.Shader.call(this,t,["precision lowp float;","attribute vec2 aVertexPosition;","uniform mat3 projectionMatrix;","void main(void) {","    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);","}"].join("\n"),["void main() {","    gl_FragColor = vec4(0, 0, 0, 1);","}"].join("\n"),{translationMatrix:{type:"mat3",value:new Float32Array(9)},projectionMatrix:{type:"mat3",value:new Float32Array(9)}},{aVertexPosition:0})}r.prototype=Object.create(PIXI.Shader.prototype),r.prototype.constructor=r,e.exports=r,PIXI.ShaderManager.registerPlugin("wireframeShader",r)},{}],4:[function(t,e,i){function r(t,e){o.call(this,t,e),this.shaderName="ambientLightShader"}var o=t("../light/Light");r.prototype=Object.create(o.prototype),r.prototype.constructor=r,e.exports=r,r.prototype.renderWebGL=function(t){t.renderingNormals&&t.plugins.lights.render(this)}},{"../light/Light":8}],5:[function(t,e,i){function r(t){o.call(this,t,null,'#define GLSLIFY 1\n\nprecision lowp float;\n\nuniform sampler2D uSampler;\nuniform sampler2D uNormalSampler;\n\nuniform mat3 translationMatrix;\n\nuniform vec2 uViewSize;     // size of the viewport\n\nuniform vec4 uLightColor;   // light color, alpha channel used for intensity.\nuniform vec3 uLightFalloff; // light attenuation coefficients (constant, linear, quadratic)\nuniform float uLightHeight; // light height above the viewport\n\n\nvoid main(void)\n{\nvec2 texCoord = gl_FragCoord.xy / uViewSize;\ntexCoord.y = 1.0 - texCoord.y; // FBOs positions are flipped.\n\nvec4 normalColor = texture2D(uNormalSampler, texCoord);\nnormalColor.g = 1.0 - normalColor.g; // Green layer is flipped Y coords.\n\n// bail out early when normal has no data\nif (normalColor.a == 0.0) discard;\n\n\n    // simplified lambert shading that makes assumptions for ambient color\n\n    // compute Distance\n    float D = 1.0;\n    \n    // normalize vectors\n    vec3 N = normalize(normalColor.xyz * 2.0 - 1.0);\n    vec3 L = vec3(1.0, 1.0, 1.0);\n    \n    // pre-multiply light color with intensity\n    // then perform "N dot L" to determine our diffuse\n    vec3 diffuse = (uLightColor.rgb * uLightColor.a) * max(dot(N, L), 0.0);\n\n    vec4 diffuseColor = texture2D(uSampler, texCoord);\n    vec3 finalColor = diffuseColor.rgb * diffuse;\n\n    gl_FragColor = vec4(finalColor, diffuseColor.a);\n}\n')}var o=t("../light/LightShader");r.prototype=Object.create(o.prototype),r.prototype.constructor=r,e.exports=r,PIXI.ShaderManager.registerPlugin("ambientLightShader",r)},{"../light/LightShader":9}],6:[function(t,e,i){function r(t,e,i){o.call(this,t,e),this.target=i,this._directionVector=new PIXI.Point,this._updateTransform=o.prototype.updateTransform,this._syncShader=o.prototype.syncShader,this.shaderName="directionalLightShader"}var o=t("../light/Light");r.prototype=Object.create(o.prototype),r.prototype.constructor=r,e.exports=r,r.prototype.updateTransform=function(){this._updateTransform();var t=this._directionVector,e=this.worldTransform,i=this.target.worldTransform?this.target.worldTransform.tx:this.target.x,r=this.target.worldTransform?this.target.worldTransform.ty:this.target.y;t.x=e.tx-i,t.y=e.ty-r;var o=Math.sqrt(t.x*t.x+t.y*t.y);t.x/=o,t.y/=o},r.prototype.syncShader=function(t){this._syncShader(t),t.uniforms.uLightDirection.value[0]=this._directionVector.x,t.uniforms.uLightDirection.value[1]=this._directionVector.y}},{"../light/Light":8}],7:[function(t,e,i){function r(t){o.call(this,t,null,'#define GLSLIFY 1\n\nprecision lowp float;\n\n// imports the common uniforms like samplers, and ambient/light color\nuniform sampler2D uSampler;\nuniform sampler2D uNormalSampler;\n\nuniform mat3 translationMatrix;\n\nuniform vec2 uViewSize;     // size of the viewport\n\nuniform vec4 uLightColor;   // light color, alpha channel used for intensity.\nuniform vec3 uLightFalloff; // light attenuation coefficients (constant, linear, quadratic)\nuniform float uLightHeight; // light height above the viewport\n\n\nuniform vec2 uLightDirection;\n\nvoid main()\n{\nvec2 texCoord = gl_FragCoord.xy / uViewSize;\ntexCoord.y = 1.0 - texCoord.y; // FBOs positions are flipped.\n\nvec4 normalColor = texture2D(uNormalSampler, texCoord);\nnormalColor.g = 1.0 - normalColor.g; // Green layer is flipped Y coords.\n\n// bail out early when normal has no data\nif (normalColor.a == 0.0) discard;\n\n\n    // the directional vector of the light\n    vec3 lightVector = vec3(uLightDirection, uLightHeight);\n\n    // compute Distance\n    float D = length(lightVector);\n\n// normalize vectors\nvec3 N = normalize(normalColor.xyz * 2.0 - 1.0);\nvec3 L = normalize(lightVector);\n\n// pre-multiply light color with intensity\n// then perform "N dot L" to determine our diffuse\nvec3 diffuse = (uLightColor.rgb * uLightColor.a) * max(dot(N, L), 0.0);\n\n\n    // calculate attenuation\n    float attenuation = 1.0;\n\n// calculate final intesity and color, then combine\nvec3 intensity = diffuse * attenuation;\nvec4 diffuseColor = texture2D(uSampler, texCoord);\nvec3 finalColor = diffuseColor.rgb * intensity;\n\ngl_FragColor = vec4(finalColor, diffuseColor.a);\n\n}\n',{uLightDirection:{type:"2f",value:new Float32Array(2)}})}var o=t("../light/LightShader");r.prototype=Object.create(o.prototype),r.prototype.constructor=r,e.exports=r,PIXI.ShaderManager.registerPlugin("directionalLightShader",r)},{"../light/LightShader":9}],8:[function(t,e,i){function r(t,e,i,o){if(this.constructor===r)throw new Error("Light is an abstract base class, it should not be created directly!");PIXI.DisplayObject.call(this),this.vertices=i||new Float32Array(8),this.indices=o||new Uint16Array([0,1,2,0,2,3]),this.blendMode=PIXI.BLEND_MODES.ADD,this.drawMode=PIXI.DRAW_MODES.TRIANGLES,this.needsUpdate=!0,this.height=.075,this.falloff=[.75,3,20],this.shaderName=null,this.useViewportQuad=!0,this._vertexBuffer=null,this._indexBuffer=null,this._color=5066073,this._colorRgba=[.3,.3,.35,.8],(t||0===t)&&(this.color=t),(e||0===e)&&(this.brightness=e)}r.prototype=Object.create(PIXI.DisplayObject.prototype),r.prototype.constructor=r,e.exports=r,Object.defineProperties(r.prototype,{color:{get:function(){return this._color},set:function(t){this._color=t,PIXI.utils.hex2rgb(t,this._colorRgba)}},brightness:{get:function(){return this._colorRgba[3]},set:function(t){this._colorRgba[3]=t}}}),r.prototype.syncShader=function(t){t.uniforms.uUseViewportQuad.value=this.useViewportQuad,t.uniforms.uLightColor.value[0]=this._colorRgba[0],t.uniforms.uLightColor.value[1]=this._colorRgba[1],t.uniforms.uLightColor.value[2]=this._colorRgba[2],t.uniforms.uLightColor.value[3]=this._colorRgba[3],t.uniforms.uLightHeight.value=this.height,t.uniforms.uLightFalloff.value[0]=this.falloff[0],t.uniforms.uLightFalloff.value[1]=this.falloff[1],t.uniforms.uLightFalloff.value[2]=this.falloff[2]},r.prototype.renderWebGL=function(t){t.renderingNormals&&t.plugins.lights.render(this)},r.prototype.destroy=function(){PIXI.DisplayObject.prototype.destroy.call(this)},r.DRAW_MODES={}},{}],9:[function(t,e,i){function r(t,e,i,o,n){var a={translationMatrix:{type:"mat3",value:new Float32Array(9)},projectionMatrix:{type:"mat3",value:new Float32Array(9)},uSampler:{type:"sampler2D",value:null},uNormalSampler:{type:"sampler2D",value:null},uUseViewportQuad:{type:"bool",value:!0},uViewSize:{type:"2f",value:new Float32Array(2)},uLightColor:{type:"4f",value:new Float32Array([1,1,1,1])},uLightFalloff:{type:"3f",value:new Float32Array([0,0,0])},uLightHeight:{type:"1f",value:.075}};if(o)for(var l in o)a[l]=o[l];var s={aVertexPosition:0};if(n)for(var h in n)s[h]=n[h];PIXI.Shader.call(this,t,e||r.defaultVertexSrc,i,a,s)}r.prototype=Object.create(PIXI.Shader.prototype),r.prototype.constructor=r,e.exports=r,r.defaultVertexSrc="#define GLSLIFY 1\n\nprecision lowp float;\n\nattribute vec2 aVertexPosition;\n\nuniform bool uUseViewportQuad;\nuniform mat3 translationMatrix;\nuniform mat3 projectionMatrix;\n\nvoid main(void) {\n    if (uUseViewportQuad) {\n        gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    }\n    else\n    {\n        gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    }\n}\n"},{}],10:[function(t,e,i){function r(t,e,i){if(i=i||1/0,i!==1/0){var r=new PIXI.math.Circle(0,0,i),n=r.getMesh();o.call(this,t,e,n.vertices,n.indices),this.useViewportQuad=!1,this.drawMode=PIXI.DRAW_MODES.TRIANGLE_FAN}else o.call(this,t,e);this._syncShader=o.prototype.syncShader,this.radius=i,this.shaderName="pointLightShader"}var o=t("../light/Light");r.prototype=Object.create(o.prototype),r.prototype.constructor=r,e.exports=r,r.prototype.syncShader=function(t){this._syncShader(t),t.uniforms.uLightRadius.value=this.radius}},{"../light/Light":8}],11:[function(t,e,i){function r(t){o.call(this,t,null,'#define GLSLIFY 1\n\nprecision lowp float;\n\n// imports the common uniforms like samplers, and ambient color\nuniform sampler2D uSampler;\nuniform sampler2D uNormalSampler;\n\nuniform mat3 translationMatrix;\n\nuniform vec2 uViewSize;     // size of the viewport\n\nuniform vec4 uLightColor;   // light color, alpha channel used for intensity.\nuniform vec3 uLightFalloff; // light attenuation coefficients (constant, linear, quadratic)\nuniform float uLightHeight; // light height above the viewport\n\n\nuniform float uLightRadius;\n\nvoid main()\n{\nvec2 texCoord = gl_FragCoord.xy / uViewSize;\ntexCoord.y = 1.0 - texCoord.y; // FBOs positions are flipped.\n\nvec4 normalColor = texture2D(uNormalSampler, texCoord);\nnormalColor.g = 1.0 - normalColor.g; // Green layer is flipped Y coords.\n\n// bail out early when normal has no data\nif (normalColor.a == 0.0) discard;\n\n\n    vec2 lightPosition = translationMatrix[2].xy / uViewSize;\n\n    // the directional vector of the light\n    vec3 lightVector = vec3(lightPosition - texCoord, uLightHeight);\n\n    // correct for aspect ratio\n    lightVector.x *= uViewSize.x / uViewSize.y;\n\n    // compute Distance\n    float D = length(lightVector);\n\n    // bail out early when pixel outside of light sphere\n    if (D > uLightRadius) discard;\n\n// normalize vectors\nvec3 N = normalize(normalColor.xyz * 2.0 - 1.0);\nvec3 L = normalize(lightVector);\n\n// pre-multiply light color with intensity\n// then perform "N dot L" to determine our diffuse\nvec3 diffuse = (uLightColor.rgb * uLightColor.a) * max(dot(N, L), 0.0);\n\n\n    // calculate attenuation\n    float attenuation = 1.0 / (uLightFalloff.x + (uLightFalloff.y * D) + (uLightFalloff.z * D * D));\n\n// calculate final intesity and color, then combine\nvec3 intensity = diffuse * attenuation;\nvec4 diffuseColor = texture2D(uSampler, texCoord);\nvec3 finalColor = diffuseColor.rgb * intensity;\n\ngl_FragColor = vec4(finalColor, diffuseColor.a);\n\n}',{uLightRadius:{type:"1f",value:1}})}var o=t("../light/LightShader");r.prototype=Object.create(o.prototype),r.prototype.constructor=r,e.exports=r,PIXI.ShaderManager.registerPlugin("pointLightShader",r)},{"../light/LightShader":9}],12:[function(t,e,i){function r(t){PIXI.ObjectRenderer.call(this,t);var e=6*r.MAX_LIGHTS;this.indices=new Uint16Array(e);for(var i=0,o=0;e>i;i+=6,o+=4)this.indices[i+0]=o+0,this.indices[i+1]=o+1,this.indices[i+2]=o+2,this.indices[i+3]=o+0,this.indices[i+4]=o+2,this.indices[i+5]=o+3;this.currentBatchSize=0,this.lights=[]}r.MAX_LIGHTS=500,r.prototype=Object.create(PIXI.ObjectRenderer.prototype),r.prototype.constructor=r,e.exports=r,PIXI.WebGLRenderer.registerPlugin("lights",r),r.prototype.render=function(t){this.lights[this.currentBatchSize++]=t},r.prototype.flush=function(){for(var t=this.renderer,e=t.gl,i=t.diffuseTexture,r=t.normalsTexture,o=null,n=0;n<this.currentBatchSize;++n){var a=this.lights[n],l=a.shader||this.renderer.shaderManager.plugins[a.shaderName];a._vertexBuffer||this._initWebGL(a),l!==o&&(o=l,t.shaderManager.setShader(l)),t.blendModeManager.setBlendMode(a.blendMode),l.uniforms.uViewSize.value[0]=t.width,l.uniforms.uViewSize.value[1]=t.height,a.worldTransform.toArray(!0,l.uniforms.translationMatrix.value),t.currentRenderTarget.projectionMatrix.toArray(!0,l.uniforms.projectionMatrix.value),a.useViewportQuad&&(a.vertices[2]=a.vertices[4]=t.width,a.vertices[5]=a.vertices[7]=t.height),a.syncShader(l),l.syncUniforms(),e.uniform1i(l.uniforms.uSampler._location,0),e.uniform1i(l.uniforms.uNormalSampler._location,1),a.needsUpdate?(a.needsUpdate=!1,e.bindBuffer(e.ARRAY_BUFFER,a._vertexBuffer),e.bufferData(e.ARRAY_BUFFER,a.vertices,e.STATIC_DRAW),e.vertexAttribPointer(l.attributes.aVertexPosition,2,e.FLOAT,!1,0,0),e.activeTexture(e.TEXTURE0),e.bindTexture(e.TEXTURE_2D,i.baseTexture._glTextures[e.id]),e.activeTexture(e.TEXTURE1),e.bindTexture(e.TEXTURE_2D,r.baseTexture._glTextures[e.id]),e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,a._indexBuffer),e.bufferData(e.ELEMENT_ARRAY_BUFFER,a.indices,e.STATIC_DRAW)):(e.bindBuffer(e.ARRAY_BUFFER,a._vertexBuffer),e.bufferSubData(e.ARRAY_BUFFER,0,a.vertices),e.vertexAttribPointer(l.attributes.aVertexPosition,2,e.FLOAT,!1,0,0),e.activeTexture(e.TEXTURE0),e.bindTexture(e.TEXTURE_2D,i.baseTexture._glTextures[e.id]),e.activeTexture(e.TEXTURE1),e.bindTexture(e.TEXTURE_2D,r.baseTexture._glTextures[e.id]),e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,a._indexBuffer),e.bufferSubData(e.ELEMENT_ARRAY_BUFFER,0,a.indices)),e.drawElements(t.drawModes[a.drawMode],a.indices.length,e.UNSIGNED_SHORT,0)}this.currentBatchSize=0},r.prototype._initWebGL=function(t){var e=this.renderer.gl;t._vertexBuffer=e.createBuffer(),t._indexBuffer=e.createBuffer(),e.bindBuffer(e.ARRAY_BUFFER,t._vertexBuffer),e.bufferData(e.ARRAY_BUFFER,t.vertices,e.DYNAMIC_DRAW),e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,t._indexBuffer),e.bufferData(e.ELEMENT_ARRAY_BUFFER,t.indices,e.STATIC_DRAW)},r.prototype.destroy=function(){}},{}],13:[function(t,e,i){function r(t,e,i){i=i||{},this.renderingNormals=!1,PIXI.WebGLRenderer.call(this,t,e,i)}r.prototype=Object.create(PIXI.WebGLRenderer.prototype),r.prototype.constructor=r,e.exports=r,Object.assign(r.prototype,{_initContext:function(){PIXI.WebGLRenderer.prototype._initContext.call(this),this.diffuseTexture=new PIXI.RenderTexture(this,this.width,this.height,null,this.resolution),this.normalsTexture=new PIXI.RenderTexture(this,this.width,this.height,null,this.resolution)},render:function(t){this.renderingNormals=!1,this.diffuseTexture.render(t),this.renderingNormals=!0,this.normalsTexture.render(t),this.setRenderTarget(this.renderTarget),this.setObjectRenderer(this.plugins.lights),this.plugins.lights.flush()}})},{}],14:[function(t,e,i){PIXI.math.Circle.prototype.getMesh=function(t,e,i){t=t||40,e=e||new Float32Array(2*(t+1)),i=i||new Uint16Array(t+1);var r=2*Math.PI/t,o=-1;i[++o]=o;for(var n=0;t>=n;++n){var a=2*n,l=r*n;e[a]=Math.cos(l)*this.radius,e[a+1]=Math.sin(l)*this.radius,i[++o]=o}return i[o]=1,{vertices:e,indices:i}}},{}]},{},[1]);