{"version":3,"sources":["node_modules/browser-pack/_prelude.js","src/index","src/lights/WireframeShader.js","src/lights/ambientLight/AmbientLight.js","src/lights/ambientLight/AmbientLightShader.js","src/lights/directionalLight/DirectionalLight.js","src/lights/directionalLight/DirectionalLightShader.js","src/lights/light/Light.js","src/lights/light/LightShader.js","src/lights/pointLight/PointLight.js","src/lights/pointLight/PointLightShader.js","src/main.js","src/renderers/LightRenderer.js","src/shapeMeshMixin.js"],"names":[],"mappings":"AAAA;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"pixi-lights.js","sourceRoot":"./","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","PIXI.lights = {\n    Light:                  require('./lights/light/Light'),\n    LightShader:            require('./lights/light/LightShader'),\n\n    AmbientLight:           require('./lights/ambientLight/AmbientLight'),\n    AmbientLightShader:     require('./lights/ambientLight/AmbientLightShader'),\n\n    PointLight:             require('./lights/pointLight/PointLight'),\n    PointLightShader:       require('./lights/pointLight/PointLightShader'),\n\n    DirectionalLight:             require('./lights/directionalLight/DirectionalLight'),\n    DirectionalLightShader:       require('./lights/directionalLight/DirectionalLightShader'),\n\n    LightRenderer:          require('./renderers/LightRenderer'),\n\n    WireframeShader:        require('./lights/WireframeShader')\n};\n\nObject.assign(PIXI.lights, require('./main'));\n\nmodule.exports = PIXI.lights;\n\nrequire('./shapeMeshMixin');\n","var main = require('../main');\n\n\n/**\n * @class\n * @extends PIXI.Shader\n * @memberof PIXI.lights\n * @param shaderManager {ShaderManager} The WebGL shader manager this shader works for.\n */\nfunction WireframeShader(gl) {\n    PIXI.Shader.call(this,\n        gl,\n        // vertex shader\n        [\n            'attribute vec2 aVertexPosition;',\n            'uniform mat3 projectionMatrix;',\n\n            'void main(void) {',\n            '    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);',\n            '}'\n        ].join('\\n'),\n        // fragment shader\n        [\n            'void main() {',\n            '    gl_FragColor = vec4(0, 0, 0, 1);',\n            '}'\n        ].join('\\n'),\n        /*// uniforms\n        {\n            translationMatrix:  { type: 'mat3', value: new Float32Array(9) },\n            projectionMatrix:   { type: 'mat3', value: new Float32Array(9) }\n        },*/\n        // attributes\n        {\n            aVertexPosition: 0\n        }\n    );\n}\n\nWireframeShader.prototype = Object.create(PIXI.Shader.prototype);\nWireframeShader.prototype.constructor = WireframeShader;\nmodule.exports = WireframeShader;\n\nmain.registerPlugin('wireframeShader', WireframeShader);\n","var Light = require('../light/Light');\n\n/**\n * @class\n * @extends PIXI.lights.Light\n * @memberof PIXI.lights\n *\n * @param [color=0xFFFFFF] {number} The color of the light.\n * @param [brightness=0.5] {number} The brightness of the light.\n */\nfunction AmbientLight(color, brightness) {\n    // ambient light is drawn using a full-screen quad\n    Light.call(this, color, brightness);\n\n    this.shaderName = 'ambientLightShader';\n}\n\nAmbientLight.prototype = Object.create(Light.prototype);\nAmbientLight.prototype.constructor = AmbientLight;\nmodule.exports = AmbientLight;\n","var main = require('../../main');\r\nvar LightShader = require('../light/LightShader');\r\n\r\n\r\n/**\r\n * @class\r\n * @extends PIXI.Shader\r\n * @memberof PIXI.lights\r\n * @param shaderManager {ShaderManager} The WebGL shader manager this shader works for.\r\n */\r\nfunction AmbientLightShader(gl) {\r\n    LightShader.call(this,\r\n        gl,\r\n        // vertex shader\r\n        null,\r\n        // fragment shader\r\n        \"precision highp float;\\n#define GLSLIFY 1\\n\\nuniform sampler2D uSampler;\\nuniform sampler2D uNormalSampler;\\n\\nuniform mat3 translationMatrix;\\n\\nuniform vec2 uViewSize;     // size of the viewport\\n\\nuniform vec4 uLightColor;   // light color, alpha channel used for intensity.\\nuniform vec3 uLightFalloff; // light attenuation coefficients (constant, linear, quadratic)\\nuniform float uLightHeight; // light height above the viewport\\n\\n\\nvoid main(void)\\n{\\nvec2 texCoord = gl_FragCoord.xy / uViewSize;\\ntexCoord.y = 1.0 - texCoord.y; // FBOs positions are flipped.\\n\\nvec4 normalColor = texture2D(uNormalSampler, texCoord);\\nnormalColor.g = 1.0 - normalColor.g; // Green layer is flipped Y coords.\\n\\n// bail out early when normal has no data\\nif (normalColor.a == 0.0) discard;\\n\\n\\n    // simplified lambert shading that makes assumptions for ambient color\\n\\n    // compute Distance\\n    float D = 1.0;\\n\\n    // normalize vectors\\n    vec3 N = normalize(normalColor.xyz * 2.0 - 1.0);\\n    vec3 L = vec3(1.0, 1.0, 1.0);\\n\\n    // pre-multiply light color with intensity\\n    // then perform \\\"N dot L\\\" to determine our diffuse\\n    vec3 diffuse = (uLightColor.rgb * uLightColor.a) * max(dot(N, L), 0.0);\\n\\n    vec4 diffuseColor = texture2D(uSampler, texCoord);\\n    vec3 finalColor = diffuseColor.rgb * diffuse;\\n\\n    gl_FragColor = vec4(finalColor, diffuseColor.a);\\n}\\n\"\r\n    );\r\n}\r\n\r\nAmbientLightShader.prototype = Object.create(LightShader.prototype);\r\nAmbientLightShader.prototype.constructor = AmbientLightShader;\r\nmodule.exports = AmbientLightShader;\r\n\r\nmain.registerPlugin('ambientLightShader', AmbientLightShader);\r\n","var Light = require('../light/Light');\n\n/**\n * @class\n * @extends PIXI.lights.Light\n * @memberof PIXI.lights\n *\n * @param [color=0xFFFFFF] {number} The color of the light.\n * @param [brightness=1] {number} The intensity of the light.\n * @param [target] {PIXI.DisplayObject|PIXI.Point} The object in the scene to target.\n */\nfunction DirectionalLight(color, brightness, target) {\n    Light.call(this, color, brightness);\n\n    this.target = target;\n    this._directionVector = new PIXI.Point();\n\n    this._updateTransform = Light.prototype.updateTransform;\n    this._syncShader = Light.prototype.syncShader;\n\n    this.shaderName = 'directionalLightShader';\n}\n\nDirectionalLight.prototype = Object.create(Light.prototype);\nDirectionalLight.prototype.constructor = DirectionalLight;\nmodule.exports = DirectionalLight;\n\nDirectionalLight.prototype.updateTransform = function () {\n    this.containerUpdateTransform();\n\n    var vec = this._directionVector,\n        wt = this.worldTransform,\n        tx = this.target.worldTransform ? this.target.worldTransform.tx : this.target.x,\n        ty = this.target.worldTransform ? this.target.worldTransform.ty : this.target.y;\n\n    // calculate direction from this light to the target\n    vec.x = wt.tx - tx;\n    vec.y = wt.ty - ty;\n\n    // normalize\n    var len = Math.sqrt(vec.x * vec.x + vec.y * vec.y);\n    vec.x /= len;\n    vec.y /= len;\n};\n\nDirectionalLight.prototype.syncShader = function (shader) {\n    this._syncShader(shader);\n\n    var uLightDirection = shader.uniforms.uLightDirection;\n    uLightDirection[0] = this._directionVector.x;\n    uLightDirection[1] = this._directionVector.y;\n    shader.uniforms.uLightDirection = uLightDirection;\n};\n","var main = require('../../main');\nvar LightShader = require('../light/LightShader');\n\n\n/**\n * @class\n * @extends PIXI.Shader\n * @memberof PIXI.lights\n * @param shaderManager {ShaderManager} The WebGL shader manager this shader works for.\n */\nfunction DirectionalLightShader(gl) {\n    LightShader.call(this,\n        gl,\n        // vertex shader\n        null,\n        // fragment shader\n        \"precision highp float;\\n#define GLSLIFY 1\\n\\n// imports the common uniforms like samplers, and ambient/light color\\nuniform sampler2D uSampler;\\nuniform sampler2D uNormalSampler;\\n\\nuniform mat3 translationMatrix;\\n\\nuniform vec2 uViewSize;     // size of the viewport\\n\\nuniform vec4 uLightColor;   // light color, alpha channel used for intensity.\\nuniform vec3 uLightFalloff; // light attenuation coefficients (constant, linear, quadratic)\\nuniform float uLightHeight; // light height above the viewport\\n\\n\\nuniform vec2 uLightDirection;\\n\\nvoid main()\\n{\\nvec2 texCoord = gl_FragCoord.xy / uViewSize;\\ntexCoord.y = 1.0 - texCoord.y; // FBOs positions are flipped.\\n\\nvec4 normalColor = texture2D(uNormalSampler, texCoord);\\nnormalColor.g = 1.0 - normalColor.g; // Green layer is flipped Y coords.\\n\\n// bail out early when normal has no data\\nif (normalColor.a == 0.0) discard;\\n\\n\\n    // the directional vector of the light\\n    vec3 lightVector = vec3(uLightDirection, uLightHeight);\\n\\n    // compute Distance\\n    float D = length(lightVector);\\n\\n// normalize vectors\\nvec3 N = normalize(normalColor.xyz * 2.0 - 1.0);\\nvec3 L = normalize(lightVector);\\n\\n// pre-multiply light color with intensity\\n// then perform \\\"N dot L\\\" to determine our diffuse\\nvec3 diffuse = (uLightColor.rgb * uLightColor.a) * max(dot(N, L), 0.0);\\n\\n\\n    // calculate attenuation\\n    float attenuation = 1.0;\\n\\n// calculate final intesity and color, then combine\\nvec3 intensity = diffuse * attenuation;\\nvec4 diffuseColor = texture2D(uSampler, texCoord);\\nvec3 finalColor = diffuseColor.rgb * intensity;\\n\\ngl_FragColor = vec4(finalColor, diffuseColor.a);\\n\\n}\\n\",\n        // custom uniforms\n        {\n            // the directional vector of the light\n            uLightDirection: { type: '2f', value: new Float32Array(2) }\n        }\n    );\n}\n\nDirectionalLightShader.prototype = Object.create(LightShader.prototype);\nDirectionalLightShader.prototype.constructor = DirectionalLightShader;\nmodule.exports = DirectionalLightShader;\n\nmain.registerPlugin('directionalLightShader', DirectionalLightShader);\n","/**\n * Excuse the mess, haven't cleaned this up yet!\n */\n\nvar main = require('../../main');\n\n/**\n * @class\n * @extends PIXI.DisplayObject\n * @memberof PIXI.lights\n *\n * @param [color=0xFFFFFF] {number} The color of the light.\n * @param [brightness=1] {number} The brightness of the light, in range [0, 1].\n */\nfunction Light(color, brightness, vertices, indices) {\n    if (this.constructor === Light) {\n        throw new Error('Light is an abstract base class, it should not be created directly!');\n    }\n\n    PIXI.Container.call(this);\n\n    /**\n     * An array of vertices\n     *\n     * @member {Float32Array}\n     */\n    this.vertices = vertices || new Float32Array(8);\n\n    /**\n     * An array containing the indices of the vertices\n     *\n     * @member {Uint16Array}\n     */\n    this.indices = indices || new Uint16Array([0,1,2, 0,2,3]);\n\n    /**\n     * The blend mode to be applied to the light.\n     *\n     * @member {number}\n     * @default CONST.BLEND_MODES.ADD;\n     */\n    this.blendMode = PIXI.BLEND_MODES.ADD;\n\n    /**\n     * The draw mode to be applied to the light geometry.\n     *\n     * @member {number}\n     * @default CONST.DRAW_MODES.TRIANGLES;\n     */\n    this.drawMode = PIXI.DRAW_MODES.TRIANGLES;\n\n    /**\n     * When incremented the renderer will re-upload indices\n     *\n     * @member {number}\n     */\n    this.dirty = 0;\n\n    /**\n     * The height of the light from the viewport.\n     *\n     * @member {number}\n     * @default 0.075\n     */\n    this.lightHeight = 0.075;\n\n    /**\n     * The falloff attenuation coeficients.\n     *\n     * @member {number[]}\n     * @default [0.75, 3, 20]\n     */\n    this.falloff = [0.75, 3, 20];\n\n    /**\n     * The name of the shader plugin to use.\n     *\n     * @member {string}\n     */\n    this.shaderName = null;\n\n    /**\n     * By default the light uses a viewport sized quad as the mesh.\n     */\n    this.useViewportQuad = true;\n\n    // color and brightness are exposed through setters\n    this._color = 0x4d4d59;\n    this._colorRgba = [0.3, 0.3, 0.35, 0.8];\n\n    // run the color setter\n    if (color || color === 0) {\n        this.color = color;\n    }\n\n    // run the brightness setter\n    if (brightness || brightness === 0) {\n        this.brightness = brightness;\n    }\n\n    this.parentGroup = main.lightGroup;\n\n\n    /**\n     * WebGL data for this light\n     * @member {Object}\n     * @private\n     */\n    this._glDatas = {};\n\n    this.shaderName = 'lights';\n}\n\nLight.prototype = Object.create(PIXI.Container.prototype);\nLight.prototype.constructor = Light;\nmodule.exports = Light;\n\nObject.defineProperties(Light.prototype, {\n    /**\n     * The color of the lighting.\n     *\n     * @member {number}\n     * @memberof Light#\n     */\n    color: {\n        get: function ()\n        {\n            return this._color;\n        },\n        set: function (val)\n        {\n            this._color = val;\n            PIXI.utils.hex2rgb(val, this._colorRgba);\n        }\n    },\n\n    /**\n     * The brightness of this lighting. Normalized in the range [0, 1].\n     *\n     * @member {number}\n     * @memberof Light#\n     */\n    brightness: {\n        get: function ()\n        {\n            return this._colorRgba[3];\n        },\n        set: function (val)\n        {\n            this._colorRgba[3] = val;\n        }\n    }\n});\n\nLight.prototype.syncShader = function (shader) {\n    shader.uniforms.uUseViewportQuad = this.useViewportQuad;\n\n    var uLightColor = shader.uniforms.uLightColor;\n    if (uLightColor) {\n        uLightColor[0] = this._colorRgba[0];\n        uLightColor[1] = this._colorRgba[1];\n        uLightColor[2] = this._colorRgba[2];\n        uLightColor[3] = this._colorRgba[3];\n        shader.uniforms.uLightColor = uLightColor;\n    }\n\n    shader.uniforms.uLightHeight = this.lightHeight;\n\n    var uLightFalloff = shader.uniforms.uLightFalloff;\n    if (uLightFalloff) {\n        uLightFalloff[0] = this.falloff[0];\n        uLightFalloff[1] = this.falloff[1];\n        uLightFalloff[2] = this.falloff[2];\n        shader.uniforms.uLightFalloff = uLightFalloff;\n    }\n};\n\nLight.prototype._renderWebGL = function (renderer)\n{\n    renderer.setObjectRenderer(renderer.plugins.lights);\n    renderer.plugins.lights.render(this);\n};\n","\r\n\r\n/**\r\n * @class\r\n * @extends PIXI.Shader\r\n * @memberof PIXI.lights\r\n * @param shaderManager {ShaderManager} The WebGL shader manager this shader works for.\r\n */\r\nfunction LightShader(gl, vertexSrc, fragmentSrc, customUniforms, customAttributes) {\r\n    var uniforms = {\r\n        translationMatrix:  { type: 'mat3', value: new Float32Array(9) },\r\n        projectionMatrix:   { type: 'mat3', value: new Float32Array(9) },\r\n\r\n        // textures from the previously rendered FBOs\r\n        uSampler:       { type: 'sampler2D', value: null },\r\n        uNormalSampler: { type: 'sampler2D', value: null },\r\n\r\n        // should we apply the translation matrix or not.\r\n        uUseViewportQuad: { type: 'bool', value: true },\r\n\r\n        // size of the renderer viewport\r\n        uViewSize:      { type: '2f', value: new Float32Array(2) },\r\n\r\n        // light color, alpha channel used for intensity.\r\n        uLightColor:    { type: '4f', value: new Float32Array([1, 1, 1, 1]) },\r\n\r\n        // light falloff attenuation coefficients\r\n        uLightFalloff:  { type: '3f', value: new Float32Array([0, 0, 0]) },\r\n\r\n        // height of the light above the viewport\r\n        uLightHeight: { type: '1f', value: 0.075 }\r\n    };\r\n\r\n    if (customUniforms)\r\n    {\r\n        for (var u in customUniforms)\r\n        {\r\n            uniforms[u] = customUniforms[u];\r\n        }\r\n    }\r\n\r\n    var attributes = {\r\n        aVertexPosition: 0\r\n    };\r\n\r\n    if (customAttributes)\r\n    {\r\n        for (var a in customAttributes)\r\n        {\r\n            attributes[a] = customAttributes[a];\r\n        }\r\n    }\r\n\r\n    PIXI.Shader.call(this, gl, vertexSrc || LightShader.defaultVertexSrc, fragmentSrc, attributes);\r\n}\r\n\r\nLightShader.prototype = Object.create(PIXI.Shader.prototype);\r\nLightShader.prototype.constructor = LightShader;\r\nmodule.exports = LightShader;\r\n\r\nLightShader.defaultVertexSrc = \"#define GLSLIFY 1\\nattribute vec2 aVertexPosition;\\n\\nuniform bool uUseViewportQuad;\\nuniform mat3 translationMatrix;\\nuniform mat3 projectionMatrix;\\n\\nvoid main(void) {\\n    if (uUseViewportQuad) {\\n        gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\\n    }\\n    else\\n    {\\n        gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\\n    }\\n}\\n\";\r\n","var Light = require('../light/Light');\n\n/**\n * @class\n * @extends PIXI.lights.Light\n * @memberof PIXI.lights\n *\n * @param [color=0xFFFFFF] {number} The color of the light.\n * @param [brightness=1] {number} The intensity of the light.\n * @param [radius=Infinity] {number} The distance the light reaches. You will likely need\n *  to change the falloff of the light as well if you change this value. Infinity will\n *  use the entire viewport as the drawing surface.\n */\nfunction PointLight(color, brightness, radius) {\n    radius = radius || Infinity;\n\n    if (radius !== Infinity) {\n        var shape = new PIXI.Circle(0, 0, radius),\n            mesh = shape.getMesh();\n\n        Light.call(this, color, brightness, mesh.vertices, mesh.indices);\n\n        this.useViewportQuad = false;\n        this.drawMode = PIXI.DRAW_MODES.TRIANGLE_FAN;\n    }\n    else {\n        Light.call(this, color, brightness);\n    }\n\n    this._syncShader = Light.prototype.syncShader;\n\n    this.radius = radius;\n    this.shaderName = 'pointLightShader';\n}\n\nPointLight.prototype = Object.create(Light.prototype);\nPointLight.prototype.constructor = PointLight;\nmodule.exports = PointLight;\n\nPointLight.prototype.syncShader = function (shader) {\n    this._syncShader(shader);\n\n    shader.uniforms.uLightRadius = this.radius;\n}\n","var main = require('../../main');\r\nvar LightShader = require('../light/LightShader');\r\n\r\n\r\n/**\r\n * @class\r\n * @extends PIXI.Shader\r\n * @memberof PIXI.lights\r\n * @param shaderManager {ShaderManager} The WebGL shader manager this shader works for.\r\n */\r\nfunction PointLightShader(gl) {\r\n    LightShader.call(this,\r\n        gl,\r\n        // vertex shader\r\n        null,\r\n        // fragment shader\r\n        \"precision highp float;\\n#define GLSLIFY 1\\n\\n// imports the common uniforms like samplers, and ambient color\\nuniform sampler2D uSampler;\\nuniform sampler2D uNormalSampler;\\n\\nuniform mat3 translationMatrix;\\n\\nuniform vec2 uViewSize;     // size of the viewport\\n\\nuniform vec4 uLightColor;   // light color, alpha channel used for intensity.\\nuniform vec3 uLightFalloff; // light attenuation coefficients (constant, linear, quadratic)\\nuniform float uLightHeight; // light height above the viewport\\n\\n\\nuniform float uLightRadius;\\n\\nvoid main()\\n{\\nvec2 texCoord = gl_FragCoord.xy / uViewSize;\\ntexCoord.y = 1.0 - texCoord.y; // FBOs positions are flipped.\\n\\nvec4 normalColor = texture2D(uNormalSampler, texCoord);\\nnormalColor.g = 1.0 - normalColor.g; // Green layer is flipped Y coords.\\n\\n// bail out early when normal has no data\\nif (normalColor.a == 0.0) discard;\\n\\n\\n    vec2 lightPosition = translationMatrix[2].xy / uViewSize;\\n\\n    // the directional vector of the light\\n    vec3 lightVector = vec3(lightPosition - texCoord, uLightHeight);\\n\\n    // correct for aspect ratio\\n    lightVector.x *= uViewSize.x / uViewSize.y;\\n\\n    // compute Distance\\n    float D = length(lightVector);\\n\\n    // bail out early when pixel outside of light sphere\\n    if (D > uLightRadius) discard;\\n\\n// normalize vectors\\nvec3 N = normalize(normalColor.xyz * 2.0 - 1.0);\\nvec3 L = normalize(lightVector);\\n\\n// pre-multiply light color with intensity\\n// then perform \\\"N dot L\\\" to determine our diffuse\\nvec3 diffuse = (uLightColor.rgb * uLightColor.a) * max(dot(N, L), 0.0);\\n\\n\\n    // calculate attenuation\\n    float attenuation = 1.0 / (uLightFalloff.x + (uLightFalloff.y * D) + (uLightFalloff.z * D * D));\\n\\n// calculate final intesity and color, then combine\\nvec3 intensity = diffuse * attenuation;\\nvec4 diffuseColor = texture2D(uSampler, texCoord);\\nvec3 finalColor = diffuseColor.rgb * intensity;\\n\\ngl_FragColor = vec4(finalColor, diffuseColor.a);\\n\\n}\\n\",\r\n        // custom uniforms\r\n        {\r\n            // height of the light above the viewport\r\n            uLightRadius:   { type: '1f', value: 1 }\r\n        }\r\n    );\r\n}\r\n\r\nPointLightShader.prototype = Object.create(LightShader.prototype);\r\nPointLightShader.prototype.constructor = PointLightShader;\r\nmodule.exports = PointLightShader;\r\n\r\nmain.registerPlugin('pointLightShader', PointLightShader);\r\n","module.exports = {\n    plugins: {},\n    registerPlugin: function(name, fun) {\n        this.plugins[name] = fun;\n    },\n    diffuseGroup: new PIXI.display.Group(),\n    normalGroup: new PIXI.display.Group(),\n    lightGroup: new PIXI.display.Group()\n};\n\nmodule.exports.diffuseGroup.useRenderTexture = true;\nmodule.exports.normalGroup.useRenderTexture = true;\n","var main = require('../main');\nvar glCore = PIXI.glCore;\n\n/**\n *\n * @class\n * @private\n * @memberof PIXI.lights\n * @extends PIXI.ObjectRenderer\n * @param renderer {WebGLRenderer} The renderer this sprite batch works for.\n */\nfunction LightRenderer(renderer) {\n    PIXI.ObjectRenderer.call(this, renderer);\n\n    // the total number of indices in our batch, there are 6 points per quad.\n    var numIndices = LightRenderer.MAX_LIGHTS * 6;\n\n    /**\n     * Holds the indices\n     *\n     * @member {Uint16Array}\n     */\n    this.indices = new Uint16Array(numIndices);\n\n    //TODO this could be a single buffer shared amongst all renderers as we reuse this set up in most renderers\n    for (var i = 0, j = 0; i < numIndices; i += 6, j += 4) {\n        this.indices[i + 0] = j + 0;\n        this.indices[i + 1] = j + 1;\n        this.indices[i + 2] = j + 2;\n        this.indices[i + 3] = j + 0;\n        this.indices[i + 4] = j + 2;\n        this.indices[i + 5] = j + 3;\n    }\n\n    this.shaders = {};\n\n    /**\n     * The current lights in the batch.\n     *\n     * @member {Light[]}\n     */\n    this.lights = [];\n}\n\nLightRenderer.MAX_LIGHTS = 500;\n\nLightRenderer.prototype = Object.create(PIXI.ObjectRenderer.prototype);\nLightRenderer.prototype.constructor = LightRenderer;\nmodule.exports = LightRenderer;\n\nPIXI.WebGLRenderer.registerPlugin('lights', LightRenderer);\n\nLightRenderer.prototype.onContextChange = function () {\n    this.gl = this.renderer.gl;\n    for (var key in main.plugins) {\n        this.shaders[key] = new (main.plugins[key])(this.gl);\n    }\n};\n\n/**\n * Renders the light object.\n *\n * @param light {Light} the light to render\n */\nLightRenderer.prototype.render = function (mesh) {\n    var renderer = this.renderer;\n    var gl = renderer.gl;\n\n    this.lights.push(mesh);\n    /**\n     * Prepares all the buffers to render this light.\n     */\n    var glData = mesh._glDatas[renderer.CONTEXT_UID];\n\n    if (!glData) {\n        renderer.bindVao(null);\n\n        glData = {\n            shader: this.shaders[mesh.shaderName],\n            vertexBuffer: glCore.GLBuffer.createVertexBuffer(gl, mesh.vertices, gl.STREAM_DRAW),\n            indexBuffer: glCore.GLBuffer.createIndexBuffer(gl, mesh.indices, gl.STATIC_DRAW),\n            // build the vao object that will render..\n            vao: null,\n            dirty: mesh.dirty\n        };\n\n        // build the vao object that will render..\n        glData.vao = new glCore.VertexArrayObject(gl)\n            .addIndex(glData.indexBuffer)\n            .addAttribute(glData.vertexBuffer, glData.shader.attributes.aVertexPosition, gl.FLOAT, false, 2 * 4, 0)\n\n        mesh._glDatas[renderer.CONTEXT_UID] = glData;\n    }\n\n    renderer.bindVao(glData.vao);\n\n    if (mesh.useViewportQuad) {\n        mesh.vertices[2] = mesh.vertices[4] = renderer.screen.width;\n        mesh.vertices[5] = mesh.vertices[7] = renderer.screen.height;\n    }\n    glData.vertexBuffer.upload(mesh.vertices);\n\n    if (glData.dirty !== mesh.dirty) {\n        glData.dirty = mesh.dirty;\n        glData.indexBuffer.upload(mesh.indices);\n    }\n};\n\nLightRenderer.prototype.flush = function () {\n    var diffuseTexture = null,\n        normalTexture = null,\n        lastLayer = null,\n        lastShader = null,\n        renderer = this.renderer;\n\n    for (var i = 0; i < this.lights.length; ++i) {\n        var light = this.lights[i],\n            layer = this.lights[i]._activeParentLayer;\n\n        if (!layer) {\n            continue;\n        }\n\n        if (lastLayer !== layer) {\n            lastLayer = layer;\n            var stage = layer._activeStageParent;\n\n            if (layer.diffuseTexture &&\n                layer.normalTexture) {\n                diffuseTexture = layer.diffuseTexture;\n                normalTexture = layer.normalTexture;\n            } else {\n                for (var j = 0; j < stage._activeLayers.length; j++) {\n                    var texLayer = stage._activeLayers[j];\n                    if (texLayer.group === main.normalGroup) {\n                        normalTexture = texLayer.getRenderTexture();\n                    }\n                    if (texLayer.group === main.diffuseGroup) {\n                        diffuseTexture = texLayer.getRenderTexture();\n                    }\n                }\n            }\n\n            renderer.bindTexture(diffuseTexture, 0, true);\n            renderer.bindTexture(normalTexture, 1, true);\n        }\n\n        var glData = light._glDatas[renderer.CONTEXT_UID],\n            shader = glData.shader;\n\n        if (lastShader !== shader) {\n            lastShader = shader;\n            renderer.bindShader(shader);\n\n            shader.uniforms.uSampler = 0;\n            shader.uniforms.uNormalSampler = 1;\n\n            var uViewSize = shader.uniforms.uViewSize;\n            uViewSize[0] = renderer.screen.width;\n            uViewSize[1] = renderer.screen.height;\n            shader.uniforms.uViewSize = uViewSize;\n        }\n\n        renderer.bindVao(glData.vao);\n\n        light.syncShader(shader);\n        renderer.state.setBlendMode(light.blendMode);\n        shader.uniforms.translationMatrix = light.worldTransform.toArray(true);\n\n        glData.vao.draw(light.drawMode, light.indices.length, 0);\n    }\n\n    this.lights.length = 0;\n};\n\nLightRenderer.prototype.stop = function() {\n    this.flush();\n};\n","/**\r\n * Creates vertices and indices arrays to describe this circle.\r\n * \r\n * @param [totalSegments=40] {number} Total segments to build for the circle mesh.\r\n * @param [verticesOutput] {Float32Array} An array to output the vertices into. Length must be\r\n *  `((totalSegments + 2) * 2)` or more. If not passed it is created for you.\r\n * @param [indicesOutput] {Uint16Array} An array to output the indices into, in gl.TRIANGLE_FAN format. Length must\r\n *  be `(totalSegments + 3)` or more. If not passed it is created for you.\r\n */\r\nPIXI.Circle.prototype.getMesh = function (totalSegments, vertices, indices)\r\n{\r\n    totalSegments = totalSegments || 40;\r\n\r\n    vertices = vertices || new Float32Array((totalSegments + 1) * 2);\r\n    indices = indices || new Uint16Array(totalSegments + 1);\r\n\r\n    var seg = (Math.PI * 2) / totalSegments,\r\n        indicesIndex = -1;\r\n\r\n    indices[++indicesIndex] = indicesIndex;\r\n\r\n    for (var i = 0; i <= totalSegments; ++i)\r\n    {\r\n        var index = i*2;\r\n        var angle = seg * i;\r\n\r\n        vertices[index] = Math.cos(angle) * this.radius;\r\n        vertices[index+1] = Math.sin(angle) * this.radius;\r\n\r\n        indices[++indicesIndex] = indicesIndex;\r\n    }\r\n\r\n    indices[indicesIndex] = 1;\r\n\r\n    return {\r\n        vertices: vertices,\r\n        indices: indices\r\n    };\r\n};\r\n"],"preExistingComment":"//# sourceMappingURL=data:application/json;charset:utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJzcmMvaW5kZXgiLCJzcmMvbGlnaHRzL1dpcmVmcmFtZVNoYWRlci5qcyIsInNyYy9saWdodHMvYW1iaWVudExpZ2h0L0FtYmllbnRMaWdodC5qcyIsInNyYy9saWdodHMvYW1iaWVudExpZ2h0L0FtYmllbnRMaWdodFNoYWRlci5qcyIsInNyYy9saWdodHMvZGlyZWN0aW9uYWxMaWdodC9EaXJlY3Rpb25hbExpZ2h0LmpzIiwic3JjL2xpZ2h0cy9kaXJlY3Rpb25hbExpZ2h0L0RpcmVjdGlvbmFsTGlnaHRTaGFkZXIuanMiLCJzcmMvbGlnaHRzL2xpZ2h0L0xpZ2h0LmpzIiwic3JjL2xpZ2h0cy9saWdodC9MaWdodFNoYWRlci5qcyIsInNyYy9saWdodHMvcG9pbnRMaWdodC9Qb2ludExpZ2h0LmpzIiwic3JjL2xpZ2h0cy9wb2ludExpZ2h0L1BvaW50TGlnaHRTaGFkZXIuanMiLCJzcmMvbWFpbi5qcyIsInNyYy9yZW5kZXJlcnMvTGlnaHRSZW5kZXJlci5qcyIsInNyYy9zaGFwZU1lc2hNaXhpbi5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0TEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiBlKHQsbixyKXtmdW5jdGlvbiBzKG8sdSl7aWYoIW5bb10pe2lmKCF0W29dKXt2YXIgYT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2lmKCF1JiZhKXJldHVybiBhKG8sITApO2lmKGkpcmV0dXJuIGkobywhMCk7dmFyIGY9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitvK1wiJ1wiKTt0aHJvdyBmLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsZn12YXIgbD1uW29dPXtleHBvcnRzOnt9fTt0W29dWzBdLmNhbGwobC5leHBvcnRzLGZ1bmN0aW9uKGUpe3ZhciBuPXRbb11bMV1bZV07cmV0dXJuIHMobj9uOmUpfSxsLGwuZXhwb3J0cyxlLHQsbixyKX1yZXR1cm4gbltvXS5leHBvcnRzfXZhciBpPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7Zm9yKHZhciBvPTA7bzxyLmxlbmd0aDtvKyspcyhyW29dKTtyZXR1cm4gc30pIiwiUElYSS5saWdodHMgPSB7XG4gICAgTGlnaHQ6ICAgICAgICAgICAgICAgICAgcmVxdWlyZSgnLi9saWdodHMvbGlnaHQvTGlnaHQnKSxcbiAgICBMaWdodFNoYWRlcjogICAgICAgICAgICByZXF1aXJlKCcuL2xpZ2h0cy9saWdodC9MaWdodFNoYWRlcicpLFxuXG4gICAgQW1iaWVudExpZ2h0OiAgICAgICAgICAgcmVxdWlyZSgnLi9saWdodHMvYW1iaWVudExpZ2h0L0FtYmllbnRMaWdodCcpLFxuICAgIEFtYmllbnRMaWdodFNoYWRlcjogICAgIHJlcXVpcmUoJy4vbGlnaHRzL2FtYmllbnRMaWdodC9BbWJpZW50TGlnaHRTaGFkZXInKSxcblxuICAgIFBvaW50TGlnaHQ6ICAgICAgICAgICAgIHJlcXVpcmUoJy4vbGlnaHRzL3BvaW50TGlnaHQvUG9pbnRMaWdodCcpLFxuICAgIFBvaW50TGlnaHRTaGFkZXI6ICAgICAgIHJlcXVpcmUoJy4vbGlnaHRzL3BvaW50TGlnaHQvUG9pbnRMaWdodFNoYWRlcicpLFxuXG4gICAgRGlyZWN0aW9uYWxMaWdodDogICAgICAgICAgICAgcmVxdWlyZSgnLi9saWdodHMvZGlyZWN0aW9uYWxMaWdodC9EaXJlY3Rpb25hbExpZ2h0JyksXG4gICAgRGlyZWN0aW9uYWxMaWdodFNoYWRlcjogICAgICAgcmVxdWlyZSgnLi9saWdodHMvZGlyZWN0aW9uYWxMaWdodC9EaXJlY3Rpb25hbExpZ2h0U2hhZGVyJyksXG5cbiAgICBMaWdodFJlbmRlcmVyOiAgICAgICAgICByZXF1aXJlKCcuL3JlbmRlcmVycy9MaWdodFJlbmRlcmVyJyksXG5cbiAgICBXaXJlZnJhbWVTaGFkZXI6ICAgICAgICByZXF1aXJlKCcuL2xpZ2h0cy9XaXJlZnJhbWVTaGFkZXInKVxufTtcblxuT2JqZWN0LmFzc2lnbihQSVhJLmxpZ2h0cywgcmVxdWlyZSgnLi9tYWluJykpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFBJWEkubGlnaHRzO1xuXG5yZXF1aXJlKCcuL3NoYXBlTWVzaE1peGluJyk7XG4iLCJ2YXIgbWFpbiA9IHJlcXVpcmUoJy4uL21haW4nKTtcblxuXG4vKipcbiAqIEBjbGFzc1xuICogQGV4dGVuZHMgUElYSS5TaGFkZXJcbiAqIEBtZW1iZXJvZiBQSVhJLmxpZ2h0c1xuICogQHBhcmFtIHNoYWRlck1hbmFnZXIge1NoYWRlck1hbmFnZXJ9IFRoZSBXZWJHTCBzaGFkZXIgbWFuYWdlciB0aGlzIHNoYWRlciB3b3JrcyBmb3IuXG4gKi9cbmZ1bmN0aW9uIFdpcmVmcmFtZVNoYWRlcihnbCkge1xuICAgIFBJWEkuU2hhZGVyLmNhbGwodGhpcyxcbiAgICAgICAgZ2wsXG4gICAgICAgIC8vIHZlcnRleCBzaGFkZXJcbiAgICAgICAgW1xuICAgICAgICAgICAgJ2F0dHJpYnV0ZSB2ZWMyIGFWZXJ0ZXhQb3NpdGlvbjsnLFxuICAgICAgICAgICAgJ3VuaWZvcm0gbWF0MyBwcm9qZWN0aW9uTWF0cml4OycsXG5cbiAgICAgICAgICAgICd2b2lkIG1haW4odm9pZCkgeycsXG4gICAgICAgICAgICAnICAgIGdsX1Bvc2l0aW9uID0gdmVjNCgocHJvamVjdGlvbk1hdHJpeCAqIHZlYzMoYVZlcnRleFBvc2l0aW9uLCAxLjApKS54eSwgMC4wLCAxLjApOycsXG4gICAgICAgICAgICAnfSdcbiAgICAgICAgXS5qb2luKCdcXG4nKSxcbiAgICAgICAgLy8gZnJhZ21lbnQgc2hhZGVyXG4gICAgICAgIFtcbiAgICAgICAgICAgICd2b2lkIG1haW4oKSB7JyxcbiAgICAgICAgICAgICcgICAgZ2xfRnJhZ0NvbG9yID0gdmVjNCgwLCAwLCAwLCAxKTsnLFxuICAgICAgICAgICAgJ30nXG4gICAgICAgIF0uam9pbignXFxuJyksXG4gICAgICAgIC8qLy8gdW5pZm9ybXNcbiAgICAgICAge1xuICAgICAgICAgICAgdHJhbnNsYXRpb25NYXRyaXg6ICB7IHR5cGU6ICdtYXQzJywgdmFsdWU6IG5ldyBGbG9hdDMyQXJyYXkoOSkgfSxcbiAgICAgICAgICAgIHByb2plY3Rpb25NYXRyaXg6ICAgeyB0eXBlOiAnbWF0MycsIHZhbHVlOiBuZXcgRmxvYXQzMkFycmF5KDkpIH1cbiAgICAgICAgfSwqL1xuICAgICAgICAvLyBhdHRyaWJ1dGVzXG4gICAgICAgIHtcbiAgICAgICAgICAgIGFWZXJ0ZXhQb3NpdGlvbjogMFxuICAgICAgICB9XG4gICAgKTtcbn1cblxuV2lyZWZyYW1lU2hhZGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoUElYSS5TaGFkZXIucHJvdG90eXBlKTtcbldpcmVmcmFtZVNoYWRlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBXaXJlZnJhbWVTaGFkZXI7XG5tb2R1bGUuZXhwb3J0cyA9IFdpcmVmcmFtZVNoYWRlcjtcblxubWFpbi5yZWdpc3RlclBsdWdpbignd2lyZWZyYW1lU2hhZGVyJywgV2lyZWZyYW1lU2hhZGVyKTtcbiIsInZhciBMaWdodCA9IHJlcXVpcmUoJy4uL2xpZ2h0L0xpZ2h0Jyk7XG5cbi8qKlxuICogQGNsYXNzXG4gKiBAZXh0ZW5kcyBQSVhJLmxpZ2h0cy5MaWdodFxuICogQG1lbWJlcm9mIFBJWEkubGlnaHRzXG4gKlxuICogQHBhcmFtIFtjb2xvcj0weEZGRkZGRl0ge251bWJlcn0gVGhlIGNvbG9yIG9mIHRoZSBsaWdodC5cbiAqIEBwYXJhbSBbYnJpZ2h0bmVzcz0wLjVdIHtudW1iZXJ9IFRoZSBicmlnaHRuZXNzIG9mIHRoZSBsaWdodC5cbiAqL1xuZnVuY3Rpb24gQW1iaWVudExpZ2h0KGNvbG9yLCBicmlnaHRuZXNzKSB7XG4gICAgLy8gYW1iaWVudCBsaWdodCBpcyBkcmF3biB1c2luZyBhIGZ1bGwtc2NyZWVuIHF1YWRcbiAgICBMaWdodC5jYWxsKHRoaXMsIGNvbG9yLCBicmlnaHRuZXNzKTtcblxuICAgIHRoaXMuc2hhZGVyTmFtZSA9ICdhbWJpZW50TGlnaHRTaGFkZXInO1xufVxuXG5BbWJpZW50TGlnaHQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShMaWdodC5wcm90b3R5cGUpO1xuQW1iaWVudExpZ2h0LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEFtYmllbnRMaWdodDtcbm1vZHVsZS5leHBvcnRzID0gQW1iaWVudExpZ2h0O1xuIiwidmFyIG1haW4gPSByZXF1aXJlKCcuLi8uLi9tYWluJyk7XHJcbnZhciBMaWdodFNoYWRlciA9IHJlcXVpcmUoJy4uL2xpZ2h0L0xpZ2h0U2hhZGVyJyk7XHJcblxyXG5cclxuLyoqXHJcbiAqIEBjbGFzc1xyXG4gKiBAZXh0ZW5kcyBQSVhJLlNoYWRlclxyXG4gKiBAbWVtYmVyb2YgUElYSS5saWdodHNcclxuICogQHBhcmFtIHNoYWRlck1hbmFnZXIge1NoYWRlck1hbmFnZXJ9IFRoZSBXZWJHTCBzaGFkZXIgbWFuYWdlciB0aGlzIHNoYWRlciB3b3JrcyBmb3IuXHJcbiAqL1xyXG5mdW5jdGlvbiBBbWJpZW50TGlnaHRTaGFkZXIoZ2wpIHtcclxuICAgIExpZ2h0U2hhZGVyLmNhbGwodGhpcyxcclxuICAgICAgICBnbCxcclxuICAgICAgICAvLyB2ZXJ0ZXggc2hhZGVyXHJcbiAgICAgICAgbnVsbCxcclxuICAgICAgICAvLyBmcmFnbWVudCBzaGFkZXJcclxuICAgICAgICBcInByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG4jZGVmaW5lIEdMU0xJRlkgMVxcblxcbnVuaWZvcm0gc2FtcGxlcjJEIHVTYW1wbGVyO1xcbnVuaWZvcm0gc2FtcGxlcjJEIHVOb3JtYWxTYW1wbGVyO1xcblxcbnVuaWZvcm0gbWF0MyB0cmFuc2xhdGlvbk1hdHJpeDtcXG5cXG51bmlmb3JtIHZlYzIgdVZpZXdTaXplOyAgICAgLy8gc2l6ZSBvZiB0aGUgdmlld3BvcnRcXG5cXG51bmlmb3JtIHZlYzQgdUxpZ2h0Q29sb3I7ICAgLy8gbGlnaHQgY29sb3IsIGFscGhhIGNoYW5uZWwgdXNlZCBmb3IgaW50ZW5zaXR5LlxcbnVuaWZvcm0gdmVjMyB1TGlnaHRGYWxsb2ZmOyAvLyBsaWdodCBhdHRlbnVhdGlvbiBjb2VmZmljaWVudHMgKGNvbnN0YW50LCBsaW5lYXIsIHF1YWRyYXRpYylcXG51bmlmb3JtIGZsb2F0IHVMaWdodEhlaWdodDsgLy8gbGlnaHQgaGVpZ2h0IGFib3ZlIHRoZSB2aWV3cG9ydFxcblxcblxcbnZvaWQgbWFpbih2b2lkKVxcbntcXG52ZWMyIHRleENvb3JkID0gZ2xfRnJhZ0Nvb3JkLnh5IC8gdVZpZXdTaXplO1xcbnRleENvb3JkLnkgPSAxLjAgLSB0ZXhDb29yZC55OyAvLyBGQk9zIHBvc2l0aW9ucyBhcmUgZmxpcHBlZC5cXG5cXG52ZWM0IG5vcm1hbENvbG9yID0gdGV4dHVyZTJEKHVOb3JtYWxTYW1wbGVyLCB0ZXhDb29yZCk7XFxubm9ybWFsQ29sb3IuZyA9IDEuMCAtIG5vcm1hbENvbG9yLmc7IC8vIEdyZWVuIGxheWVyIGlzIGZsaXBwZWQgWSBjb29yZHMuXFxuXFxuLy8gYmFpbCBvdXQgZWFybHkgd2hlbiBub3JtYWwgaGFzIG5vIGRhdGFcXG5pZiAobm9ybWFsQ29sb3IuYSA9PSAwLjApIGRpc2NhcmQ7XFxuXFxuXFxuICAgIC8vIHNpbXBsaWZpZWQgbGFtYmVydCBzaGFkaW5nIHRoYXQgbWFrZXMgYXNzdW1wdGlvbnMgZm9yIGFtYmllbnQgY29sb3JcXG5cXG4gICAgLy8gY29tcHV0ZSBEaXN0YW5jZVxcbiAgICBmbG9hdCBEID0gMS4wO1xcblxcbiAgICAvLyBub3JtYWxpemUgdmVjdG9yc1xcbiAgICB2ZWMzIE4gPSBub3JtYWxpemUobm9ybWFsQ29sb3IueHl6ICogMi4wIC0gMS4wKTtcXG4gICAgdmVjMyBMID0gdmVjMygxLjAsIDEuMCwgMS4wKTtcXG5cXG4gICAgLy8gcHJlLW11bHRpcGx5IGxpZ2h0IGNvbG9yIHdpdGggaW50ZW5zaXR5XFxuICAgIC8vIHRoZW4gcGVyZm9ybSBcXFwiTiBkb3QgTFxcXCIgdG8gZGV0ZXJtaW5lIG91ciBkaWZmdXNlXFxuICAgIHZlYzMgZGlmZnVzZSA9ICh1TGlnaHRDb2xvci5yZ2IgKiB1TGlnaHRDb2xvci5hKSAqIG1heChkb3QoTiwgTCksIDAuMCk7XFxuXFxuICAgIHZlYzQgZGlmZnVzZUNvbG9yID0gdGV4dHVyZTJEKHVTYW1wbGVyLCB0ZXhDb29yZCk7XFxuICAgIHZlYzMgZmluYWxDb2xvciA9IGRpZmZ1c2VDb2xvci5yZ2IgKiBkaWZmdXNlO1xcblxcbiAgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KGZpbmFsQ29sb3IsIGRpZmZ1c2VDb2xvci5hKTtcXG59XFxuXCJcclxuICAgICk7XHJcbn1cclxuXHJcbkFtYmllbnRMaWdodFNoYWRlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKExpZ2h0U2hhZGVyLnByb3RvdHlwZSk7XHJcbkFtYmllbnRMaWdodFNoYWRlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBBbWJpZW50TGlnaHRTaGFkZXI7XHJcbm1vZHVsZS5leHBvcnRzID0gQW1iaWVudExpZ2h0U2hhZGVyO1xyXG5cclxubWFpbi5yZWdpc3RlclBsdWdpbignYW1iaWVudExpZ2h0U2hhZGVyJywgQW1iaWVudExpZ2h0U2hhZGVyKTtcclxuIiwidmFyIExpZ2h0ID0gcmVxdWlyZSgnLi4vbGlnaHQvTGlnaHQnKTtcblxuLyoqXG4gKiBAY2xhc3NcbiAqIEBleHRlbmRzIFBJWEkubGlnaHRzLkxpZ2h0XG4gKiBAbWVtYmVyb2YgUElYSS5saWdodHNcbiAqXG4gKiBAcGFyYW0gW2NvbG9yPTB4RkZGRkZGXSB7bnVtYmVyfSBUaGUgY29sb3Igb2YgdGhlIGxpZ2h0LlxuICogQHBhcmFtIFticmlnaHRuZXNzPTFdIHtudW1iZXJ9IFRoZSBpbnRlbnNpdHkgb2YgdGhlIGxpZ2h0LlxuICogQHBhcmFtIFt0YXJnZXRdIHtQSVhJLkRpc3BsYXlPYmplY3R8UElYSS5Qb2ludH0gVGhlIG9iamVjdCBpbiB0aGUgc2NlbmUgdG8gdGFyZ2V0LlxuICovXG5mdW5jdGlvbiBEaXJlY3Rpb25hbExpZ2h0KGNvbG9yLCBicmlnaHRuZXNzLCB0YXJnZXQpIHtcbiAgICBMaWdodC5jYWxsKHRoaXMsIGNvbG9yLCBicmlnaHRuZXNzKTtcblxuICAgIHRoaXMudGFyZ2V0ID0gdGFyZ2V0O1xuICAgIHRoaXMuX2RpcmVjdGlvblZlY3RvciA9IG5ldyBQSVhJLlBvaW50KCk7XG5cbiAgICB0aGlzLl91cGRhdGVUcmFuc2Zvcm0gPSBMaWdodC5wcm90b3R5cGUudXBkYXRlVHJhbnNmb3JtO1xuICAgIHRoaXMuX3N5bmNTaGFkZXIgPSBMaWdodC5wcm90b3R5cGUuc3luY1NoYWRlcjtcblxuICAgIHRoaXMuc2hhZGVyTmFtZSA9ICdkaXJlY3Rpb25hbExpZ2h0U2hhZGVyJztcbn1cblxuRGlyZWN0aW9uYWxMaWdodC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKExpZ2h0LnByb3RvdHlwZSk7XG5EaXJlY3Rpb25hbExpZ2h0LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IERpcmVjdGlvbmFsTGlnaHQ7XG5tb2R1bGUuZXhwb3J0cyA9IERpcmVjdGlvbmFsTGlnaHQ7XG5cbkRpcmVjdGlvbmFsTGlnaHQucHJvdG90eXBlLnVwZGF0ZVRyYW5zZm9ybSA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmNvbnRhaW5lclVwZGF0ZVRyYW5zZm9ybSgpO1xuXG4gICAgdmFyIHZlYyA9IHRoaXMuX2RpcmVjdGlvblZlY3RvcixcbiAgICAgICAgd3QgPSB0aGlzLndvcmxkVHJhbnNmb3JtLFxuICAgICAgICB0eCA9IHRoaXMudGFyZ2V0LndvcmxkVHJhbnNmb3JtID8gdGhpcy50YXJnZXQud29ybGRUcmFuc2Zvcm0udHggOiB0aGlzLnRhcmdldC54LFxuICAgICAgICB0eSA9IHRoaXMudGFyZ2V0LndvcmxkVHJhbnNmb3JtID8gdGhpcy50YXJnZXQud29ybGRUcmFuc2Zvcm0udHkgOiB0aGlzLnRhcmdldC55O1xuXG4gICAgLy8gY2FsY3VsYXRlIGRpcmVjdGlvbiBmcm9tIHRoaXMgbGlnaHQgdG8gdGhlIHRhcmdldFxuICAgIHZlYy54ID0gd3QudHggLSB0eDtcbiAgICB2ZWMueSA9IHd0LnR5IC0gdHk7XG5cbiAgICAvLyBub3JtYWxpemVcbiAgICB2YXIgbGVuID0gTWF0aC5zcXJ0KHZlYy54ICogdmVjLnggKyB2ZWMueSAqIHZlYy55KTtcbiAgICB2ZWMueCAvPSBsZW47XG4gICAgdmVjLnkgLz0gbGVuO1xufTtcblxuRGlyZWN0aW9uYWxMaWdodC5wcm90b3R5cGUuc3luY1NoYWRlciA9IGZ1bmN0aW9uIChzaGFkZXIpIHtcbiAgICB0aGlzLl9zeW5jU2hhZGVyKHNoYWRlcik7XG5cbiAgICB2YXIgdUxpZ2h0RGlyZWN0aW9uID0gc2hhZGVyLnVuaWZvcm1zLnVMaWdodERpcmVjdGlvbjtcbiAgICB1TGlnaHREaXJlY3Rpb25bMF0gPSB0aGlzLl9kaXJlY3Rpb25WZWN0b3IueDtcbiAgICB1TGlnaHREaXJlY3Rpb25bMV0gPSB0aGlzLl9kaXJlY3Rpb25WZWN0b3IueTtcbiAgICBzaGFkZXIudW5pZm9ybXMudUxpZ2h0RGlyZWN0aW9uID0gdUxpZ2h0RGlyZWN0aW9uO1xufTtcbiIsInZhciBtYWluID0gcmVxdWlyZSgnLi4vLi4vbWFpbicpO1xudmFyIExpZ2h0U2hhZGVyID0gcmVxdWlyZSgnLi4vbGlnaHQvTGlnaHRTaGFkZXInKTtcblxuXG4vKipcbiAqIEBjbGFzc1xuICogQGV4dGVuZHMgUElYSS5TaGFkZXJcbiAqIEBtZW1iZXJvZiBQSVhJLmxpZ2h0c1xuICogQHBhcmFtIHNoYWRlck1hbmFnZXIge1NoYWRlck1hbmFnZXJ9IFRoZSBXZWJHTCBzaGFkZXIgbWFuYWdlciB0aGlzIHNoYWRlciB3b3JrcyBmb3IuXG4gKi9cbmZ1bmN0aW9uIERpcmVjdGlvbmFsTGlnaHRTaGFkZXIoZ2wpIHtcbiAgICBMaWdodFNoYWRlci5jYWxsKHRoaXMsXG4gICAgICAgIGdsLFxuICAgICAgICAvLyB2ZXJ0ZXggc2hhZGVyXG4gICAgICAgIG51bGwsXG4gICAgICAgIC8vIGZyYWdtZW50IHNoYWRlclxuICAgICAgICBcInByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG4jZGVmaW5lIEdMU0xJRlkgMVxcblxcbi8vIGltcG9ydHMgdGhlIGNvbW1vbiB1bmlmb3JtcyBsaWtlIHNhbXBsZXJzLCBhbmQgYW1iaWVudC9saWdodCBjb2xvclxcbnVuaWZvcm0gc2FtcGxlcjJEIHVTYW1wbGVyO1xcbnVuaWZvcm0gc2FtcGxlcjJEIHVOb3JtYWxTYW1wbGVyO1xcblxcbnVuaWZvcm0gbWF0MyB0cmFuc2xhdGlvbk1hdHJpeDtcXG5cXG51bmlmb3JtIHZlYzIgdVZpZXdTaXplOyAgICAgLy8gc2l6ZSBvZiB0aGUgdmlld3BvcnRcXG5cXG51bmlmb3JtIHZlYzQgdUxpZ2h0Q29sb3I7ICAgLy8gbGlnaHQgY29sb3IsIGFscGhhIGNoYW5uZWwgdXNlZCBmb3IgaW50ZW5zaXR5LlxcbnVuaWZvcm0gdmVjMyB1TGlnaHRGYWxsb2ZmOyAvLyBsaWdodCBhdHRlbnVhdGlvbiBjb2VmZmljaWVudHMgKGNvbnN0YW50LCBsaW5lYXIsIHF1YWRyYXRpYylcXG51bmlmb3JtIGZsb2F0IHVMaWdodEhlaWdodDsgLy8gbGlnaHQgaGVpZ2h0IGFib3ZlIHRoZSB2aWV3cG9ydFxcblxcblxcbnVuaWZvcm0gdmVjMiB1TGlnaHREaXJlY3Rpb247XFxuXFxudm9pZCBtYWluKClcXG57XFxudmVjMiB0ZXhDb29yZCA9IGdsX0ZyYWdDb29yZC54eSAvIHVWaWV3U2l6ZTtcXG50ZXhDb29yZC55ID0gMS4wIC0gdGV4Q29vcmQueTsgLy8gRkJPcyBwb3NpdGlvbnMgYXJlIGZsaXBwZWQuXFxuXFxudmVjNCBub3JtYWxDb2xvciA9IHRleHR1cmUyRCh1Tm9ybWFsU2FtcGxlciwgdGV4Q29vcmQpO1xcbm5vcm1hbENvbG9yLmcgPSAxLjAgLSBub3JtYWxDb2xvci5nOyAvLyBHcmVlbiBsYXllciBpcyBmbGlwcGVkIFkgY29vcmRzLlxcblxcbi8vIGJhaWwgb3V0IGVhcmx5IHdoZW4gbm9ybWFsIGhhcyBubyBkYXRhXFxuaWYgKG5vcm1hbENvbG9yLmEgPT0gMC4wKSBkaXNjYXJkO1xcblxcblxcbiAgICAvLyB0aGUgZGlyZWN0aW9uYWwgdmVjdG9yIG9mIHRoZSBsaWdodFxcbiAgICB2ZWMzIGxpZ2h0VmVjdG9yID0gdmVjMyh1TGlnaHREaXJlY3Rpb24sIHVMaWdodEhlaWdodCk7XFxuXFxuICAgIC8vIGNvbXB1dGUgRGlzdGFuY2VcXG4gICAgZmxvYXQgRCA9IGxlbmd0aChsaWdodFZlY3Rvcik7XFxuXFxuLy8gbm9ybWFsaXplIHZlY3RvcnNcXG52ZWMzIE4gPSBub3JtYWxpemUobm9ybWFsQ29sb3IueHl6ICogMi4wIC0gMS4wKTtcXG52ZWMzIEwgPSBub3JtYWxpemUobGlnaHRWZWN0b3IpO1xcblxcbi8vIHByZS1tdWx0aXBseSBsaWdodCBjb2xvciB3aXRoIGludGVuc2l0eVxcbi8vIHRoZW4gcGVyZm9ybSBcXFwiTiBkb3QgTFxcXCIgdG8gZGV0ZXJtaW5lIG91ciBkaWZmdXNlXFxudmVjMyBkaWZmdXNlID0gKHVMaWdodENvbG9yLnJnYiAqIHVMaWdodENvbG9yLmEpICogbWF4KGRvdChOLCBMKSwgMC4wKTtcXG5cXG5cXG4gICAgLy8gY2FsY3VsYXRlIGF0dGVudWF0aW9uXFxuICAgIGZsb2F0IGF0dGVudWF0aW9uID0gMS4wO1xcblxcbi8vIGNhbGN1bGF0ZSBmaW5hbCBpbnRlc2l0eSBhbmQgY29sb3IsIHRoZW4gY29tYmluZVxcbnZlYzMgaW50ZW5zaXR5ID0gZGlmZnVzZSAqIGF0dGVudWF0aW9uO1xcbnZlYzQgZGlmZnVzZUNvbG9yID0gdGV4dHVyZTJEKHVTYW1wbGVyLCB0ZXhDb29yZCk7XFxudmVjMyBmaW5hbENvbG9yID0gZGlmZnVzZUNvbG9yLnJnYiAqIGludGVuc2l0eTtcXG5cXG5nbF9GcmFnQ29sb3IgPSB2ZWM0KGZpbmFsQ29sb3IsIGRpZmZ1c2VDb2xvci5hKTtcXG5cXG59XFxuXCIsXG4gICAgICAgIC8vIGN1c3RvbSB1bmlmb3Jtc1xuICAgICAgICB7XG4gICAgICAgICAgICAvLyB0aGUgZGlyZWN0aW9uYWwgdmVjdG9yIG9mIHRoZSBsaWdodFxuICAgICAgICAgICAgdUxpZ2h0RGlyZWN0aW9uOiB7IHR5cGU6ICcyZicsIHZhbHVlOiBuZXcgRmxvYXQzMkFycmF5KDIpIH1cbiAgICAgICAgfVxuICAgICk7XG59XG5cbkRpcmVjdGlvbmFsTGlnaHRTaGFkZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShMaWdodFNoYWRlci5wcm90b3R5cGUpO1xuRGlyZWN0aW9uYWxMaWdodFNoYWRlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBEaXJlY3Rpb25hbExpZ2h0U2hhZGVyO1xubW9kdWxlLmV4cG9ydHMgPSBEaXJlY3Rpb25hbExpZ2h0U2hhZGVyO1xuXG5tYWluLnJlZ2lzdGVyUGx1Z2luKCdkaXJlY3Rpb25hbExpZ2h0U2hhZGVyJywgRGlyZWN0aW9uYWxMaWdodFNoYWRlcik7XG4iLCIvKipcbiAqIEV4Y3VzZSB0aGUgbWVzcywgaGF2ZW4ndCBjbGVhbmVkIHRoaXMgdXAgeWV0IVxuICovXG5cbnZhciBtYWluID0gcmVxdWlyZSgnLi4vLi4vbWFpbicpO1xuXG4vKipcbiAqIEBjbGFzc1xuICogQGV4dGVuZHMgUElYSS5EaXNwbGF5T2JqZWN0XG4gKiBAbWVtYmVyb2YgUElYSS5saWdodHNcbiAqXG4gKiBAcGFyYW0gW2NvbG9yPTB4RkZGRkZGXSB7bnVtYmVyfSBUaGUgY29sb3Igb2YgdGhlIGxpZ2h0LlxuICogQHBhcmFtIFticmlnaHRuZXNzPTFdIHtudW1iZXJ9IFRoZSBicmlnaHRuZXNzIG9mIHRoZSBsaWdodCwgaW4gcmFuZ2UgWzAsIDFdLlxuICovXG5mdW5jdGlvbiBMaWdodChjb2xvciwgYnJpZ2h0bmVzcywgdmVydGljZXMsIGluZGljZXMpIHtcbiAgICBpZiAodGhpcy5jb25zdHJ1Y3RvciA9PT0gTGlnaHQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdMaWdodCBpcyBhbiBhYnN0cmFjdCBiYXNlIGNsYXNzLCBpdCBzaG91bGQgbm90IGJlIGNyZWF0ZWQgZGlyZWN0bHkhJyk7XG4gICAgfVxuXG4gICAgUElYSS5Db250YWluZXIuY2FsbCh0aGlzKTtcblxuICAgIC8qKlxuICAgICAqIEFuIGFycmF5IG9mIHZlcnRpY2VzXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtGbG9hdDMyQXJyYXl9XG4gICAgICovXG4gICAgdGhpcy52ZXJ0aWNlcyA9IHZlcnRpY2VzIHx8IG5ldyBGbG9hdDMyQXJyYXkoOCk7XG5cbiAgICAvKipcbiAgICAgKiBBbiBhcnJheSBjb250YWluaW5nIHRoZSBpbmRpY2VzIG9mIHRoZSB2ZXJ0aWNlc1xuICAgICAqXG4gICAgICogQG1lbWJlciB7VWludDE2QXJyYXl9XG4gICAgICovXG4gICAgdGhpcy5pbmRpY2VzID0gaW5kaWNlcyB8fCBuZXcgVWludDE2QXJyYXkoWzAsMSwyLCAwLDIsM10pO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGJsZW5kIG1vZGUgdG8gYmUgYXBwbGllZCB0byB0aGUgbGlnaHQuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICogQGRlZmF1bHQgQ09OU1QuQkxFTkRfTU9ERVMuQUREO1xuICAgICAqL1xuICAgIHRoaXMuYmxlbmRNb2RlID0gUElYSS5CTEVORF9NT0RFUy5BREQ7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZHJhdyBtb2RlIHRvIGJlIGFwcGxpZWQgdG8gdGhlIGxpZ2h0IGdlb21ldHJ5LlxuICAgICAqXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAqIEBkZWZhdWx0IENPTlNULkRSQVdfTU9ERVMuVFJJQU5HTEVTO1xuICAgICAqL1xuICAgIHRoaXMuZHJhd01vZGUgPSBQSVhJLkRSQVdfTU9ERVMuVFJJQU5HTEVTO1xuXG4gICAgLyoqXG4gICAgICogV2hlbiBpbmNyZW1lbnRlZCB0aGUgcmVuZGVyZXIgd2lsbCByZS11cGxvYWQgaW5kaWNlc1xuICAgICAqXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuZGlydHkgPSAwO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGhlaWdodCBvZiB0aGUgbGlnaHQgZnJvbSB0aGUgdmlld3BvcnQuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICogQGRlZmF1bHQgMC4wNzVcbiAgICAgKi9cbiAgICB0aGlzLmxpZ2h0SGVpZ2h0ID0gMC4wNzU7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZmFsbG9mZiBhdHRlbnVhdGlvbiBjb2VmaWNpZW50cy5cbiAgICAgKlxuICAgICAqIEBtZW1iZXIge251bWJlcltdfVxuICAgICAqIEBkZWZhdWx0IFswLjc1LCAzLCAyMF1cbiAgICAgKi9cbiAgICB0aGlzLmZhbGxvZmYgPSBbMC43NSwgMywgMjBdO1xuXG4gICAgLyoqXG4gICAgICogVGhlIG5hbWUgb2YgdGhlIHNoYWRlciBwbHVnaW4gdG8gdXNlLlxuICAgICAqXG4gICAgICogQG1lbWJlciB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMuc2hhZGVyTmFtZSA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBCeSBkZWZhdWx0IHRoZSBsaWdodCB1c2VzIGEgdmlld3BvcnQgc2l6ZWQgcXVhZCBhcyB0aGUgbWVzaC5cbiAgICAgKi9cbiAgICB0aGlzLnVzZVZpZXdwb3J0UXVhZCA9IHRydWU7XG5cbiAgICAvLyBjb2xvciBhbmQgYnJpZ2h0bmVzcyBhcmUgZXhwb3NlZCB0aHJvdWdoIHNldHRlcnNcbiAgICB0aGlzLl9jb2xvciA9IDB4NGQ0ZDU5O1xuICAgIHRoaXMuX2NvbG9yUmdiYSA9IFswLjMsIDAuMywgMC4zNSwgMC44XTtcblxuICAgIC8vIHJ1biB0aGUgY29sb3Igc2V0dGVyXG4gICAgaWYgKGNvbG9yIHx8IGNvbG9yID09PSAwKSB7XG4gICAgICAgIHRoaXMuY29sb3IgPSBjb2xvcjtcbiAgICB9XG5cbiAgICAvLyBydW4gdGhlIGJyaWdodG5lc3Mgc2V0dGVyXG4gICAgaWYgKGJyaWdodG5lc3MgfHwgYnJpZ2h0bmVzcyA9PT0gMCkge1xuICAgICAgICB0aGlzLmJyaWdodG5lc3MgPSBicmlnaHRuZXNzO1xuICAgIH1cblxuICAgIHRoaXMucGFyZW50R3JvdXAgPSBtYWluLmxpZ2h0R3JvdXA7XG5cblxuICAgIC8qKlxuICAgICAqIFdlYkdMIGRhdGEgZm9yIHRoaXMgbGlnaHRcbiAgICAgKiBAbWVtYmVyIHtPYmplY3R9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl9nbERhdGFzID0ge307XG5cbiAgICB0aGlzLnNoYWRlck5hbWUgPSAnbGlnaHRzJztcbn1cblxuTGlnaHQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShQSVhJLkNvbnRhaW5lci5wcm90b3R5cGUpO1xuTGlnaHQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTGlnaHQ7XG5tb2R1bGUuZXhwb3J0cyA9IExpZ2h0O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhMaWdodC5wcm90b3R5cGUsIHtcbiAgICAvKipcbiAgICAgKiBUaGUgY29sb3Igb2YgdGhlIGxpZ2h0aW5nLlxuICAgICAqXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAqIEBtZW1iZXJvZiBMaWdodCNcbiAgICAgKi9cbiAgICBjb2xvcjoge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jb2xvcjtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLl9jb2xvciA9IHZhbDtcbiAgICAgICAgICAgIFBJWEkudXRpbHMuaGV4MnJnYih2YWwsIHRoaXMuX2NvbG9yUmdiYSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGhlIGJyaWdodG5lc3Mgb2YgdGhpcyBsaWdodGluZy4gTm9ybWFsaXplZCBpbiB0aGUgcmFuZ2UgWzAsIDFdLlxuICAgICAqXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAqIEBtZW1iZXJvZiBMaWdodCNcbiAgICAgKi9cbiAgICBicmlnaHRuZXNzOiB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NvbG9yUmdiYVszXTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLl9jb2xvclJnYmFbM10gPSB2YWw7XG4gICAgICAgIH1cbiAgICB9XG59KTtcblxuTGlnaHQucHJvdG90eXBlLnN5bmNTaGFkZXIgPSBmdW5jdGlvbiAoc2hhZGVyKSB7XG4gICAgc2hhZGVyLnVuaWZvcm1zLnVVc2VWaWV3cG9ydFF1YWQgPSB0aGlzLnVzZVZpZXdwb3J0UXVhZDtcblxuICAgIHZhciB1TGlnaHRDb2xvciA9IHNoYWRlci51bmlmb3Jtcy51TGlnaHRDb2xvcjtcbiAgICBpZiAodUxpZ2h0Q29sb3IpIHtcbiAgICAgICAgdUxpZ2h0Q29sb3JbMF0gPSB0aGlzLl9jb2xvclJnYmFbMF07XG4gICAgICAgIHVMaWdodENvbG9yWzFdID0gdGhpcy5fY29sb3JSZ2JhWzFdO1xuICAgICAgICB1TGlnaHRDb2xvclsyXSA9IHRoaXMuX2NvbG9yUmdiYVsyXTtcbiAgICAgICAgdUxpZ2h0Q29sb3JbM10gPSB0aGlzLl9jb2xvclJnYmFbM107XG4gICAgICAgIHNoYWRlci51bmlmb3Jtcy51TGlnaHRDb2xvciA9IHVMaWdodENvbG9yO1xuICAgIH1cblxuICAgIHNoYWRlci51bmlmb3Jtcy51TGlnaHRIZWlnaHQgPSB0aGlzLmxpZ2h0SGVpZ2h0O1xuXG4gICAgdmFyIHVMaWdodEZhbGxvZmYgPSBzaGFkZXIudW5pZm9ybXMudUxpZ2h0RmFsbG9mZjtcbiAgICBpZiAodUxpZ2h0RmFsbG9mZikge1xuICAgICAgICB1TGlnaHRGYWxsb2ZmWzBdID0gdGhpcy5mYWxsb2ZmWzBdO1xuICAgICAgICB1TGlnaHRGYWxsb2ZmWzFdID0gdGhpcy5mYWxsb2ZmWzFdO1xuICAgICAgICB1TGlnaHRGYWxsb2ZmWzJdID0gdGhpcy5mYWxsb2ZmWzJdO1xuICAgICAgICBzaGFkZXIudW5pZm9ybXMudUxpZ2h0RmFsbG9mZiA9IHVMaWdodEZhbGxvZmY7XG4gICAgfVxufTtcblxuTGlnaHQucHJvdG90eXBlLl9yZW5kZXJXZWJHTCA9IGZ1bmN0aW9uIChyZW5kZXJlcilcbntcbiAgICByZW5kZXJlci5zZXRPYmplY3RSZW5kZXJlcihyZW5kZXJlci5wbHVnaW5zLmxpZ2h0cyk7XG4gICAgcmVuZGVyZXIucGx1Z2lucy5saWdodHMucmVuZGVyKHRoaXMpO1xufTtcbiIsIlxyXG5cclxuLyoqXHJcbiAqIEBjbGFzc1xyXG4gKiBAZXh0ZW5kcyBQSVhJLlNoYWRlclxyXG4gKiBAbWVtYmVyb2YgUElYSS5saWdodHNcclxuICogQHBhcmFtIHNoYWRlck1hbmFnZXIge1NoYWRlck1hbmFnZXJ9IFRoZSBXZWJHTCBzaGFkZXIgbWFuYWdlciB0aGlzIHNoYWRlciB3b3JrcyBmb3IuXHJcbiAqL1xyXG5mdW5jdGlvbiBMaWdodFNoYWRlcihnbCwgdmVydGV4U3JjLCBmcmFnbWVudFNyYywgY3VzdG9tVW5pZm9ybXMsIGN1c3RvbUF0dHJpYnV0ZXMpIHtcclxuICAgIHZhciB1bmlmb3JtcyA9IHtcclxuICAgICAgICB0cmFuc2xhdGlvbk1hdHJpeDogIHsgdHlwZTogJ21hdDMnLCB2YWx1ZTogbmV3IEZsb2F0MzJBcnJheSg5KSB9LFxyXG4gICAgICAgIHByb2plY3Rpb25NYXRyaXg6ICAgeyB0eXBlOiAnbWF0MycsIHZhbHVlOiBuZXcgRmxvYXQzMkFycmF5KDkpIH0sXHJcblxyXG4gICAgICAgIC8vIHRleHR1cmVzIGZyb20gdGhlIHByZXZpb3VzbHkgcmVuZGVyZWQgRkJPc1xyXG4gICAgICAgIHVTYW1wbGVyOiAgICAgICB7IHR5cGU6ICdzYW1wbGVyMkQnLCB2YWx1ZTogbnVsbCB9LFxyXG4gICAgICAgIHVOb3JtYWxTYW1wbGVyOiB7IHR5cGU6ICdzYW1wbGVyMkQnLCB2YWx1ZTogbnVsbCB9LFxyXG5cclxuICAgICAgICAvLyBzaG91bGQgd2UgYXBwbHkgdGhlIHRyYW5zbGF0aW9uIG1hdHJpeCBvciBub3QuXHJcbiAgICAgICAgdVVzZVZpZXdwb3J0UXVhZDogeyB0eXBlOiAnYm9vbCcsIHZhbHVlOiB0cnVlIH0sXHJcblxyXG4gICAgICAgIC8vIHNpemUgb2YgdGhlIHJlbmRlcmVyIHZpZXdwb3J0XHJcbiAgICAgICAgdVZpZXdTaXplOiAgICAgIHsgdHlwZTogJzJmJywgdmFsdWU6IG5ldyBGbG9hdDMyQXJyYXkoMikgfSxcclxuXHJcbiAgICAgICAgLy8gbGlnaHQgY29sb3IsIGFscGhhIGNoYW5uZWwgdXNlZCBmb3IgaW50ZW5zaXR5LlxyXG4gICAgICAgIHVMaWdodENvbG9yOiAgICB7IHR5cGU6ICc0ZicsIHZhbHVlOiBuZXcgRmxvYXQzMkFycmF5KFsxLCAxLCAxLCAxXSkgfSxcclxuXHJcbiAgICAgICAgLy8gbGlnaHQgZmFsbG9mZiBhdHRlbnVhdGlvbiBjb2VmZmljaWVudHNcclxuICAgICAgICB1TGlnaHRGYWxsb2ZmOiAgeyB0eXBlOiAnM2YnLCB2YWx1ZTogbmV3IEZsb2F0MzJBcnJheShbMCwgMCwgMF0pIH0sXHJcblxyXG4gICAgICAgIC8vIGhlaWdodCBvZiB0aGUgbGlnaHQgYWJvdmUgdGhlIHZpZXdwb3J0XHJcbiAgICAgICAgdUxpZ2h0SGVpZ2h0OiB7IHR5cGU6ICcxZicsIHZhbHVlOiAwLjA3NSB9XHJcbiAgICB9O1xyXG5cclxuICAgIGlmIChjdXN0b21Vbmlmb3JtcylcclxuICAgIHtcclxuICAgICAgICBmb3IgKHZhciB1IGluIGN1c3RvbVVuaWZvcm1zKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdW5pZm9ybXNbdV0gPSBjdXN0b21Vbmlmb3Jtc1t1XTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGF0dHJpYnV0ZXMgPSB7XHJcbiAgICAgICAgYVZlcnRleFBvc2l0aW9uOiAwXHJcbiAgICB9O1xyXG5cclxuICAgIGlmIChjdXN0b21BdHRyaWJ1dGVzKVxyXG4gICAge1xyXG4gICAgICAgIGZvciAodmFyIGEgaW4gY3VzdG9tQXR0cmlidXRlcylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGF0dHJpYnV0ZXNbYV0gPSBjdXN0b21BdHRyaWJ1dGVzW2FdO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBQSVhJLlNoYWRlci5jYWxsKHRoaXMsIGdsLCB2ZXJ0ZXhTcmMgfHwgTGlnaHRTaGFkZXIuZGVmYXVsdFZlcnRleFNyYywgZnJhZ21lbnRTcmMsIGF0dHJpYnV0ZXMpO1xyXG59XHJcblxyXG5MaWdodFNoYWRlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFBJWEkuU2hhZGVyLnByb3RvdHlwZSk7XHJcbkxpZ2h0U2hhZGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IExpZ2h0U2hhZGVyO1xyXG5tb2R1bGUuZXhwb3J0cyA9IExpZ2h0U2hhZGVyO1xyXG5cclxuTGlnaHRTaGFkZXIuZGVmYXVsdFZlcnRleFNyYyA9IFwiI2RlZmluZSBHTFNMSUZZIDFcXG5hdHRyaWJ1dGUgdmVjMiBhVmVydGV4UG9zaXRpb247XFxuXFxudW5pZm9ybSBib29sIHVVc2VWaWV3cG9ydFF1YWQ7XFxudW5pZm9ybSBtYXQzIHRyYW5zbGF0aW9uTWF0cml4O1xcbnVuaWZvcm0gbWF0MyBwcm9qZWN0aW9uTWF0cml4O1xcblxcbnZvaWQgbWFpbih2b2lkKSB7XFxuICAgIGlmICh1VXNlVmlld3BvcnRRdWFkKSB7XFxuICAgICAgICBnbF9Qb3NpdGlvbiA9IHZlYzQoKHByb2plY3Rpb25NYXRyaXggKiB2ZWMzKGFWZXJ0ZXhQb3NpdGlvbiwgMS4wKSkueHksIDAuMCwgMS4wKTtcXG4gICAgfVxcbiAgICBlbHNlXFxuICAgIHtcXG4gICAgICAgIGdsX1Bvc2l0aW9uID0gdmVjNCgocHJvamVjdGlvbk1hdHJpeCAqIHRyYW5zbGF0aW9uTWF0cml4ICogdmVjMyhhVmVydGV4UG9zaXRpb24sIDEuMCkpLnh5LCAwLjAsIDEuMCk7XFxuICAgIH1cXG59XFxuXCI7XHJcbiIsInZhciBMaWdodCA9IHJlcXVpcmUoJy4uL2xpZ2h0L0xpZ2h0Jyk7XG5cbi8qKlxuICogQGNsYXNzXG4gKiBAZXh0ZW5kcyBQSVhJLmxpZ2h0cy5MaWdodFxuICogQG1lbWJlcm9mIFBJWEkubGlnaHRzXG4gKlxuICogQHBhcmFtIFtjb2xvcj0weEZGRkZGRl0ge251bWJlcn0gVGhlIGNvbG9yIG9mIHRoZSBsaWdodC5cbiAqIEBwYXJhbSBbYnJpZ2h0bmVzcz0xXSB7bnVtYmVyfSBUaGUgaW50ZW5zaXR5IG9mIHRoZSBsaWdodC5cbiAqIEBwYXJhbSBbcmFkaXVzPUluZmluaXR5XSB7bnVtYmVyfSBUaGUgZGlzdGFuY2UgdGhlIGxpZ2h0IHJlYWNoZXMuIFlvdSB3aWxsIGxpa2VseSBuZWVkXG4gKiAgdG8gY2hhbmdlIHRoZSBmYWxsb2ZmIG9mIHRoZSBsaWdodCBhcyB3ZWxsIGlmIHlvdSBjaGFuZ2UgdGhpcyB2YWx1ZS4gSW5maW5pdHkgd2lsbFxuICogIHVzZSB0aGUgZW50aXJlIHZpZXdwb3J0IGFzIHRoZSBkcmF3aW5nIHN1cmZhY2UuXG4gKi9cbmZ1bmN0aW9uIFBvaW50TGlnaHQoY29sb3IsIGJyaWdodG5lc3MsIHJhZGl1cykge1xuICAgIHJhZGl1cyA9IHJhZGl1cyB8fCBJbmZpbml0eTtcblxuICAgIGlmIChyYWRpdXMgIT09IEluZmluaXR5KSB7XG4gICAgICAgIHZhciBzaGFwZSA9IG5ldyBQSVhJLkNpcmNsZSgwLCAwLCByYWRpdXMpLFxuICAgICAgICAgICAgbWVzaCA9IHNoYXBlLmdldE1lc2goKTtcblxuICAgICAgICBMaWdodC5jYWxsKHRoaXMsIGNvbG9yLCBicmlnaHRuZXNzLCBtZXNoLnZlcnRpY2VzLCBtZXNoLmluZGljZXMpO1xuXG4gICAgICAgIHRoaXMudXNlVmlld3BvcnRRdWFkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZHJhd01vZGUgPSBQSVhJLkRSQVdfTU9ERVMuVFJJQU5HTEVfRkFOO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgTGlnaHQuY2FsbCh0aGlzLCBjb2xvciwgYnJpZ2h0bmVzcyk7XG4gICAgfVxuXG4gICAgdGhpcy5fc3luY1NoYWRlciA9IExpZ2h0LnByb3RvdHlwZS5zeW5jU2hhZGVyO1xuXG4gICAgdGhpcy5yYWRpdXMgPSByYWRpdXM7XG4gICAgdGhpcy5zaGFkZXJOYW1lID0gJ3BvaW50TGlnaHRTaGFkZXInO1xufVxuXG5Qb2ludExpZ2h0LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoTGlnaHQucHJvdG90eXBlKTtcblBvaW50TGlnaHQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUG9pbnRMaWdodDtcbm1vZHVsZS5leHBvcnRzID0gUG9pbnRMaWdodDtcblxuUG9pbnRMaWdodC5wcm90b3R5cGUuc3luY1NoYWRlciA9IGZ1bmN0aW9uIChzaGFkZXIpIHtcbiAgICB0aGlzLl9zeW5jU2hhZGVyKHNoYWRlcik7XG5cbiAgICBzaGFkZXIudW5pZm9ybXMudUxpZ2h0UmFkaXVzID0gdGhpcy5yYWRpdXM7XG59XG4iLCJ2YXIgbWFpbiA9IHJlcXVpcmUoJy4uLy4uL21haW4nKTtcclxudmFyIExpZ2h0U2hhZGVyID0gcmVxdWlyZSgnLi4vbGlnaHQvTGlnaHRTaGFkZXInKTtcclxuXHJcblxyXG4vKipcclxuICogQGNsYXNzXHJcbiAqIEBleHRlbmRzIFBJWEkuU2hhZGVyXHJcbiAqIEBtZW1iZXJvZiBQSVhJLmxpZ2h0c1xyXG4gKiBAcGFyYW0gc2hhZGVyTWFuYWdlciB7U2hhZGVyTWFuYWdlcn0gVGhlIFdlYkdMIHNoYWRlciBtYW5hZ2VyIHRoaXMgc2hhZGVyIHdvcmtzIGZvci5cclxuICovXHJcbmZ1bmN0aW9uIFBvaW50TGlnaHRTaGFkZXIoZ2wpIHtcclxuICAgIExpZ2h0U2hhZGVyLmNhbGwodGhpcyxcclxuICAgICAgICBnbCxcclxuICAgICAgICAvLyB2ZXJ0ZXggc2hhZGVyXHJcbiAgICAgICAgbnVsbCxcclxuICAgICAgICAvLyBmcmFnbWVudCBzaGFkZXJcclxuICAgICAgICBcInByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG4jZGVmaW5lIEdMU0xJRlkgMVxcblxcbi8vIGltcG9ydHMgdGhlIGNvbW1vbiB1bmlmb3JtcyBsaWtlIHNhbXBsZXJzLCBhbmQgYW1iaWVudCBjb2xvclxcbnVuaWZvcm0gc2FtcGxlcjJEIHVTYW1wbGVyO1xcbnVuaWZvcm0gc2FtcGxlcjJEIHVOb3JtYWxTYW1wbGVyO1xcblxcbnVuaWZvcm0gbWF0MyB0cmFuc2xhdGlvbk1hdHJpeDtcXG5cXG51bmlmb3JtIHZlYzIgdVZpZXdTaXplOyAgICAgLy8gc2l6ZSBvZiB0aGUgdmlld3BvcnRcXG5cXG51bmlmb3JtIHZlYzQgdUxpZ2h0Q29sb3I7ICAgLy8gbGlnaHQgY29sb3IsIGFscGhhIGNoYW5uZWwgdXNlZCBmb3IgaW50ZW5zaXR5LlxcbnVuaWZvcm0gdmVjMyB1TGlnaHRGYWxsb2ZmOyAvLyBsaWdodCBhdHRlbnVhdGlvbiBjb2VmZmljaWVudHMgKGNvbnN0YW50LCBsaW5lYXIsIHF1YWRyYXRpYylcXG51bmlmb3JtIGZsb2F0IHVMaWdodEhlaWdodDsgLy8gbGlnaHQgaGVpZ2h0IGFib3ZlIHRoZSB2aWV3cG9ydFxcblxcblxcbnVuaWZvcm0gZmxvYXQgdUxpZ2h0UmFkaXVzO1xcblxcbnZvaWQgbWFpbigpXFxue1xcbnZlYzIgdGV4Q29vcmQgPSBnbF9GcmFnQ29vcmQueHkgLyB1Vmlld1NpemU7XFxudGV4Q29vcmQueSA9IDEuMCAtIHRleENvb3JkLnk7IC8vIEZCT3MgcG9zaXRpb25zIGFyZSBmbGlwcGVkLlxcblxcbnZlYzQgbm9ybWFsQ29sb3IgPSB0ZXh0dXJlMkQodU5vcm1hbFNhbXBsZXIsIHRleENvb3JkKTtcXG5ub3JtYWxDb2xvci5nID0gMS4wIC0gbm9ybWFsQ29sb3IuZzsgLy8gR3JlZW4gbGF5ZXIgaXMgZmxpcHBlZCBZIGNvb3Jkcy5cXG5cXG4vLyBiYWlsIG91dCBlYXJseSB3aGVuIG5vcm1hbCBoYXMgbm8gZGF0YVxcbmlmIChub3JtYWxDb2xvci5hID09IDAuMCkgZGlzY2FyZDtcXG5cXG5cXG4gICAgdmVjMiBsaWdodFBvc2l0aW9uID0gdHJhbnNsYXRpb25NYXRyaXhbMl0ueHkgLyB1Vmlld1NpemU7XFxuXFxuICAgIC8vIHRoZSBkaXJlY3Rpb25hbCB2ZWN0b3Igb2YgdGhlIGxpZ2h0XFxuICAgIHZlYzMgbGlnaHRWZWN0b3IgPSB2ZWMzKGxpZ2h0UG9zaXRpb24gLSB0ZXhDb29yZCwgdUxpZ2h0SGVpZ2h0KTtcXG5cXG4gICAgLy8gY29ycmVjdCBmb3IgYXNwZWN0IHJhdGlvXFxuICAgIGxpZ2h0VmVjdG9yLnggKj0gdVZpZXdTaXplLnggLyB1Vmlld1NpemUueTtcXG5cXG4gICAgLy8gY29tcHV0ZSBEaXN0YW5jZVxcbiAgICBmbG9hdCBEID0gbGVuZ3RoKGxpZ2h0VmVjdG9yKTtcXG5cXG4gICAgLy8gYmFpbCBvdXQgZWFybHkgd2hlbiBwaXhlbCBvdXRzaWRlIG9mIGxpZ2h0IHNwaGVyZVxcbiAgICBpZiAoRCA+IHVMaWdodFJhZGl1cykgZGlzY2FyZDtcXG5cXG4vLyBub3JtYWxpemUgdmVjdG9yc1xcbnZlYzMgTiA9IG5vcm1hbGl6ZShub3JtYWxDb2xvci54eXogKiAyLjAgLSAxLjApO1xcbnZlYzMgTCA9IG5vcm1hbGl6ZShsaWdodFZlY3Rvcik7XFxuXFxuLy8gcHJlLW11bHRpcGx5IGxpZ2h0IGNvbG9yIHdpdGggaW50ZW5zaXR5XFxuLy8gdGhlbiBwZXJmb3JtIFxcXCJOIGRvdCBMXFxcIiB0byBkZXRlcm1pbmUgb3VyIGRpZmZ1c2VcXG52ZWMzIGRpZmZ1c2UgPSAodUxpZ2h0Q29sb3IucmdiICogdUxpZ2h0Q29sb3IuYSkgKiBtYXgoZG90KE4sIEwpLCAwLjApO1xcblxcblxcbiAgICAvLyBjYWxjdWxhdGUgYXR0ZW51YXRpb25cXG4gICAgZmxvYXQgYXR0ZW51YXRpb24gPSAxLjAgLyAodUxpZ2h0RmFsbG9mZi54ICsgKHVMaWdodEZhbGxvZmYueSAqIEQpICsgKHVMaWdodEZhbGxvZmYueiAqIEQgKiBEKSk7XFxuXFxuLy8gY2FsY3VsYXRlIGZpbmFsIGludGVzaXR5IGFuZCBjb2xvciwgdGhlbiBjb21iaW5lXFxudmVjMyBpbnRlbnNpdHkgPSBkaWZmdXNlICogYXR0ZW51YXRpb247XFxudmVjNCBkaWZmdXNlQ29sb3IgPSB0ZXh0dXJlMkQodVNhbXBsZXIsIHRleENvb3JkKTtcXG52ZWMzIGZpbmFsQ29sb3IgPSBkaWZmdXNlQ29sb3IucmdiICogaW50ZW5zaXR5O1xcblxcbmdsX0ZyYWdDb2xvciA9IHZlYzQoZmluYWxDb2xvciwgZGlmZnVzZUNvbG9yLmEpO1xcblxcbn1cXG5cIixcclxuICAgICAgICAvLyBjdXN0b20gdW5pZm9ybXNcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIC8vIGhlaWdodCBvZiB0aGUgbGlnaHQgYWJvdmUgdGhlIHZpZXdwb3J0XHJcbiAgICAgICAgICAgIHVMaWdodFJhZGl1czogICB7IHR5cGU6ICcxZicsIHZhbHVlOiAxIH1cclxuICAgICAgICB9XHJcbiAgICApO1xyXG59XHJcblxyXG5Qb2ludExpZ2h0U2hhZGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoTGlnaHRTaGFkZXIucHJvdG90eXBlKTtcclxuUG9pbnRMaWdodFNoYWRlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBQb2ludExpZ2h0U2hhZGVyO1xyXG5tb2R1bGUuZXhwb3J0cyA9IFBvaW50TGlnaHRTaGFkZXI7XHJcblxyXG5tYWluLnJlZ2lzdGVyUGx1Z2luKCdwb2ludExpZ2h0U2hhZGVyJywgUG9pbnRMaWdodFNoYWRlcik7XHJcbiIsIm1vZHVsZS5leHBvcnRzID0ge1xuICAgIHBsdWdpbnM6IHt9LFxuICAgIHJlZ2lzdGVyUGx1Z2luOiBmdW5jdGlvbihuYW1lLCBmdW4pIHtcbiAgICAgICAgdGhpcy5wbHVnaW5zW25hbWVdID0gZnVuO1xuICAgIH0sXG4gICAgZGlmZnVzZUdyb3VwOiBuZXcgUElYSS5kaXNwbGF5Lkdyb3VwKCksXG4gICAgbm9ybWFsR3JvdXA6IG5ldyBQSVhJLmRpc3BsYXkuR3JvdXAoKSxcbiAgICBsaWdodEdyb3VwOiBuZXcgUElYSS5kaXNwbGF5Lkdyb3VwKClcbn07XG5cbm1vZHVsZS5leHBvcnRzLmRpZmZ1c2VHcm91cC51c2VSZW5kZXJUZXh0dXJlID0gdHJ1ZTtcbm1vZHVsZS5leHBvcnRzLm5vcm1hbEdyb3VwLnVzZVJlbmRlclRleHR1cmUgPSB0cnVlO1xuIiwidmFyIG1haW4gPSByZXF1aXJlKCcuLi9tYWluJyk7XG52YXIgZ2xDb3JlID0gUElYSS5nbENvcmU7XG5cbi8qKlxuICpcbiAqIEBjbGFzc1xuICogQHByaXZhdGVcbiAqIEBtZW1iZXJvZiBQSVhJLmxpZ2h0c1xuICogQGV4dGVuZHMgUElYSS5PYmplY3RSZW5kZXJlclxuICogQHBhcmFtIHJlbmRlcmVyIHtXZWJHTFJlbmRlcmVyfSBUaGUgcmVuZGVyZXIgdGhpcyBzcHJpdGUgYmF0Y2ggd29ya3MgZm9yLlxuICovXG5mdW5jdGlvbiBMaWdodFJlbmRlcmVyKHJlbmRlcmVyKSB7XG4gICAgUElYSS5PYmplY3RSZW5kZXJlci5jYWxsKHRoaXMsIHJlbmRlcmVyKTtcblxuICAgIC8vIHRoZSB0b3RhbCBudW1iZXIgb2YgaW5kaWNlcyBpbiBvdXIgYmF0Y2gsIHRoZXJlIGFyZSA2IHBvaW50cyBwZXIgcXVhZC5cbiAgICB2YXIgbnVtSW5kaWNlcyA9IExpZ2h0UmVuZGVyZXIuTUFYX0xJR0hUUyAqIDY7XG5cbiAgICAvKipcbiAgICAgKiBIb2xkcyB0aGUgaW5kaWNlc1xuICAgICAqXG4gICAgICogQG1lbWJlciB7VWludDE2QXJyYXl9XG4gICAgICovXG4gICAgdGhpcy5pbmRpY2VzID0gbmV3IFVpbnQxNkFycmF5KG51bUluZGljZXMpO1xuXG4gICAgLy9UT0RPIHRoaXMgY291bGQgYmUgYSBzaW5nbGUgYnVmZmVyIHNoYXJlZCBhbW9uZ3N0IGFsbCByZW5kZXJlcnMgYXMgd2UgcmV1c2UgdGhpcyBzZXQgdXAgaW4gbW9zdCByZW5kZXJlcnNcbiAgICBmb3IgKHZhciBpID0gMCwgaiA9IDA7IGkgPCBudW1JbmRpY2VzOyBpICs9IDYsIGogKz0gNCkge1xuICAgICAgICB0aGlzLmluZGljZXNbaSArIDBdID0gaiArIDA7XG4gICAgICAgIHRoaXMuaW5kaWNlc1tpICsgMV0gPSBqICsgMTtcbiAgICAgICAgdGhpcy5pbmRpY2VzW2kgKyAyXSA9IGogKyAyO1xuICAgICAgICB0aGlzLmluZGljZXNbaSArIDNdID0gaiArIDA7XG4gICAgICAgIHRoaXMuaW5kaWNlc1tpICsgNF0gPSBqICsgMjtcbiAgICAgICAgdGhpcy5pbmRpY2VzW2kgKyA1XSA9IGogKyAzO1xuICAgIH1cblxuICAgIHRoaXMuc2hhZGVycyA9IHt9O1xuXG4gICAgLyoqXG4gICAgICogVGhlIGN1cnJlbnQgbGlnaHRzIGluIHRoZSBiYXRjaC5cbiAgICAgKlxuICAgICAqIEBtZW1iZXIge0xpZ2h0W119XG4gICAgICovXG4gICAgdGhpcy5saWdodHMgPSBbXTtcbn1cblxuTGlnaHRSZW5kZXJlci5NQVhfTElHSFRTID0gNTAwO1xuXG5MaWdodFJlbmRlcmVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoUElYSS5PYmplY3RSZW5kZXJlci5wcm90b3R5cGUpO1xuTGlnaHRSZW5kZXJlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBMaWdodFJlbmRlcmVyO1xubW9kdWxlLmV4cG9ydHMgPSBMaWdodFJlbmRlcmVyO1xuXG5QSVhJLldlYkdMUmVuZGVyZXIucmVnaXN0ZXJQbHVnaW4oJ2xpZ2h0cycsIExpZ2h0UmVuZGVyZXIpO1xuXG5MaWdodFJlbmRlcmVyLnByb3RvdHlwZS5vbkNvbnRleHRDaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5nbCA9IHRoaXMucmVuZGVyZXIuZ2w7XG4gICAgZm9yICh2YXIga2V5IGluIG1haW4ucGx1Z2lucykge1xuICAgICAgICB0aGlzLnNoYWRlcnNba2V5XSA9IG5ldyAobWFpbi5wbHVnaW5zW2tleV0pKHRoaXMuZ2wpO1xuICAgIH1cbn07XG5cbi8qKlxuICogUmVuZGVycyB0aGUgbGlnaHQgb2JqZWN0LlxuICpcbiAqIEBwYXJhbSBsaWdodCB7TGlnaHR9IHRoZSBsaWdodCB0byByZW5kZXJcbiAqL1xuTGlnaHRSZW5kZXJlci5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKG1lc2gpIHtcbiAgICB2YXIgcmVuZGVyZXIgPSB0aGlzLnJlbmRlcmVyO1xuICAgIHZhciBnbCA9IHJlbmRlcmVyLmdsO1xuXG4gICAgdGhpcy5saWdodHMucHVzaChtZXNoKTtcbiAgICAvKipcbiAgICAgKiBQcmVwYXJlcyBhbGwgdGhlIGJ1ZmZlcnMgdG8gcmVuZGVyIHRoaXMgbGlnaHQuXG4gICAgICovXG4gICAgdmFyIGdsRGF0YSA9IG1lc2guX2dsRGF0YXNbcmVuZGVyZXIuQ09OVEVYVF9VSURdO1xuXG4gICAgaWYgKCFnbERhdGEpIHtcbiAgICAgICAgcmVuZGVyZXIuYmluZFZhbyhudWxsKTtcblxuICAgICAgICBnbERhdGEgPSB7XG4gICAgICAgICAgICBzaGFkZXI6IHRoaXMuc2hhZGVyc1ttZXNoLnNoYWRlck5hbWVdLFxuICAgICAgICAgICAgdmVydGV4QnVmZmVyOiBnbENvcmUuR0xCdWZmZXIuY3JlYXRlVmVydGV4QnVmZmVyKGdsLCBtZXNoLnZlcnRpY2VzLCBnbC5TVFJFQU1fRFJBVyksXG4gICAgICAgICAgICBpbmRleEJ1ZmZlcjogZ2xDb3JlLkdMQnVmZmVyLmNyZWF0ZUluZGV4QnVmZmVyKGdsLCBtZXNoLmluZGljZXMsIGdsLlNUQVRJQ19EUkFXKSxcbiAgICAgICAgICAgIC8vIGJ1aWxkIHRoZSB2YW8gb2JqZWN0IHRoYXQgd2lsbCByZW5kZXIuLlxuICAgICAgICAgICAgdmFvOiBudWxsLFxuICAgICAgICAgICAgZGlydHk6IG1lc2guZGlydHlcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBidWlsZCB0aGUgdmFvIG9iamVjdCB0aGF0IHdpbGwgcmVuZGVyLi5cbiAgICAgICAgZ2xEYXRhLnZhbyA9IG5ldyBnbENvcmUuVmVydGV4QXJyYXlPYmplY3QoZ2wpXG4gICAgICAgICAgICAuYWRkSW5kZXgoZ2xEYXRhLmluZGV4QnVmZmVyKVxuICAgICAgICAgICAgLmFkZEF0dHJpYnV0ZShnbERhdGEudmVydGV4QnVmZmVyLCBnbERhdGEuc2hhZGVyLmF0dHJpYnV0ZXMuYVZlcnRleFBvc2l0aW9uLCBnbC5GTE9BVCwgZmFsc2UsIDIgKiA0LCAwKVxuXG4gICAgICAgIG1lc2guX2dsRGF0YXNbcmVuZGVyZXIuQ09OVEVYVF9VSURdID0gZ2xEYXRhO1xuICAgIH1cblxuICAgIHJlbmRlcmVyLmJpbmRWYW8oZ2xEYXRhLnZhbyk7XG5cbiAgICBpZiAobWVzaC51c2VWaWV3cG9ydFF1YWQpIHtcbiAgICAgICAgbWVzaC52ZXJ0aWNlc1syXSA9IG1lc2gudmVydGljZXNbNF0gPSByZW5kZXJlci5zY3JlZW4ud2lkdGg7XG4gICAgICAgIG1lc2gudmVydGljZXNbNV0gPSBtZXNoLnZlcnRpY2VzWzddID0gcmVuZGVyZXIuc2NyZWVuLmhlaWdodDtcbiAgICB9XG4gICAgZ2xEYXRhLnZlcnRleEJ1ZmZlci51cGxvYWQobWVzaC52ZXJ0aWNlcyk7XG5cbiAgICBpZiAoZ2xEYXRhLmRpcnR5ICE9PSBtZXNoLmRpcnR5KSB7XG4gICAgICAgIGdsRGF0YS5kaXJ0eSA9IG1lc2guZGlydHk7XG4gICAgICAgIGdsRGF0YS5pbmRleEJ1ZmZlci51cGxvYWQobWVzaC5pbmRpY2VzKTtcbiAgICB9XG59O1xuXG5MaWdodFJlbmRlcmVyLnByb3RvdHlwZS5mbHVzaCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZGlmZnVzZVRleHR1cmUgPSBudWxsLFxuICAgICAgICBub3JtYWxUZXh0dXJlID0gbnVsbCxcbiAgICAgICAgbGFzdExheWVyID0gbnVsbCxcbiAgICAgICAgbGFzdFNoYWRlciA9IG51bGwsXG4gICAgICAgIHJlbmRlcmVyID0gdGhpcy5yZW5kZXJlcjtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5saWdodHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIGxpZ2h0ID0gdGhpcy5saWdodHNbaV0sXG4gICAgICAgICAgICBsYXllciA9IHRoaXMubGlnaHRzW2ldLl9hY3RpdmVQYXJlbnRMYXllcjtcblxuICAgICAgICBpZiAoIWxheWVyKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChsYXN0TGF5ZXIgIT09IGxheWVyKSB7XG4gICAgICAgICAgICBsYXN0TGF5ZXIgPSBsYXllcjtcbiAgICAgICAgICAgIHZhciBzdGFnZSA9IGxheWVyLl9hY3RpdmVTdGFnZVBhcmVudDtcblxuICAgICAgICAgICAgaWYgKGxheWVyLmRpZmZ1c2VUZXh0dXJlICYmXG4gICAgICAgICAgICAgICAgbGF5ZXIubm9ybWFsVGV4dHVyZSkge1xuICAgICAgICAgICAgICAgIGRpZmZ1c2VUZXh0dXJlID0gbGF5ZXIuZGlmZnVzZVRleHR1cmU7XG4gICAgICAgICAgICAgICAgbm9ybWFsVGV4dHVyZSA9IGxheWVyLm5vcm1hbFRleHR1cmU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgc3RhZ2UuX2FjdGl2ZUxheWVycy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdGV4TGF5ZXIgPSBzdGFnZS5fYWN0aXZlTGF5ZXJzW2pdO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGV4TGF5ZXIuZ3JvdXAgPT09IG1haW4ubm9ybWFsR3JvdXApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vcm1hbFRleHR1cmUgPSB0ZXhMYXllci5nZXRSZW5kZXJUZXh0dXJlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRleExheWVyLmdyb3VwID09PSBtYWluLmRpZmZ1c2VHcm91cCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGlmZnVzZVRleHR1cmUgPSB0ZXhMYXllci5nZXRSZW5kZXJUZXh0dXJlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJlbmRlcmVyLmJpbmRUZXh0dXJlKGRpZmZ1c2VUZXh0dXJlLCAwLCB0cnVlKTtcbiAgICAgICAgICAgIHJlbmRlcmVyLmJpbmRUZXh0dXJlKG5vcm1hbFRleHR1cmUsIDEsIHRydWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGdsRGF0YSA9IGxpZ2h0Ll9nbERhdGFzW3JlbmRlcmVyLkNPTlRFWFRfVUlEXSxcbiAgICAgICAgICAgIHNoYWRlciA9IGdsRGF0YS5zaGFkZXI7XG5cbiAgICAgICAgaWYgKGxhc3RTaGFkZXIgIT09IHNoYWRlcikge1xuICAgICAgICAgICAgbGFzdFNoYWRlciA9IHNoYWRlcjtcbiAgICAgICAgICAgIHJlbmRlcmVyLmJpbmRTaGFkZXIoc2hhZGVyKTtcblxuICAgICAgICAgICAgc2hhZGVyLnVuaWZvcm1zLnVTYW1wbGVyID0gMDtcbiAgICAgICAgICAgIHNoYWRlci51bmlmb3Jtcy51Tm9ybWFsU2FtcGxlciA9IDE7XG5cbiAgICAgICAgICAgIHZhciB1Vmlld1NpemUgPSBzaGFkZXIudW5pZm9ybXMudVZpZXdTaXplO1xuICAgICAgICAgICAgdVZpZXdTaXplWzBdID0gcmVuZGVyZXIuc2NyZWVuLndpZHRoO1xuICAgICAgICAgICAgdVZpZXdTaXplWzFdID0gcmVuZGVyZXIuc2NyZWVuLmhlaWdodDtcbiAgICAgICAgICAgIHNoYWRlci51bmlmb3Jtcy51Vmlld1NpemUgPSB1Vmlld1NpemU7XG4gICAgICAgIH1cblxuICAgICAgICByZW5kZXJlci5iaW5kVmFvKGdsRGF0YS52YW8pO1xuXG4gICAgICAgIGxpZ2h0LnN5bmNTaGFkZXIoc2hhZGVyKTtcbiAgICAgICAgcmVuZGVyZXIuc3RhdGUuc2V0QmxlbmRNb2RlKGxpZ2h0LmJsZW5kTW9kZSk7XG4gICAgICAgIHNoYWRlci51bmlmb3Jtcy50cmFuc2xhdGlvbk1hdHJpeCA9IGxpZ2h0LndvcmxkVHJhbnNmb3JtLnRvQXJyYXkodHJ1ZSk7XG5cbiAgICAgICAgZ2xEYXRhLnZhby5kcmF3KGxpZ2h0LmRyYXdNb2RlLCBsaWdodC5pbmRpY2VzLmxlbmd0aCwgMCk7XG4gICAgfVxuXG4gICAgdGhpcy5saWdodHMubGVuZ3RoID0gMDtcbn07XG5cbkxpZ2h0UmVuZGVyZXIucHJvdG90eXBlLnN0b3AgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmZsdXNoKCk7XG59O1xuIiwiLyoqXHJcbiAqIENyZWF0ZXMgdmVydGljZXMgYW5kIGluZGljZXMgYXJyYXlzIHRvIGRlc2NyaWJlIHRoaXMgY2lyY2xlLlxyXG4gKiBcclxuICogQHBhcmFtIFt0b3RhbFNlZ21lbnRzPTQwXSB7bnVtYmVyfSBUb3RhbCBzZWdtZW50cyB0byBidWlsZCBmb3IgdGhlIGNpcmNsZSBtZXNoLlxyXG4gKiBAcGFyYW0gW3ZlcnRpY2VzT3V0cHV0XSB7RmxvYXQzMkFycmF5fSBBbiBhcnJheSB0byBvdXRwdXQgdGhlIHZlcnRpY2VzIGludG8uIExlbmd0aCBtdXN0IGJlXHJcbiAqICBgKCh0b3RhbFNlZ21lbnRzICsgMikgKiAyKWAgb3IgbW9yZS4gSWYgbm90IHBhc3NlZCBpdCBpcyBjcmVhdGVkIGZvciB5b3UuXHJcbiAqIEBwYXJhbSBbaW5kaWNlc091dHB1dF0ge1VpbnQxNkFycmF5fSBBbiBhcnJheSB0byBvdXRwdXQgdGhlIGluZGljZXMgaW50bywgaW4gZ2wuVFJJQU5HTEVfRkFOIGZvcm1hdC4gTGVuZ3RoIG11c3RcclxuICogIGJlIGAodG90YWxTZWdtZW50cyArIDMpYCBvciBtb3JlLiBJZiBub3QgcGFzc2VkIGl0IGlzIGNyZWF0ZWQgZm9yIHlvdS5cclxuICovXHJcblBJWEkuQ2lyY2xlLnByb3RvdHlwZS5nZXRNZXNoID0gZnVuY3Rpb24gKHRvdGFsU2VnbWVudHMsIHZlcnRpY2VzLCBpbmRpY2VzKVxyXG57XHJcbiAgICB0b3RhbFNlZ21lbnRzID0gdG90YWxTZWdtZW50cyB8fCA0MDtcclxuXHJcbiAgICB2ZXJ0aWNlcyA9IHZlcnRpY2VzIHx8IG5ldyBGbG9hdDMyQXJyYXkoKHRvdGFsU2VnbWVudHMgKyAxKSAqIDIpO1xyXG4gICAgaW5kaWNlcyA9IGluZGljZXMgfHwgbmV3IFVpbnQxNkFycmF5KHRvdGFsU2VnbWVudHMgKyAxKTtcclxuXHJcbiAgICB2YXIgc2VnID0gKE1hdGguUEkgKiAyKSAvIHRvdGFsU2VnbWVudHMsXHJcbiAgICAgICAgaW5kaWNlc0luZGV4ID0gLTE7XHJcblxyXG4gICAgaW5kaWNlc1srK2luZGljZXNJbmRleF0gPSBpbmRpY2VzSW5kZXg7XHJcblxyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPD0gdG90YWxTZWdtZW50czsgKytpKVxyXG4gICAge1xyXG4gICAgICAgIHZhciBpbmRleCA9IGkqMjtcclxuICAgICAgICB2YXIgYW5nbGUgPSBzZWcgKiBpO1xyXG5cclxuICAgICAgICB2ZXJ0aWNlc1tpbmRleF0gPSBNYXRoLmNvcyhhbmdsZSkgKiB0aGlzLnJhZGl1cztcclxuICAgICAgICB2ZXJ0aWNlc1tpbmRleCsxXSA9IE1hdGguc2luKGFuZ2xlKSAqIHRoaXMucmFkaXVzO1xyXG5cclxuICAgICAgICBpbmRpY2VzWysraW5kaWNlc0luZGV4XSA9IGluZGljZXNJbmRleDtcclxuICAgIH1cclxuXHJcbiAgICBpbmRpY2VzW2luZGljZXNJbmRleF0gPSAxO1xyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgdmVydGljZXM6IHZlcnRpY2VzLFxyXG4gICAgICAgIGluZGljZXM6IGluZGljZXNcclxuICAgIH07XHJcbn07XHJcbiJdfQ=="}