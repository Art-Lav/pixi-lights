{"version":3,"sources":["node_modules/browserify/node_modules/browser-pack/_prelude.js","src/index","pixi-lights.min.js","src/light_2/lightSpriteMixin.js","src/light_2/lights/Light.js","src/light_2/lights/LightShader.js","src/light_2/lights/point/PointLight.js","src/light_2/lights/point/PointLightShader.js","src/light_2/renderers/LightRenderer.js","src/light_2/renderers/WebGLDeferredRenderer.js"],"names":["e","t","n","r","s","o","u","a","require","i","f","Error","code","l","exports","call","length",1,"module","PIXI","lights","Light","LightShader","PointLight","PointLightShader","LightRenderer","WebGLDeferredRenderer","./light_2/lightSpriteMixin","./light_2/lights/Light","./light_2/lights/LightShader","./light_2/lights/point/PointLight","./light_2/lights/point/PointLightShader","./light_2/renderers/LightRenderer","./light_2/renderers/WebGLDeferredRenderer",2,"Sprite","prototype","_renderWebGL","renderer","this","_originalTexture","_texture","renderingNormals","normalTexture","setObjectRenderer","plugins","sprite","render",3,"color","DisplayObject","_color","_colorRgba","undefined","height","falloff","children","shaderName","Object","create","constructor","defineProperties","get","set","val","utils","hex2rgb","renderWebGL",4,"shaderManager","vertexSrc","fragmentSrc","customUniforms","customAttributes","uniforms","projectionMatrix","type","value","Float32Array","uSampler","normalsRenderTarget","uNormalSampler","diffuseRenderTarget","uViewSize","uAmbientColor","_lightAmbientColorRgba","attributes","aVertexPosition","Shader",5,"intensity","distance","decay","../Light",6,"aLightColor","aLightPosition","aLightFalloff","ShaderManager","registerPlugin","../LightShader",7,"ObjectRenderer","vertSize","vertByteSize","size","MAX_LIGHTS","numVerts","numIndices","vertices","ArrayBuffer","positions","colors","Uint32Array","indices","Uint16Array","j","currentBatchSize","vertexBuffer","WebGLRenderer","onContextChange","gl","createBuffer","indexBuffer","bindBuffer","ELEMENT_ARRAY_BUFFER","bufferData","STATIC_DRAW","ARRAY_BUFFER","DYNAMIC_DRAW","light","flush","index","worldTransform","b","c","d","tx","ty","roundPixels","shader","bufferSubData","view","subarray","nextShader","batchSize","start","currentShader","renderBatch","shaders","id","setShader","currentRenderTarget","toArray","width","syncUniforms","activateTexture","TEXTURE0","startIndex","drawElements","TRIANGLES","UNSIGNED_SHORT","drawCount","vertexAttribPointer","FLOAT","destroy","deleteBuffer",8,"options","_lightAmbientColor","ambientColor","ambientIntensity","_doWebGLRender","assign","_initContext","RenderTarget","resolution","outputRenderTarget","renderTarget","activate","object","setRenderTarget","_renderLights","_updateLight"],"mappings":"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","file":"pixi-lights.min.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","module.exports = PIXI.lights = {\r\n//    LitSprite: require('./light_1/LitSprite'),\r\n//    LightingRenderer: require('./light_1/webgl/LightingRenderer')\r\n\r\n    Light:                  require('./light_2/lights/Light'),\r\n    LightShader:            require('./light_2/lights/LightShader'),\r\n\r\n    PointLight:             require('./light_2/lights/point/PointLight'),\r\n    PointLightShader:       require('./light_2/lights/point/PointLightShader'),\r\n\r\n    LightRenderer:          require('./light_2/renderers/LightRenderer'),\r\n    WebGLDeferredRenderer:  require('./light_2/renderers/WebGLDeferredRenderer')\r\n};\r\n\r\nrequire('./light_2/lightSpriteMixin');\r\n",null,"var tempTexture = null;\r\n\r\n /**\r\n * Renders the object using the WebGL renderer\r\n *\r\n * @param renderer {WebGLRenderer}\r\n * @private\r\n */\r\nPIXI.Sprite.prototype._renderWebGL = function (renderer)\r\n{\r\n    if (!this._originalTexture) {\r\n        this._originalTexture = this._texture;\r\n    }\r\n\r\n    if (renderer.renderingNormals && this.normalTexture)\r\n    {\r\n        this._texture = this.normalTexture;\r\n    }\r\n    else\r\n    {\r\n        this._texture = this._originalTexture;\r\n    }\r\n\r\n    renderer.setObjectRenderer(renderer.plugins.sprite);\r\n    renderer.plugins.sprite.render(this);\r\n};\r\n","/**\r\n * @class\r\n * @extends PIXI.DisplayObject\r\n * @memberof PIXI.lights\r\n *\r\n * @param [color=0xFFFFFF] {number} The color of the light.\r\n */\r\nfunction Light(color) {\r\n    PIXI.DisplayObject.call(this);\r\n\r\n    this._color = 0xFFFFFF;\r\n    this._colorRgba = [0, 0, 0, 1];\r\n\r\n    this.color = color !== undefined ? color : this._color;\r\n\r\n    this.height = 1;\r\n    \r\n    this.falloff = [0.4, 7.0, 40.0];\r\n\r\n    // hack around bug in interaction manager. It dies when processing raw DOs\r\n    this.children = [];\r\n\r\n    this.shaderName = null;\r\n}\r\n\r\nLight.prototype = Object.create(PIXI.DisplayObject.prototype);\r\nLight.prototype.constructor = Light;\r\nmodule.exports = Light;\r\n\r\nObject.defineProperties(Light.prototype, {\r\n    /**\r\n     * The color of lighting\r\n     *\r\n     * @member {number}\r\n     * @memberof Light#\r\n     */\r\n    color: {\r\n        get: function ()\r\n        {\r\n            return this._color;\r\n        },\r\n        set: function (val)\r\n        {\r\n            this._color = val;\r\n            PIXI.utils.hex2rgb(val, this._colorRgba);\r\n        }\r\n    }\r\n});\r\n\r\n/**\r\n * Renders the object using the WebGL renderer\r\n *\r\n * @param renderer {WebGLRenderer}\r\n * @private\r\n */\r\nLight.prototype.renderWebGL = function (renderer)\r\n{\r\n    // I actually don't want to interrupt the current batch, so don't set light as the current object renderer.\r\n    // light renderer works a bit differently in that ALL lights are in a single batch no matter what.\r\n\r\n    // renderer.setObjectRenderer(renderer.plugins.light);\r\n\r\n    renderer.plugins.lights.render(this);\r\n};\r\n","\r\n\r\n/**\r\n * @class\r\n * @extends PIXI.Shader\r\n * @memberof PIXI.lights\r\n * @param shaderManager {ShaderManager} The WebGL shader manager this shader works for.\r\n */\r\nfunction LightShader(shaderManager, vertexSrc, fragmentSrc, customUniforms, customAttributes) {\r\n    var uniforms = {\r\n        projectionMatrix:   { type: 'mat3', value: new Float32Array([1, 0, 0,\r\n                                                                     0, 1, 0,\r\n                                                                     0, 0, 1]) },\r\n        // textures from the previously rendered FBOs\r\n        uSampler:       { type: 'sampler2D', value: shaderManager.renderer.normalsRenderTarget },\r\n        uNormalSampler: { type: 'sampler2D', value: shaderManager.renderer.diffuseRenderTarget },\r\n\r\n        // size of the renderer viewport\r\n        uViewSize:      { type: '2f', value: [0, 0] },\r\n\r\n        // ambient lighting color, alpha channel used for intensity\r\n        uAmbientColor:  { type: '4f', value: shaderManager.renderer._lightAmbientColorRgba }\r\n    };\r\n\r\n    if (customUniforms)\r\n    {\r\n        for (var u in customUniforms)\r\n        {\r\n            uniforms[u] = customUniforms[u];\r\n        }\r\n    }\r\n\r\n    var attributes = {\r\n        aVertexPosition: 0\r\n    };\r\n\r\n    if (customAttributes)\r\n    {\r\n        for (var a in customAttributes)\r\n        {\r\n            attributes[a] = customAttributes[a];\r\n        }\r\n    }\r\n\r\n    PIXI.Shader.call(this, shaderManager, vertexSrc, fragmentSrc, uniforms, attributes);\r\n}\r\n\r\nLightShader.prototype = Object.create(PIXI.Shader.prototype);\r\nLightShader.prototype.constructor = LightShader;\r\nmodule.exports = LightShader;\r\n","var Light = require('../Light');\r\n\r\n/**\r\n * @class\r\n * @extends PIXI.lights.Light\r\n * @memberof PIXI.lights\r\n *\r\n * @param [color=0xFFFFFF] {number} The color of the light.\r\n * @param [intensity=1] {number} The intensity of the light.\r\n * @param [distance=0] {number} The distance the light reaches.\r\n * @param [decay=1] {number} The decay factor of the light. Physically correct lights should be 2.\r\n */\r\nfunction PointLight(color, intensity, distance, decay) {\r\n    Light.call(this, color);\r\n\r\n    this.shaderName = 'pointLightShader';\r\n}\r\n\r\nPointLight.prototype = Object.create(Light.prototype);\r\nPointLight.prototype.constructor = PointLight;\r\nmodule.exports = PointLight;\r\n","var LightShader = require('../LightShader');\r\n\r\n\r\n/**\r\n * @class\r\n * @extends PIXI.Shader\r\n * @memberof PIXI.lights\r\n * @param shaderManager {ShaderManager} The WebGL shader manager this shader works for.\r\n */\r\nfunction PointLightShader(shaderManager) {\r\n    LightShader.call(this,\r\n        shaderManager,\r\n        // vertex shader\r\n        \"#define GLSLIFY 1\\n\\nprecision lowp float;\\r\\n\\r\\nattribute vec2 aVertexPosition;\\r\\nattribute vec4 aLightColor;\\r\\nattribute vec3 aLightPosition;\\r\\nattribute vec3 aLightFalloff;\\r\\n\\r\\nuniform mat3 projectionMatrix;\\r\\n\\r\\nvarying vec4 vLightColor;\\r\\nvarying vec3 vLightPosition;\\r\\nvarying vec3 vLightFalloff;\\r\\n\\r\\nvoid main(void) {\\r\\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\\r\\n\\r\\n    vLightColor = aLightColor;\\r\\n    vLightPosition = aLightPosition;\\r\\n    vLightFalloff = aLightFalloff;\\r\\n}\\r\\n\",\r\n        // fragment shader\r\n        \"#define GLSLIFY 1\\n\\nprecision lowp float;\\r\\n\\r\\n// imports the common uniforms like samplers, and ambient color\\r\\nuniform sampler2D uSampler;\\r\\nuniform sampler2D uNormalSampler;\\r\\n\\r\\nuniform vec2 uViewSize;\\r\\n\\r\\nuniform vec4 uAmbientColor; // ambient color, alpha channel used for intensity.\\r\\n\\n\\r\\nvarying vec4 vLightColor;   // light color, alpha channel used for intensity.\\r\\nvarying vec3 vLightPosition;// light position normalized to view size (position / viewport)\\r\\nvarying vec3 vLightFalloff; // light falloff attenuation coefficients\\r\\n\\r\\nvoid main()\\r\\n{\\r\\n// sets diffuseColor and normalColor from their respective textures\\r\\nvec2 textureCoord = gl_FragCoord.xy / uViewSize;\\r\\n\\r\\nvec4 diffuseColor = texture2D(uSampler, textureCoord);\\r\\nvec4 normalColor = texture2D(uNormalSampler, textureCoord);\\r\\n\\r\\n// if no normal color here, just discard\\r\\nif (normalColor.a == 0.0) discard;\\r\\n\\n\\r\\n    // the directional vector of the light\\r\\n    vec3 lightVector = vec3(vLightPosition.xy - textureCoord, vLightPosition.z);\\r\\n\\r\\n    // correct for aspect ratio\\r\\n    lightVector.x *= uViewSize.x / uViewSize.y;\\r\\n\\r\\n// does lambertian illumination calculations and sets \\\"finalColor\\\"\\r\\n// compute Distance\\r\\nfloat D = length(lightVector);\\r\\n\\r\\n// normalize vectors\\r\\nvec3 N = normalize(normalColor.xyz * 2.0 - 1.0);\\r\\nvec3 L = normalize(lightVector);\\r\\n\\r\\n// pre-multiply light color with intensity\\r\\n// then perform \\\"N dot L\\\" to determine our diffuse\\r\\nvec3 diffuse = (vLightColor.rgb * vLightColor.a) * max(dot(N, L), 0.0);\\r\\n\\r\\n// pre-multiply ambient color with intensity\\r\\nvec3 ambient = uAmbientColor.rgb * uAmbientColor.a;\\r\\n\\r\\n// calculate attenuation\\r\\nfloat attenuation = 1.0 / (vLightFalloff.x + (vLightFalloff.y * D) + (vLightFalloff.z * D * D));\\r\\n\\r\\n// calculate final intesity and color, then combine\\r\\nvec3 intensity = ambient + diffuse * attenuation;\\r\\nvec3 finalColor = diffuseColor.rgb * intensity;\\r\\n\\n\\r\\n    gl_FragColor = vec4(finalColor, diffuseColor.a);\\r\\n}\",\r\n        // custom uniforms\r\n        null,\r\n        // custom attributes\r\n        {\r\n            aLightColor: 0,\r\n            aLightPosition: 0,\r\n            aLightFalloff: 0\r\n        }\r\n    );\r\n}\r\n\r\nPointLightShader.prototype = Object.create(LightShader.prototype);\r\nPointLightShader.prototype.constructor = PointLightShader;\r\nmodule.exports = PointLightShader;\r\n\r\nPIXI.ShaderManager.registerPlugin('pointLightShader', PointLightShader);\r\n","/**\r\n *\r\n * @class\r\n * @private\r\n * @memberof PIXI.lights\r\n * @extends PIXI.ObjectRenderer\r\n * @param renderer {WebGLRenderer} The renderer this sprite batch works for.\r\n */\r\nfunction LightRenderer(renderer)\r\n{\r\n    PIXI.ObjectRenderer.call(this, renderer);\r\n\r\n    /**\r\n     * Number of values sent in the vertex buffer.\r\n     *\r\n     * To support:\r\n     *  attribute vec2 aVertexPosition;\r\n     *  attribute vec4 aLightColor;\r\n     *  attribute vec3 aLightPosition;\r\n     *  attribute vec3 aLightFalloff;\r\n     * We need 12 values.\r\n     *\r\n     * @member {number}\r\n     */\r\n    this.vertSize = 12;\r\n\r\n    /**\r\n     * The size of the vertex information in bytes.\r\n     *\r\n     * @member {number}\r\n     */\r\n    this.vertByteSize = this.vertSize * 4;\r\n\r\n    /**\r\n     * The number of lights this renderer can draw at a time.\r\n     *\r\n     * @member {number}\r\n     */\r\n    this.size = LightRenderer.MAX_LIGHTS;\r\n\r\n    // the total number of bytes in our batch\r\n    var numVerts = (this.size * 4) * this.vertByteSize;\r\n\r\n    // the total number of indices in our batch, there are 6 points per quad.\r\n    var numIndices = this.size * 6;\r\n\r\n    /**\r\n     * Holds the vertex data that will be sent to the vertex shader.\r\n     *\r\n     * @member {ArrayBuffer}\r\n     */\r\n    this.vertices = new ArrayBuffer(numVerts);\r\n\r\n    /**\r\n     * View on the vertices as a Float32Array for positions\r\n     *\r\n     * @member {Float32Array}\r\n     */\r\n    this.positions = new Float32Array(this.vertices);\r\n\r\n    /**\r\n     * View on the vertices as a Uint32Array for colors\r\n     *\r\n     * @member {Uint32Array}\r\n     */\r\n    this.colors = new Uint32Array(this.vertices);\r\n\r\n    /**\r\n     * Holds the indices of the geometry (quads) to draw.\r\n     *\r\n     * @member {Uint16Array}\r\n     */\r\n    this.indices = new Uint16Array(numIndices);\r\n\r\n    // fill the indices with the quads to draw\r\n    for (var i=0, j=0; i < numIndices; i += 6, j += 4)\r\n    {\r\n        this.indices[i + 0] = j + 0;\r\n        this.indices[i + 1] = j + 1;\r\n        this.indices[i + 2] = j + 2;\r\n        this.indices[i + 3] = j + 0;\r\n        this.indices[i + 4] = j + 2;\r\n        this.indices[i + 5] = j + 3;\r\n    }\r\n\r\n    /**\r\n     * The current size of the batch, each render() call adds to this number.\r\n     *\r\n     * @member {number}\r\n     */\r\n    this.currentBatchSize = 0;\r\n\r\n    /**\r\n     * The current lights in the batch.\r\n     *\r\n     * @member {Light[]}\r\n     */\r\n    this.lights = [];\r\n\r\n    /**\r\n     * The vertex GL buffer that will be uploaded to the GPU.\r\n     * \r\n     * @member {glBuffer}\r\n     */\r\n    this.vertexBuffer = null;\r\n\r\n    /**\r\n     * The index GL buffer that will be uploaded to the GPU.\r\n     * \r\n     * @member {glBuffer}\r\n     */\r\n    this.vertexBuffer = null;\r\n}\r\n\r\nLightRenderer.MAX_LIGHTS = 500;\r\n\r\nLightRenderer.prototype = Object.create(PIXI.ObjectRenderer.prototype);\r\nLightRenderer.prototype.constructor = LightRenderer;\r\nmodule.exports = LightRenderer;\r\n\r\nPIXI.WebGLRenderer.registerPlugin('lights', LightRenderer);\r\n\r\n/**\r\n * Sets up the renderer context and necessary buffers.\r\n *\r\n * @private\r\n * @param gl {WebGLRenderingContext} the current WebGL drawing context\r\n */\r\nLightRenderer.prototype.onContextChange = function ()\r\n{\r\n    var gl = this.renderer.gl;\r\n\r\n    // create a couple of buffers\r\n    this.vertexBuffer = gl.createBuffer();\r\n    this.indexBuffer = gl.createBuffer();\r\n\r\n    // upload the index data\r\n    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);\r\n    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this.indices, gl.STATIC_DRAW);\r\n\r\n    gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);\r\n    gl.bufferData(gl.ARRAY_BUFFER, this.vertices, gl.DYNAMIC_DRAW);\r\n};\r\n\r\n/**\r\n * Renders the light object.\r\n *\r\n * @param light {Light} The light to render.\r\n */\r\nLightRenderer.prototype.render = function (light)\r\n{\r\n    if (this.currentBatchSize >= this.size)\r\n    {\r\n        this.flush();\r\n    }\r\n\r\n    var index = this.currentBatchSize * this.vertByteSize;\r\n\r\n    var worldTransform = light.worldTransform;\r\n\r\n    var a = worldTransform.a;\r\n    var b = worldTransform.b;\r\n    var c = worldTransform.c;\r\n    var d = worldTransform.d;\r\n    var tx = worldTransform.tx;\r\n    var ty = worldTransform.ty;\r\n\r\n    var positions = this.positions;\r\n    var colors = this.colors;\r\n\r\n    if (this.renderer.roundPixels)\r\n    {\r\n        // xy\r\n        positions[index+0] = positions[index+12] = positions[index+24] = positions[index+36] = a + c + tx | 0;\r\n        positions[index+1] = positions[index+13] = positions[index+25] = positions[index+37] = d + b + ty | 0;\r\n    }\r\n    else\r\n    {\r\n        // xy\r\n        positions[index+0] = positions[index+12] = positions[index+24] = positions[index+36] = a + c + tx;\r\n        positions[index+1] = positions[index+13] = positions[index+25] = positions[index+37] = d + b + ty;\r\n    }\r\n\r\n    colors[index+2] = colors[index+14] = colors[index+26] = colors[index+38] = light._colorRgba[0];\r\n    colors[index+3] = colors[index+15] = colors[index+27] = colors[index+39] = light._colorRgba[1];\r\n    colors[index+4] = colors[index+16] = colors[index+28] = colors[index+40] = light._colorRgba[2];\r\n    colors[index+5] = colors[index+17] = colors[index+29] = colors[index+41] = light._colorRgba[3];\r\n\r\n    positions[index+6] = positions[index+18] = positions[index+30] = positions[index+42] = positions[index];\r\n    positions[index+7] = positions[index+19] = positions[index+31] = positions[index+43] = positions[index+1];\r\n    positions[index+8] = positions[index+20] = positions[index+32] = positions[index+44] = this.renderer.roundPixels ? (light.height | 0) : light.height;\r\n\r\n    positions[index+9 ] = positions[index+21] = positions[index+33] = positions[index+45] = light.falloff[0];\r\n    positions[index+10] = positions[index+22] = positions[index+34] = positions[index+46] = light.falloff[1];\r\n    positions[index+11] = positions[index+23] = positions[index+35] = positions[index+47] = light.falloff[2];\r\n\r\n    this.lights[this.currentBatchSize++] = light;\r\n};\r\n\r\n/**\r\n * Renders the content and empties the current batch.\r\n *\r\n */\r\nLightRenderer.prototype.flush = function ()\r\n{\r\n    // If the batch is length 0 then return as there is nothing to draw\r\n    if (this.currentBatchSize === 0)\r\n    {\r\n        return;\r\n    }\r\n\r\n    var gl = this.renderer.gl;\r\n    var shader;\r\n\r\n    // upload the verts to the buffer\r\n    if (this.currentBatchSize > (this.size * 0.5))\r\n    {\r\n        gl.bufferSubData(gl.ARRAY_BUFFER, 0, this.vertices);\r\n    }\r\n    else\r\n    {\r\n        var view = this.positions.subarray(0, this.currentBatchSize * this.vertByteSize);\r\n        gl.bufferSubData(gl.ARRAY_BUFFER, 0, view);\r\n    }\r\n\r\n    var nextShader;\r\n    var batchSize = 0;\r\n    var start = 0;\r\n\r\n    var currentShader = null;\r\n\r\n    var light;\r\n\r\n    for (var i = 0, j = this.currentBatchSize; i < j; ++i)\r\n    {\r\n        light = this.lights[i];\r\n\r\n        nextShader = light.shader || this.renderer.shaderManager.plugins[light.shaderName];\r\n\r\n        if (currentShader !== nextShader)\r\n        {\r\n            this.renderBatch(batchSize, start);\r\n\r\n            start = i;\r\n            batchSize = 0;\r\n\r\n            currentShader = nextShader;\r\n\r\n            shader = currentShader.shaders ? currentShader.shaders[gl.id] : currentShader;\r\n\r\n            this.renderer.shaderManager.setShader(shader);\r\n\r\n            // set some uniform values\r\n            shader.uniforms.projectionMatrix.value = this.renderer.currentRenderTarget.projectionMatrix.toArray(true);\r\n\r\n            shader.uniforms.uViewSize.value[0] = this.renderer.width;\r\n            shader.uniforms.uViewSize.value[1] = this.renderer.height;\r\n\r\n            shader.syncUniforms();\r\n\r\n            gl.activateTexture(gl.TEXTURE0);\r\n        }\r\n\r\n        batchSize++;\r\n    }\r\n\r\n    this.renderBatch(batchSize, start);\r\n\r\n    this.currentBatchSize = 0;\r\n};\r\n\r\n/**\r\n * Draws the currently batched lights.\r\n *\r\n * @private\r\n * @param texture {Texture}\r\n * @param size {number}\r\n * @param startIndex {number}\r\n */\r\nLightRenderer.prototype.renderBatch = function (size, startIndex)\r\n{\r\n    if (size === 0)\r\n    {\r\n        return;\r\n    }\r\n\r\n    var gl = this.renderer.gl;\r\n\r\n    gl.drawElements(gl.TRIANGLES, size * 6, gl.UNSIGNED_SHORT, startIndex * 6 * 2);\r\n\r\n    // increment the draw count\r\n    this.renderer.drawCount++;\r\n};\r\n\r\nLightRenderer.prototype.start = function () {\r\n    var gl = this.renderer.gl;\r\n\r\n    // bind the buffers\r\n    gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);\r\n    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);\r\n\r\n    // set the vertex attribute\r\n    gl.vertexAttribPointer(this.shader.attributes.aVertexPosition, 2, gl.FLOAT, false, this.vertByteSize, 0);\r\n};\r\n\r\n/**\r\n * Destroys the SpriteBatch.\r\n *\r\n */\r\nLightRenderer.prototype.destroy = function ()\r\n{\r\n    this.renderer.gl.deleteBuffer(this.vertexBuffer);\r\n    this.renderer.gl.deleteBuffer(this.indexBuffer);\r\n\r\n    this.renderer = null;\r\n\r\n    this.vertices = null;\r\n    this.positions = null;\r\n    this.indices = null;\r\n\r\n    this.vertexBuffer = null;\r\n    this.indexBuffer = null;\r\n\r\n    this.lights = null;\r\n};\r\n","/**\r\n * The WebGLDeferredRenderer draws the scene and all its content onto a webGL enabled canvas. This renderer\r\n * should be used for browsers that support webGL. This Render works by automatically managing webGLBatchs.\r\n * So no need for Sprite Batches or Sprite Clouds.\r\n * Don't forget to add the view to your DOM or you will not see anything :)\r\n *\r\n * @class\r\n * @memberof PIXI.lights\r\n * @extends PIXI.SystemRenderer\r\n * @param [width=0] {number} the width of the canvas view\r\n * @param [height=0] {number} the height of the canvas view\r\n * @param [options] {object} The optional renderer parameters\r\n * @param [options.view] {HTMLCanvasElement} the canvas to use as a view, optional\r\n * @param [options.transparent=false] {boolean} If the render view is transparent, default false\r\n * @param [options.autoResize=false] {boolean} If the render view is automatically resized, default false\r\n * @param [options.antialias=false] {boolean} sets antialias. If not available natively then FXAA antialiasing is used\r\n * @param [options.forceFXAA=false] {boolean} forces FXAA antialiasing to be used over native. FXAA is faster, but may not always lok as great\r\n * @param [options.resolution=1] {number} the resolution of the renderer retina would be 2\r\n * @param [options.clearBeforeRender=true] {boolean} This sets if the CanvasRenderer will clear the canvas or\r\n *      not before the new render pass.\r\n * @param [options.preserveDrawingBuffer=false] {boolean} enables drawing buffer preservation, enable this if\r\n *      you need to call toDataUrl on the webgl context.\r\n */\r\nfunction WebGLDeferredRenderer(width, height, options)\r\n{\r\n    options = options || {};\r\n\r\n    this._lightAmbientColor = 0x000000;\r\n    this._lightAmbientColorRgba = [0, 0, 0, 0];\r\n\r\n    this.ambientColor = options.ambientColor || this._lightAmbientColor;\r\n    this.ambientIntensity = options.ambientIntensity || this._lightAmbientColorRgba[3];\r\n\r\n    this.lights = [];\r\n\r\n    this.renderingNormals = false;\r\n\r\n    this._doWebGLRender = PIXI.WebGLRenderer.prototype.render;\r\n\r\n    PIXI.WebGLRenderer.call(this, width, height, options);\r\n}\r\n\r\nWebGLDeferredRenderer.prototype = Object.create(PIXI.WebGLRenderer.prototype);\r\nWebGLDeferredRenderer.prototype.constructor = WebGLDeferredRenderer;\r\nmodule.exports = WebGLDeferredRenderer;\r\n\r\nObject.defineProperties(WebGLDeferredRenderer.prototype, {\r\n    /**\r\n     * The color of ambient lighting\r\n     *\r\n     * @member {number}\r\n     * @memberof WebGLDeferredRenderer#\r\n     */\r\n    ambientColor: {\r\n        get: function ()\r\n        {\r\n            return this._lightAmbientColor;\r\n        },\r\n        set: function (val)\r\n        {\r\n            this._lightAmbientColor = val;\r\n            PIXI.utils.hex2rgb(val, this._lightAmbientColorRgba);\r\n        }\r\n    },\r\n    /**\r\n     * The intensity of ambient lighting\r\n     *\r\n     * @member {number}\r\n     * @memberof WebGLDeferredRenderer#\r\n     */\r\n    ambientIntensity: {\r\n        get: function ()\r\n        {\r\n            return this._lightAmbientColorRgba[3];\r\n        },\r\n        set: function (val)\r\n        {\r\n            this._lightAmbientColorRgba[3] = val;\r\n        }\r\n    }\r\n});\r\n\r\n/** @lends PIXI.DisplayObject# */\r\nObject.assign(WebGLDeferredRenderer.prototype, {\r\n    /**\r\n     * Initializes the context and necessary framebuffers.\r\n     */\r\n    _initContext: function ()\r\n    {\r\n        // first create our render targets.\r\n        this.diffuseRenderTarget = new PIXI.RenderTarget(this.gl, this.width, this.height, null, this.resolution, false);\r\n        this.normalsRenderTarget = new PIXI.RenderTarget(this.gl, this.width, this.height, null, this.resolution, false);\r\n\r\n        // call parent init\r\n        PIXI.WebGLRenderer.prototype._initContext.call(this);\r\n\r\n        this.outputRenderTarget = this.renderTarget;\r\n\r\n        // render targets bind when they get created, so we need to reset back to the default one.\r\n        this.renderTarget.activate();\r\n    },\r\n\r\n    render: function (object)\r\n    {\r\n        // render diffuse\r\n        this.renderingNormals = false;\r\n        this.renderTarget = this.diffuseRenderTarget;\r\n        this._doWebGLRender(object);\r\n\r\n        // render normals\r\n        this.renderingNormals = true;\r\n        this.renderTarget = this.normalsRenderTarget;\r\n        this._doWebGLRender(object);\r\n\r\n        // render lights\r\n        this.setRenderTarget(this.outputRenderTarget);\r\n        this.plugins.lights.flush();\r\n\r\n        // composite to viewport\r\n//        this._composite();\r\n    },\r\n\r\n    _renderLights: function () {\r\n        \r\n    },\r\n\r\n    _updateLight: function () {\r\n        \r\n    }\r\n});\r\n"],"sourceRoot":"./"}