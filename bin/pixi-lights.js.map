{"version":3,"sources":["node_modules/browserify/node_modules/browser-pack/_prelude.js","src/index","src/lightSpriteMixin.js","src/lights/Light.js","src/lights/LightShader.js","src/lights/point/PointLight.js","src/lights/point/PointLightShader.js","src/renderers/LightRenderer.js","src/renderers/WebGLDeferredRenderer.js"],"names":[],"mappings":"AAAA;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"pixi-lights.js","sourceRoot":"./","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","module.exports = PIXI.lights = {\r\n//    LitSprite: require('./light_1/LitSprite'),\r\n//    LightingRenderer: require('./light_1/webgl/LightingRenderer')\r\n\r\n    Light:                  require('./lights/Light'),\r\n    LightShader:            require('./lights/LightShader'),\r\n\r\n    PointLight:             require('./lights/point/PointLight'),\r\n    PointLightShader:       require('./lights/point/PointLightShader'),\r\n\r\n    LightRenderer:          require('./renderers/LightRenderer'),\r\n    WebGLDeferredRenderer:  require('./renderers/WebGLDeferredRenderer')\r\n};\r\n\r\nrequire('./lightSpriteMixin');\r\n","var tempTexture = null;\r\n\r\n /**\r\n * Renders the object using the WebGL renderer\r\n *\r\n * @param renderer {WebGLRenderer}\r\n * @private\r\n */\r\nPIXI.Sprite.prototype._renderWebGL = function (renderer)\r\n{\r\n    if (!this._originalTexture) {\r\n        this._originalTexture = this._texture;\r\n    }\r\n\r\n    if (renderer.renderingNormals && this.normalTexture)\r\n    {\r\n        this._texture = this.normalTexture;\r\n    }\r\n    else\r\n    {\r\n        this._texture = this._originalTexture;\r\n    }\r\n\r\n    renderer.setObjectRenderer(renderer.plugins.sprite);\r\n    renderer.plugins.sprite.render(this);\r\n};\r\n","/**\r\n * Excuse the mess, haven't cleaned this up yet!\r\n */\r\n\r\n\r\n\r\n/**\r\n * @class\r\n * @extends PIXI.DisplayObject\r\n * @memberof PIXI.lights\r\n *\r\n * @param [color=0xFFFFFF] {number} The color of the light.\r\n */\r\nfunction Light(color, vertices, indices) {\r\n    if (this.constructor === Light) {\r\n        throw new Error('Light is an abstract base and should not be created directly!');\r\n    }\r\n\r\n    PIXI.DisplayObject.call(this);\r\n\r\n    /**\r\n     * An array of vertices\r\n     *\r\n     * @member {Float32Array}\r\n     */\r\n    this.vertices = vertices || new Float32Array([0,   0,\r\n                                                  1024, 0,\r\n                                                  1024, 512,\r\n                                                  0,   512]);\r\n\r\n    /**\r\n     * An array containing the indices of the vertices\r\n     *\r\n     * @member {Uint16Array}\r\n     */\r\n    this.indices = new Uint16Array([0,1,2, 0,2,3]);\r\n\r\n    /**\r\n     * The blend mode to be applied to the light.\r\n     *\r\n     * @member {number}\r\n     * @default CONST.BLEND_MODES.ADD;\r\n     */\r\n    this.blendMode = PIXI.BLEND_MODES.ADD;\r\n\r\n    this._vertexBuffer = null;\r\n    this._indexBuffer = null;\r\n\r\n    this.needsUpdate = true;\r\n\r\n    // light stuff...\r\n\r\n    this._color = 0xFFFFFF;\r\n    this._colorRgba = [1, 1, 1, 1];\r\n\r\n    if (color || color === 0) {\r\n        this.color = color;\r\n    }\r\n\r\n    this.height = 0.075;\r\n\r\n    this.falloff = [0.2, 5, 20];\r\n\r\n    // hack around bug in interaction manager. It dies when processing raw DOs\r\n//    this.children = [];\r\n\r\n    this.shaderName = null;\r\n}\r\n\r\nLight.prototype = Object.create(PIXI.DisplayObject.prototype);\r\nLight.prototype.constructor = Light;\r\nmodule.exports = Light;\r\n\r\nObject.defineProperties(Light.prototype, {\r\n    /**\r\n     * The color of lighting\r\n     *\r\n     * @member {number}\r\n     * @memberof Light#\r\n     */\r\n    color: {\r\n        get: function ()\r\n        {\r\n            return this._color;\r\n        },\r\n        set: function (val)\r\n        {\r\n            this._color = val;\r\n            PIXI.utils.hex2rgb(val, this._colorRgba);\r\n        }\r\n    }\r\n});\r\n\r\n/**\r\n * Renders the object using the WebGL renderer\r\n *\r\n * @param renderer {WebGLRenderer}\r\n * @private\r\n */\r\n//Light.prototype.renderWebGL = function (renderer)\r\n//{\r\n//    // I actually don't want to interrupt the current batch, so don't set light as the current object renderer.\r\n//    // light renderer works a bit differently in that ALL lights are in a single batch no matter what.\r\n//\r\n//    // renderer.setObjectRenderer(renderer.plugins.lights);\r\n//\r\n////    if (renderer.renderingNormals) {\r\n////        renderer.plugins.lights.render(this);\r\n//        renderer.lights.push(this);\r\n////    }\r\n//};\r\n\r\nLight.prototype.renderWebGL = function (renderer)\r\n{\r\n    // add lights to their renderer on the normals pass\r\n    if (!renderer.renderingNormals) {\r\n        return;\r\n    }\r\n\r\n//    renderer.setObjectRenderer(renderer.plugins.lights);\r\n    renderer.plugins.lights.render(this);\r\n};\r\n\r\nLight.prototype.destroy = function ()\r\n{\r\n    PIXI.DisplayObject.prototype.destroy.call(this);\r\n\r\n    // TODO: Destroy buffers!\r\n}\r\n","\r\n\r\n/**\r\n * @class\r\n * @extends PIXI.Shader\r\n * @memberof PIXI.lights\r\n * @param shaderManager {ShaderManager} The WebGL shader manager this shader works for.\r\n */\r\nfunction LightShader(shaderManager, vertexSrc, fragmentSrc, customUniforms, customAttributes) {\r\n    var uniforms = {\r\n        alpha:              { type: '1f', value: 0 },\r\n        translationMatrix:  { type: 'mat3', value: new Float32Array(9) },\r\n        projectionMatrix:   { type: 'mat3', value: new Float32Array(9) },\r\n\r\n        // textures from the previously rendered FBOs\r\n        uSampler:       { type: 'sampler2D', value: null },\r\n        uNormalSampler: { type: 'sampler2D', value: null },\r\n\r\n        // size of the renderer viewport\r\n        uViewSize:      { type: '2f', value: new Float32Array(2) },\r\n\r\n        // ambient lighting color, alpha channel used for intensity\r\n        uAmbientColor:  { type: '4f', value: new Float32Array(4) },\r\n\r\n        // light color, alpha channel used for intensity.\r\n        uLightColor:    { type: '4f', value: new Float32Array([1, 1, 1, 1]) },\r\n\r\n        // light falloff attenuation coefficients\r\n        uLightFalloff:  { type: '3f', value: new Float32Array([0, 0, 0]) }\r\n    };\r\n\r\n    if (customUniforms)\r\n    {\r\n        for (var u in customUniforms)\r\n        {\r\n            uniforms[u] = customUniforms[u];\r\n        }\r\n    }\r\n\r\n    var attributes = {\r\n        aVertexPosition: 0\r\n    };\r\n\r\n    if (customAttributes)\r\n    {\r\n        for (var a in customAttributes)\r\n        {\r\n            attributes[a] = customAttributes[a];\r\n        }\r\n    }\r\n\r\n    PIXI.Shader.call(this, shaderManager, vertexSrc || LightShader.defaultVertexSrc, fragmentSrc || LightShader.defaultFragmentSrc, uniforms, attributes);\r\n}\r\n\r\nLightShader.prototype = Object.create(PIXI.Shader.prototype);\r\nLightShader.prototype.constructor = LightShader;\r\nmodule.exports = LightShader;\r\n\r\nLightShader.defaultVertexSrc = \"#define GLSLIFY 1\\n\\nprecision lowp float;\\r\\n\\r\\nattribute vec2 aVertexPosition;\\r\\n\\r\\nuniform mat3 translationMatrix;\\r\\nuniform mat3 projectionMatrix;\\r\\n\\r\\nvoid main(void) {\\r\\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\\r\\n}\\r\\n\";\r\nLightShader.defaultFragmentSrc = \"#define GLSLIFY 1\\n\\nprecision lowp float;\\r\\n\\r\\nuniform sampler2D uSampler;\\r\\nuniform sampler2D uNormalSampler;\\r\\n\\r\\nuniform mat3 translationMatrix;\\r\\n\\r\\nuniform float alpha;\\r\\n\\r\\nuniform vec2 uViewSize;\\r\\n\\r\\nuniform vec4 uAmbientColor; // ambient color, alpha channel used for intensity.\\r\\n\\r\\nuniform vec2 uLightPosition;// light position, normalized to viewport.\\r\\nuniform vec4 uLightColor;   // light color, alpha channel used for intensity.\\r\\nuniform vec3 uLightFalloff; // light falloff attenuation coefficients.\\r\\n\\n\\r\\nvoid main(void){\\r\\nvec2 texCoord = gl_FragCoord.xy / uViewSize;\\r\\ntexCoord.y = 1.0 - texCoord.y; // FBOs are flipped.\\r\\n\\r\\nvec4 diffuseColor = texture2D(uSampler, texCoord);\\r\\nvec4 normalColor = texture2D(uNormalSampler, texCoord);\\r\\n\\r\\n// if no normal color here, just discard\\r\\nif (normalColor.a == 0.0) discard;\\r\\n\\n\\r\\n    // this shader should always be overriden by a specific light type...\\r\\n    gl_FragColor = vec4(mix(diffuseColor.rgb, normalColor.rgb, 0.5), diffuseColor.a);\\r\\n}\\r\\n\";\r\n","var Light = require('../Light');\r\n\r\n/**\r\n * @class\r\n * @extends PIXI.lights.Light\r\n * @memberof PIXI.lights\r\n *\r\n * @param [color=0xFFFFFF] {number} The color of the light.\r\n * @param [intensity=1] {number} The intensity of the light.\r\n * @param [distance=0] {number} The distance the light reaches.\r\n * @param [decay=1] {number} The decay factor of the light. Physically correct lights should be 2.\r\n */\r\nfunction PointLight(color, intensity, distance, decay) {\r\n    Light.call(this, color);\r\n\r\n    this.shaderName = 'pointLightShader';\r\n}\r\n\r\nPointLight.prototype = Object.create(Light.prototype);\r\nPointLight.prototype.constructor = PointLight;\r\nmodule.exports = PointLight;\r\n","var LightShader = require('../LightShader');\r\n\r\n\r\n/**\r\n * @class\r\n * @extends PIXI.Shader\r\n * @memberof PIXI.lights\r\n * @param shaderManager {ShaderManager} The WebGL shader manager this shader works for.\r\n */\r\nfunction PointLightShader(shaderManager) {\r\n    LightShader.call(this,\r\n        shaderManager,\r\n        // vertex shader\r\n        null,\r\n        // fragment shader\r\n        \"#define GLSLIFY 1\\n\\nprecision lowp float;\\r\\n\\r\\n// imports the common uniforms like samplers, and ambient color\\r\\nuniform sampler2D uSampler;\\r\\nuniform sampler2D uNormalSampler;\\r\\n\\r\\nuniform mat3 translationMatrix;\\r\\n\\r\\nuniform float alpha;\\r\\n\\r\\nuniform vec2 uViewSize;\\r\\n\\r\\nuniform vec4 uAmbientColor; // ambient color, alpha channel used for intensity.\\r\\n\\r\\nuniform vec2 uLightPosition;// light position, normalized to viewport.\\r\\nuniform vec4 uLightColor;   // light color, alpha channel used for intensity.\\r\\nuniform vec3 uLightFalloff; // light falloff attenuation coefficients.\\r\\n\\n\\r\\nuniform float uLightHeight;\\r\\n\\r\\nvoid main()\\r\\n{\\r\\n// sets diffuseColor and normalColor from their respective textures\\r\\nvec2 texCoord = gl_FragCoord.xy / uViewSize;\\r\\ntexCoord.y = 1.0 - texCoord.y; // FBOs are flipped.\\r\\n\\r\\nvec4 diffuseColor = texture2D(uSampler, texCoord);\\r\\nvec4 normalColor = texture2D(uNormalSampler, texCoord);\\r\\n\\r\\n// if no normal color here, just discard\\r\\nif (normalColor.a == 0.0) discard;\\r\\n\\n\\r\\n    vec2 lightPosition = translationMatrix[2].xy / uViewSize;\\r\\n\\r\\n    // the directional vector of the light\\r\\n    vec3 lightVector = vec3(lightPosition - texCoord, uLightHeight);\\r\\n\\r\\n    // correct for aspect ratio\\r\\n    lightVector.x *= uViewSize.x / uViewSize.y;\\r\\n\\r\\n// does lambertian illumination calculations and sets \\\"finalColor\\\"\\r\\n// compute Distance\\r\\nfloat D = length(lightVector);\\r\\n\\r\\n// normalize vectors\\r\\nvec3 N = normalize(normalColor.xyz * 2.0 - 1.0);\\r\\nvec3 L = normalize(lightVector);\\r\\n\\r\\n// pre-multiply light color with intensity\\r\\n// then perform \\\"N dot L\\\" to determine our diffuse\\r\\nvec3 diffuse = (uLightColor.rgb * uLightColor.a) * max(dot(N, L), 0.0);\\r\\n\\r\\n// pre-multiply ambient color with intensity\\r\\nvec3 ambient = uAmbientColor.rgb * uAmbientColor.a;\\r\\n\\r\\n// calculate attenuation\\r\\nfloat attenuation = 1.0 / (uLightFalloff.x + (uLightFalloff.y * D) + (uLightFalloff.z * D * D));\\r\\n\\r\\n// calculate final intesity and color, then combine\\r\\nvec3 intensity = ambient + diffuse * attenuation;\\r\\nvec3 finalColor = diffuseColor.rgb * intensity;\\r\\n\\n\\r\\n    gl_FragColor = vec4(finalColor, diffuseColor.a);\\r\\n}\",\r\n        // custom uniforms\r\n        {\r\n            // height of the light above the viewport\r\n            uLightHeight: { type: '1f', value: 0.075 }\r\n        }\r\n    );\r\n}\r\n\r\nPointLightShader.prototype = Object.create(LightShader.prototype);\r\nPointLightShader.prototype.constructor = PointLightShader;\r\nmodule.exports = PointLightShader;\r\n\r\nPIXI.ShaderManager.registerPlugin('pointLightShader', PointLightShader);\r\n","/**\r\n *\r\n * @class\r\n * @private\r\n * @memberof PIXI.lights\r\n * @extends PIXI.ObjectRenderer\r\n * @param renderer {WebGLRenderer} The renderer this sprite batch works for.\r\n */\r\nfunction LightRenderer(renderer)\r\n{\r\n    PIXI.ObjectRenderer.call(this, renderer);\r\n\r\n    // the total number of indices in our batch, there are 6 points per quad.\r\n    var numIndices = LightRenderer.MAX_LIGHTS * 6;\r\n\r\n    /**\r\n     * Holds the indices\r\n     *\r\n     * @member {Uint16Array}\r\n     */\r\n    this.indices = new Uint16Array(numIndices);\r\n\r\n    //TODO this could be a single buffer shared amongst all renderers as we reuse this set up in most renderers\r\n    for (var i = 0, j = 0; i < numIndices; i += 6, j += 4)\r\n    {\r\n        this.indices[i + 0] = j + 0;\r\n        this.indices[i + 1] = j + 1;\r\n        this.indices[i + 2] = j + 2;\r\n        this.indices[i + 3] = j + 0;\r\n        this.indices[i + 4] = j + 2;\r\n        this.indices[i + 5] = j + 3;\r\n    }\r\n\r\n    /**\r\n     * The current size of the batch, each render() call adds to this number.\r\n     *\r\n     * @member {number}\r\n     */\r\n    this.currentBatchSize = 0;\r\n\r\n    /**\r\n     * The current lights in the batch.\r\n     *\r\n     * @member {Light[]}\r\n     */\r\n    this.lights = [];\r\n}\r\n\r\nLightRenderer.MAX_LIGHTS = 500;\r\n\r\nLightRenderer.prototype = Object.create(PIXI.ObjectRenderer.prototype);\r\nLightRenderer.prototype.constructor = LightRenderer;\r\nmodule.exports = LightRenderer;\r\n\r\nPIXI.WebGLRenderer.registerPlugin('lights', LightRenderer);\r\n\r\n/**\r\n * Renders the light object.\r\n *\r\n * @param light {Light} the light to render\r\n */\r\nLightRenderer.prototype.render = function (light)\r\n{\r\n    this.lights[this.currentBatchSize++] = light;\r\n};\r\n\r\nLightRenderer.prototype.flush = function ()\r\n{\r\n    var renderer = this.renderer,\r\n        gl = renderer.gl,\r\n        diffuseTexture = renderer.diffuseTexture,\r\n        normalsTexture = renderer.normalsTexture,\r\n        lastShader = null;\r\n\r\n    for (var i = 0; i < this.currentBatchSize; ++i)\r\n    {\r\n        var light = this.lights[i],\r\n            shader = light.shader || this.renderer.shaderManager.plugins[light.shaderName];\r\n\r\n        if (!light._vertexBuffer)\r\n        {\r\n            this._initWebGL(light);\r\n        }\r\n\r\n        // set shader if needed\r\n        if (shader !== lastShader) {\r\n            lastShader = shader;\r\n            renderer.shaderManager.setShader(shader);\r\n        }\r\n\r\n        renderer.blendModeManager.setBlendMode(light.blendMode);\r\n\r\n        // set uniforms, can do some optimizations here.\r\n        light.worldTransform.toArray(true, shader.uniforms.translationMatrix.value);\r\n        renderer.currentRenderTarget.projectionMatrix.toArray(true, shader.uniforms.projectionMatrix.value);\r\n\r\n        shader.uniforms.alpha.value = light.worldAlpha;\r\n\r\n        shader.uniforms.uViewSize.value[0] = renderer.width;\r\n        shader.uniforms.uViewSize.value[1] = renderer.height;\r\n\r\n        shader.uniforms.uAmbientColor.value[0] = renderer._lightAmbientColorRgba[0];\r\n        shader.uniforms.uAmbientColor.value[1] = renderer._lightAmbientColorRgba[1];\r\n        shader.uniforms.uAmbientColor.value[2] = renderer._lightAmbientColorRgba[2];\r\n        shader.uniforms.uAmbientColor.value[3] = renderer._lightAmbientColorRgba[3];\r\n\r\n        shader.uniforms.uLightColor.value[0] = light._colorRgba[0];\r\n        shader.uniforms.uLightColor.value[1] = light._colorRgba[1];\r\n        shader.uniforms.uLightColor.value[2] = light._colorRgba[2];\r\n        shader.uniforms.uLightColor.value[3] = light._colorRgba[3];\r\n\r\n        shader.uniforms.uLightFalloff.value[0] = light.falloff[0];\r\n        shader.uniforms.uLightFalloff.value[1] = light.falloff[1];\r\n        shader.uniforms.uLightFalloff.value[2] = light.falloff[2];\r\n\r\n        shader.syncUniforms();\r\n\r\n        // have to set these manually due to the way pixi base shader makes assumptions about texture units\r\n        gl.uniform1i(shader.uniforms.uSampler._location, 0);\r\n        gl.uniform1i(shader.uniforms.uNormalSampler._location, 1);\r\n\r\n        if (!light.needsUpdate)\r\n        {\r\n            // update vertex data\r\n            gl.bindBuffer(gl.ARRAY_BUFFER, light._vertexBuffer);\r\n            gl.bufferSubData(gl.ARRAY_BUFFER, 0, light.vertices);\r\n            gl.vertexAttribPointer(shader.attributes.aVertexPosition, 2, gl.FLOAT, false, 0, 0);\r\n\r\n            // bind diffuse texture\r\n            gl.activeTexture(gl.TEXTURE0);\r\n            gl.bindTexture(gl.TEXTURE_2D, diffuseTexture.baseTexture._glTextures[gl.id]);\r\n\r\n            // bind normal texture\r\n            gl.activeTexture(gl.TEXTURE1);\r\n            gl.bindTexture(gl.TEXTURE_2D, normalsTexture.baseTexture._glTextures[gl.id]);\r\n\r\n            // update indices\r\n            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, light._indexBuffer);\r\n            gl.bufferSubData(gl.ELEMENT_ARRAY_BUFFER, 0, light.indices);\r\n        }\r\n        else\r\n        {\r\n            light.needsUpdate = false;\r\n\r\n            // upload vertex data\r\n            gl.bindBuffer(gl.ARRAY_BUFFER, light._vertexBuffer);\r\n            gl.bufferData(gl.ARRAY_BUFFER, light.vertices, gl.STATIC_DRAW);\r\n            gl.vertexAttribPointer(shader.attributes.aVertexPosition, 2, gl.FLOAT, false, 0, 0);\r\n\r\n            // bind diffuse texture\r\n            gl.activeTexture(gl.TEXTURE0);\r\n            gl.bindTexture(gl.TEXTURE_2D, diffuseTexture.baseTexture._glTextures[gl.id]);\r\n\r\n            // bind normal texture\r\n            gl.activeTexture(gl.TEXTURE1);\r\n            gl.bindTexture(gl.TEXTURE_2D, normalsTexture.baseTexture._glTextures[gl.id]);\r\n\r\n            // static upload of index buffer\r\n            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, light._indexBuffer);\r\n            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, light.indices, gl.STATIC_DRAW);\r\n        }\r\n\r\n        gl.drawElements(gl.TRIANGLES, light.indices.length, gl.UNSIGNED_SHORT, 0);\r\n    }\r\n\r\n    this.currentBatchSize = 0;\r\n};\r\n\r\n/**\r\n * Prepares all the buffers to render this light.\r\n *\r\n * @param light {Light} The light object to prepare for rendering.\r\n */\r\nLightRenderer.prototype._initWebGL = function (light)\r\n{\r\n    var gl = this.renderer.gl;\r\n\r\n    // create the buffers\r\n    light._vertexBuffer = gl.createBuffer();\r\n    light._indexBuffer = gl.createBuffer();\r\n\r\n    gl.bindBuffer(gl.ARRAY_BUFFER, light._vertexBuffer);\r\n    gl.bufferData(gl.ARRAY_BUFFER, light.vertices, gl.DYNAMIC_DRAW);\r\n\r\n    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, light._indexBuffer);\r\n    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, light.indices, gl.STATIC_DRAW);\r\n};\r\n\r\nLightRenderer.prototype.destroy = function ()\r\n{\r\n    \r\n};\r\n","/**\r\n * The WebGLDeferredRenderer draws the scene and all its content onto a webGL enabled canvas. This renderer\r\n * should be used for browsers that support webGL. This Render works by automatically managing webGLBatchs.\r\n * So no need for Sprite Batches or Sprite Clouds.\r\n * Don't forget to add the view to your DOM or you will not see anything :)\r\n *\r\n * @class\r\n * @memberof PIXI.lights\r\n * @extends PIXI.SystemRenderer\r\n * @param [width=0] {number} the width of the canvas view\r\n * @param [height=0] {number} the height of the canvas view\r\n * @param [options] {object} The optional renderer parameters\r\n * @param [options.view] {HTMLCanvasElement} the canvas to use as a view, optional\r\n * @param [options.transparent=false] {boolean} If the render view is transparent, default false\r\n * @param [options.autoResize=false] {boolean} If the render view is automatically resized, default false\r\n * @param [options.antialias=false] {boolean} sets antialias. If not available natively then FXAA antialiasing is used\r\n * @param [options.forceFXAA=false] {boolean} forces FXAA antialiasing to be used over native. FXAA is faster, but may not always lok as great\r\n * @param [options.resolution=1] {number} the resolution of the renderer retina would be 2\r\n * @param [options.clearBeforeRender=true] {boolean} This sets if the CanvasRenderer will clear the canvas or\r\n *      not before the new render pass.\r\n * @param [options.preserveDrawingBuffer=false] {boolean} enables drawing buffer preservation, enable this if\r\n *      you need to call toDataUrl on the webgl context.\r\n */\r\nfunction WebGLDeferredRenderer(width, height, options)\r\n{\r\n    options = options || {};\r\n\r\n    this._lightAmbientColor = 0x000000;\r\n    this._lightAmbientColorRgba = [0, 0, 0, 0];\r\n\r\n    this.ambientColor = options.ambientColor || this._lightAmbientColor;\r\n    this.ambientIntensity = options.ambientIntensity || this._lightAmbientColorRgba[3];\r\n\r\n    this.renderingNormals = false;\r\n\r\n    PIXI.WebGLRenderer.call(this, width, height, options);\r\n}\r\n\r\nWebGLDeferredRenderer.prototype = Object.create(PIXI.WebGLRenderer.prototype);\r\nWebGLDeferredRenderer.prototype.constructor = WebGLDeferredRenderer;\r\nmodule.exports = WebGLDeferredRenderer;\r\n\r\nObject.defineProperties(WebGLDeferredRenderer.prototype, {\r\n    /**\r\n     * The color of ambient lighting\r\n     *\r\n     * @member {number}\r\n     * @memberof WebGLDeferredRenderer#\r\n     */\r\n    ambientColor: {\r\n        get: function ()\r\n        {\r\n            return this._lightAmbientColor;\r\n        },\r\n        set: function (val)\r\n        {\r\n            this._lightAmbientColor = val;\r\n            PIXI.utils.hex2rgb(val, this._lightAmbientColorRgba);\r\n        }\r\n    },\r\n    /**\r\n     * The intensity of ambient lighting\r\n     *\r\n     * @member {number}\r\n     * @memberof WebGLDeferredRenderer#\r\n     */\r\n    ambientIntensity: {\r\n        get: function ()\r\n        {\r\n            return this._lightAmbientColorRgba[3];\r\n        },\r\n        set: function (val)\r\n        {\r\n            this._lightAmbientColorRgba[3] = val;\r\n        }\r\n    }\r\n});\r\n\r\n/** @lends PIXI.DisplayObject# */\r\nObject.assign(WebGLDeferredRenderer.prototype, {\r\n    /**\r\n     * Initializes the context and necessary framebuffers.\r\n     */\r\n    _initContext: function ()\r\n    {\r\n        // call parent init\r\n        PIXI.WebGLRenderer.prototype._initContext.call(this);\r\n\r\n        // first create our render targets.\r\n        this.diffuseTexture = new PIXI.RenderTexture(this, this.width, this.height, null, this.resolution);\r\n        this.normalsTexture = new PIXI.RenderTexture(this, this.width, this.height, null, this.resolution);\r\n    },\r\n\r\n    render: function (object)\r\n    {\r\n        // render diffuse\r\n        this.renderingNormals = false;\r\n        this.diffuseTexture.render(object);\r\n\r\n        // render normals\r\n        this.renderingNormals = true;\r\n        this.normalsTexture.render(object);\r\n\r\n        // render lights\r\n        this.setRenderTarget(this.renderTarget);\r\n        this.setObjectRenderer(this.plugins.lights);\r\n        this.plugins.lights.flush();\r\n    }\r\n});\r\n"]}