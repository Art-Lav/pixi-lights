{"version":3,"sources":["node_modules/browserify/node_modules/browser-pack/_prelude.js","src/index","src/lightSpriteMixin.js","src/lights/WireframeShader.js","src/lights/ambientLight/AmbientLight.js","src/lights/ambientLight/AmbientLightShader.js","src/lights/light/Light.js","src/lights/light/LightShader.js","src/lights/pointLight/PointLight.js","src/lights/pointLight/PointLightShader.js","src/renderers/LightRenderer.js","src/renderers/WebGLDeferredRenderer.js","src/shapeMeshMixin.js"],"names":[],"mappings":"AAAA;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"pixi-lights.js","sourceRoot":"./","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","module.exports = PIXI.lights = {\r\n//    LitSprite: require('./light_1/LitSprite'),\r\n//    LightingRenderer: require('./light_1/webgl/LightingRenderer')\r\n\r\n    Light:                  require('./lights/light/Light'),\r\n    LightShader:            require('./lights/light/LightShader'),\r\n\r\n    AmbientLight:           require('./lights/ambientLight/AmbientLight'),\r\n    AmbientLightShader:     require('./lights/ambientLight/AmbientLightShader'),\r\n\r\n    PointLight:             require('./lights/pointLight/PointLight'),\r\n    PointLightShader:       require('./lights/pointLight/PointLightShader'),\r\n\r\n    LightRenderer:          require('./renderers/LightRenderer'),\r\n    WebGLDeferredRenderer:  require('./renderers/WebGLDeferredRenderer'),\r\n\r\n    WireframeShader:        require('./lights/WireframeShader')\r\n};\r\n\r\nrequire('./lightSpriteMixin');\r\nrequire('./shapeMeshMixin');\r\n","var tempTexture = null;\r\n\r\n /**\r\n * Renders the object using the WebGL renderer\r\n *\r\n * @param renderer {WebGLRenderer}\r\n * @private\r\n */\r\nPIXI.Sprite.prototype._renderWebGL = function (renderer)\r\n{\r\n    if (!this._originalTexture) {\r\n        this._originalTexture = this._texture;\r\n    }\r\n\r\n    if (renderer.renderingNormals && this.normalTexture)\r\n    {\r\n        this._texture = this.normalTexture;\r\n    }\r\n    else\r\n    {\r\n        this._texture = this._originalTexture;\r\n    }\r\n\r\n    renderer.setObjectRenderer(renderer.plugins.sprite);\r\n    renderer.plugins.sprite.render(this);\r\n};\r\n","\r\n\r\n/**\r\n * @class\r\n * @extends PIXI.Shader\r\n * @memberof PIXI.lights\r\n * @param shaderManager {ShaderManager} The WebGL shader manager this shader works for.\r\n */\r\nfunction WireframeShader(shaderManager) {\r\n    PIXI.Shader.call(this,\r\n        shaderManager,\r\n        // vertex shader\r\n        [\r\n            'precision lowp float;',\r\n\r\n            'attribute vec2 aVertexPosition;',\r\n\r\n            'uniform mat3 projectionMatrix;',\r\n\r\n            'void main(void) {',\r\n            '    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);',\r\n            '}'\r\n        ].join('\\n'),\r\n        // fragment shader\r\n        [\r\n            'void main() {',\r\n            '    gl_FragColor = vec4(0, 0, 0, 1);',\r\n            '}'\r\n        ].join('\\n'),\r\n        // uniforms\r\n        {\r\n            translationMatrix:  { type: 'mat3', value: new Float32Array(9) },\r\n            projectionMatrix:   { type: 'mat3', value: new Float32Array(9) }\r\n        },\r\n        // attributes\r\n        {\r\n            aVertexPosition: 0\r\n        }\r\n    );\r\n}\r\n\r\nWireframeShader.prototype = Object.create(PIXI.Shader.prototype);\r\nWireframeShader.prototype.constructor = WireframeShader;\r\nmodule.exports = WireframeShader;\r\n\r\nPIXI.ShaderManager.registerPlugin('wireframeShader', WireframeShader);\r\n","var Light = require('../light/Light');\r\n\r\n/**\r\n * @class\r\n * @extends PIXI.lights.Light\r\n * @memberof PIXI.lights\r\n *\r\n * @param [color=0xFFFFFF] {number} The color of the light.\r\n * @param [brightness=0.5] {number} The brightness of the light.\r\n */\r\nfunction AmbientLight(color, brightness) {\r\n    // ambient light is drawn using a full-screen quad\r\n    Light.call(this, color, brightness);\r\n\r\n    this.shaderName = 'ambientLightShader';\r\n}\r\n\r\nAmbientLight.prototype = Object.create(Light.prototype);\r\nAmbientLight.prototype.constructor = AmbientLight;\r\nmodule.exports = AmbientLight;\r\n\r\nAmbientLight.prototype.renderWebGL = function (renderer)\r\n{\r\n    // add lights to their renderer on the normals pass\r\n    if (!renderer.renderingNormals) {\r\n        return;\r\n    }\r\n\r\n    // I actually don't want to interrupt the current batch, so don't set light as the current object renderer.\r\n    // Light renderer works a bit differently in that lights are draw individually on flush (called by WebGLDeferredRenderer).\r\n    //renderer.setObjectRenderer(renderer.plugins.lights);\r\n\r\n    renderer.plugins.lights.render(this);\r\n};\r\n","var LightShader = require('../light/LightShader');\r\n\r\n\r\n/**\r\n * @class\r\n * @extends PIXI.Shader\r\n * @memberof PIXI.lights\r\n * @param shaderManager {ShaderManager} The WebGL shader manager this shader works for.\r\n */\r\nfunction AmbientLightShader(shaderManager) {\r\n    LightShader.call(this,\r\n        shaderManager,\r\n        // vertex shader\r\n        null,\r\n        // fragment shader\r\n        \"#define GLSLIFY 1\\n\\nprecision lowp float;\\r\\n\\r\\nuniform sampler2D uSampler;\\r\\nuniform sampler2D uNormalSampler;\\r\\n\\r\\nuniform mat3 translationMatrix;\\r\\n\\r\\nuniform vec2 uViewSize;\\r\\n\\r\\nuniform vec4 uAmbientColor; // ambient color, alpha channel used for intensity.\\r\\n\\r\\nuniform vec4 uLightColor;   // light color, alpha channel used for intensity.\\r\\nuniform vec3 uLightFalloff; // light attenuation coefficients (constant, linear, quadratic)\\r\\nuniform float uLightHeight; // light height above the viewport\\r\\n\\n\\r\\nvoid main(void)\\r\\n{\\r\\nvec2 texCoord = gl_FragCoord.xy / uViewSize;\\r\\ntexCoord.y = 1.0 - texCoord.y; // FBOs are flipped.\\r\\n\\r\\nvec4 diffuseColor = texture2D(uSampler, texCoord);\\r\\nvec4 normalColor = texture2D(uNormalSampler, texCoord);\\r\\n\\r\\n// if no normal color here, just discard\\r\\nif (normalColor.a == 0.0) discard;\\r\\n\\n\\r\\n    // simplified lambert shading that makes assumptions for ambient color\\r\\n\\r\\n    // compute Distance\\r\\n//    float D = length(lightVector);\\r\\n    float D = 1.0;\\r\\n    \\r\\n    // normalize vectors\\r\\n    vec3 N = normalize(normalColor.xyz * 2.0 - 1.0);\\r\\n//    vec3 L = normalize(lightVector);\\r\\n    vec3 L = vec3(1.0, 1.0, 1.0);\\r\\n    \\r\\n    // pre-multiply light color with intensity\\r\\n    // then perform \\\"N dot L\\\" to determine our diffuse\\r\\n    vec3 diffuse = (uLightColor.rgb * uLightColor.a) * max(dot(N, L), 0.0);\\r\\n    \\r\\n    // pre-multiply ambient color with intensity\\r\\n//    vec3 ambient = uAmbientColor.rgb * uAmbientColor.a;\\r\\n    \\r\\n    // calculate attenuation\\r\\n//    float attenuation = 1.0 / (uLightFalloff.x + (uLightFalloff.y * D) + (uLightFalloff.z * D * D));\\r\\n    \\r\\n    // calculate final intesity and color, then combine\\r\\n//    vec3 intensity = ambient + diffuse * attenuation;\\r\\n//    vec3 finalColor = diffuseColor.rgb * intensity;\\r\\n    vec3 finalColor = diffuseColor.rgb * diffuse;\\r\\n\\r\\n    // calculate just ambient light color, most lights will override this frag\\r\\n//    vec3 ambientColor = uLightColor.rgb * uLightColor.a;\\r\\n//    gl_FragColor = vec4(diffuseColor.rgb * ambientColor, diffuseColor.a);\\r\\n    gl_FragColor = vec4(finalColor, diffuseColor.a);\\r\\n}\\r\\n\"\r\n    );\r\n}\r\n\r\nAmbientLightShader.prototype = Object.create(LightShader.prototype);\r\nAmbientLightShader.prototype.constructor = AmbientLightShader;\r\nmodule.exports = AmbientLightShader;\r\n\r\nPIXI.ShaderManager.registerPlugin('ambientLightShader', AmbientLightShader);\r\n","/**\r\n * Excuse the mess, haven't cleaned this up yet!\r\n */\r\n\r\n\r\n\r\n/**\r\n * @class\r\n * @extends PIXI.DisplayObject\r\n * @memberof PIXI.lights\r\n *\r\n * @param [color=0xFFFFFF] {number} The color of the light.\r\n * @param [brightness=1] {number} The brightness of the light, in range [0, 1].\r\n */\r\nfunction Light(color, brightness, vertices, indices) {\r\n    if (this.constructor === Light) {\r\n        throw new Error('Light is an abstract base class, it should not be created directly!');\r\n    }\r\n    \r\n    PIXI.DisplayObject.call(this);\r\n\r\n    /**\r\n     * An array of vertices\r\n     *\r\n     * @member {Float32Array}\r\n     */\r\n    this.vertices = vertices || new Float32Array(8);\r\n\r\n    /**\r\n     * An array containing the indices of the vertices\r\n     *\r\n     * @member {Uint16Array}\r\n     */\r\n    this.indices = indices || new Uint16Array([0,1,2, 0,2,3]);\r\n\r\n    /**\r\n     * The blend mode to be applied to the light.\r\n     *\r\n     * @member {number}\r\n     * @default CONST.BLEND_MODES.ADD;\r\n     */\r\n    this.blendMode = PIXI.BLEND_MODES.ADD;\r\n\r\n    /**\r\n     * The draw mode to be applied to the light geometry.\r\n     *\r\n     * @member {number}\r\n     * @default CONST.DRAW_MODES.TRIANGLES;\r\n     */\r\n    this.drawMode = PIXI.DRAW_MODES.TRIANGLES;\r\n\r\n    /**\r\n     * When set, the renderer will reupload the geometry data.\r\n     * \r\n     * @member {boolean}\r\n     */\r\n    this.needsUpdate = true;\r\n\r\n    /**\r\n     * The height of the light from the viewport.\r\n     *\r\n     * @member {number}\r\n     * @default 0.075\r\n     */\r\n    this.height = 0.075;\r\n\r\n    /**\r\n     * The falloff attenuation coeficients.\r\n     *\r\n     * @member {number[]}\r\n     * @default [0.75, 3, 20]\r\n     */\r\n    this.falloff = [0.75, 3, 20];\r\n\r\n    /**\r\n     * The name of the shader plugin to use.\r\n     *\r\n     * @member {string}\r\n     */\r\n    this.shaderName = null;\r\n\r\n    /**\r\n     * By default the light uses a viewport sized quad as the mesh.\r\n     */\r\n    this.useViewportQuad = true;\r\n\r\n    // webgl buffers\r\n    this._vertexBuffer = null;\r\n    this._indexBuffer = null;\r\n\r\n    // color and brightness are exposed through setters\r\n    this._color = 0x4d4d59;\r\n    this._colorRgba = [0.3, 0.3, 0.35, 0.8];\r\n\r\n    // run the color setter\r\n    if (color || color === 0) {\r\n        this.color = color;\r\n    }\r\n    \r\n    // run the brightness setter\r\n    if (brightness || brightness === 0) {\r\n        this.brightness = brightness;\r\n    }\r\n}\r\n\r\nLight.prototype = Object.create(PIXI.DisplayObject.prototype);\r\nLight.prototype.constructor = Light;\r\nmodule.exports = Light;\r\n\r\nObject.defineProperties(Light.prototype, {\r\n    /**\r\n     * The color of the lighting.\r\n     *\r\n     * @member {number}\r\n     * @memberof Light#\r\n     */\r\n    color: {\r\n        get: function ()\r\n        {\r\n            return this._color;\r\n        },\r\n        set: function (val)\r\n        {\r\n            this._color = val;\r\n            PIXI.utils.hex2rgb(val, this._colorRgba);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * The brightness of this lighting. Normalized in the range [0, 1].\r\n     *\r\n     * @member {number}\r\n     * @memberof Light#\r\n     */\r\n    brightness: {\r\n        get: function ()\r\n        {\r\n            return this._colorRgba[3];\r\n        },\r\n        set: function (val)\r\n        {\r\n            this._colorRgba[3] = val;\r\n        }\r\n    }\r\n});\r\n\r\nLight.prototype.syncShader = function (shader) {\r\n    shader.uniforms.uUseViewportQuad.value = this.useViewportQuad;\r\n\r\n    shader.uniforms.uLightColor.value[0] = this._colorRgba[0];\r\n    shader.uniforms.uLightColor.value[1] = this._colorRgba[1];\r\n    shader.uniforms.uLightColor.value[2] = this._colorRgba[2];\r\n    shader.uniforms.uLightColor.value[3] = this._colorRgba[3];\r\n\r\n    shader.uniforms.uLightHeight.value = this.height;\r\n\r\n    shader.uniforms.uLightFalloff.value[0] = this.falloff[0];\r\n    shader.uniforms.uLightFalloff.value[1] = this.falloff[1];\r\n    shader.uniforms.uLightFalloff.value[2] = this.falloff[2];\r\n};\r\n\r\nLight.prototype.renderWebGL = function (renderer)\r\n{\r\n    // add lights to their renderer on the normals pass\r\n    if (!renderer.renderingNormals) {\r\n        return;\r\n    }\r\n\r\n    // I actually don't want to interrupt the current batch, so don't set light as the current object renderer.\r\n    // Light renderer works a bit differently in that lights are draw individually on flush (called by WebGLDeferredRenderer).\r\n    //renderer.setObjectRenderer(renderer.plugins.lights);\r\n\r\n    renderer.plugins.lights.render(this);\r\n};\r\n\r\nLight.prototype.destroy = function ()\r\n{\r\n    PIXI.DisplayObject.prototype.destroy.call(this);\r\n\r\n    // TODO: Destroy buffers!\r\n};\r\n\r\nLight.DRAW_MODES = {\r\n    \r\n};\r\n","\r\n\r\n/**\r\n * @class\r\n * @extends PIXI.Shader\r\n * @memberof PIXI.lights\r\n * @param shaderManager {ShaderManager} The WebGL shader manager this shader works for.\r\n */\r\nfunction LightShader(shaderManager, vertexSrc, fragmentSrc, customUniforms, customAttributes) {\r\n    var uniforms = {\r\n        translationMatrix:  { type: 'mat3', value: new Float32Array(9) },\r\n        projectionMatrix:   { type: 'mat3', value: new Float32Array(9) },\r\n\r\n        // textures from the previously rendered FBOs\r\n        uSampler:       { type: 'sampler2D', value: null },\r\n        uNormalSampler: { type: 'sampler2D', value: null },\r\n\r\n        // should we apply the translation matrix or not.\r\n        uUseViewportQuad: { type: 'bool', value: true },\r\n\r\n        // size of the renderer viewport\r\n        uViewSize:      { type: '2f', value: new Float32Array(2) },\r\n\r\n        // light color, alpha channel used for intensity.\r\n        uLightColor:    { type: '4f', value: new Float32Array([1, 1, 1, 1]) },\r\n\r\n        // light falloff attenuation coefficients\r\n        uLightFalloff:  { type: '3f', value: new Float32Array([0, 0, 0]) },\r\n\r\n        // height of the light above the viewport\r\n        uLightHeight: { type: '1f', value: 0.075 }\r\n    };\r\n\r\n    if (customUniforms)\r\n    {\r\n        for (var u in customUniforms)\r\n        {\r\n            uniforms[u] = customUniforms[u];\r\n        }\r\n    }\r\n\r\n    var attributes = {\r\n        aVertexPosition: 0\r\n    };\r\n\r\n    if (customAttributes)\r\n    {\r\n        for (var a in customAttributes)\r\n        {\r\n            attributes[a] = customAttributes[a];\r\n        }\r\n    }\r\n\r\n    PIXI.Shader.call(this, shaderManager, vertexSrc || LightShader.defaultVertexSrc, fragmentSrc, uniforms, attributes);\r\n}\r\n\r\nLightShader.prototype = Object.create(PIXI.Shader.prototype);\r\nLightShader.prototype.constructor = LightShader;\r\nmodule.exports = LightShader;\r\n\r\nLightShader.defaultVertexSrc = \"#define GLSLIFY 1\\n\\nprecision lowp float;\\r\\n\\r\\nattribute vec2 aVertexPosition;\\r\\n\\r\\nuniform bool uUseViewportQuad;\\r\\nuniform mat3 translationMatrix;\\r\\nuniform mat3 projectionMatrix;\\r\\n\\r\\nvoid main(void) {\\r\\n    if (uUseViewportQuad) {\\r\\n        gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\\r\\n    }\\r\\n    else\\r\\n    {\\r\\n        gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\\r\\n    }\\r\\n}\\r\\n\";\r\n","var Light = require('../light/Light');\r\n\r\n/**\r\n * @class\r\n * @extends PIXI.lights.Light\r\n * @memberof PIXI.lights\r\n *\r\n * @param [color=0xFFFFFF] {number} The color of the light.\r\n * @param [brightness=1] {number} The intensity of the light.\r\n * @param [radius=Infinity] {number} The distance the light reaches. You will likely need\r\n *  to change the falloff of the light as well if you change this value. Infinity will\r\n *  use the entire viewport as the drawing surface.\r\n */\r\nfunction PointLight(color, brightness, radius) {\r\n    radius = radius || Infinity;\r\n\r\n    if (radius !== Infinity) {\r\n        var shape = new PIXI.math.Circle(0, 0, radius),\r\n            mesh = shape.getMesh();\r\n\r\n        Light.call(this, color, brightness, mesh.vertices, mesh.indices);\r\n\r\n        this.useViewportQuad = false;\r\n        this.drawMode = PIXI.DRAW_MODES.TRIANGLE_FAN;\r\n    }\r\n    else {\r\n        Light.call(this, color, brightness);\r\n    }\r\n\r\n    this._syncShader = Light.prototype.syncShader;\r\n\r\n    this.radius = radius;\r\n    this.shaderName = 'pointLightShader';\r\n}\r\n\r\nPointLight.prototype = Object.create(Light.prototype);\r\nPointLight.prototype.constructor = PointLight;\r\nmodule.exports = PointLight;\r\n\r\nPointLight.prototype.syncShader = function (shader) {\r\n    this._syncShader(shader);\r\n\r\n    shader.uniforms.uLightRadius.value = this.radius;\r\n}\r\n","var LightShader = require('../light/LightShader');\r\n\r\n\r\n/**\r\n * @class\r\n * @extends PIXI.Shader\r\n * @memberof PIXI.lights\r\n * @param shaderManager {ShaderManager} The WebGL shader manager this shader works for.\r\n */\r\nfunction PointLightShader(shaderManager) {\r\n    LightShader.call(this,\r\n        shaderManager,\r\n        // vertex shader\r\n        null,\r\n        // fragment shader\r\n        \"#define GLSLIFY 1\\n\\nprecision lowp float;\\r\\n\\r\\n// imports the common uniforms like samplers, and ambient color\\r\\nuniform sampler2D uSampler;\\r\\nuniform sampler2D uNormalSampler;\\r\\n\\r\\nuniform mat3 translationMatrix;\\r\\n\\r\\nuniform vec2 uViewSize;\\r\\n\\r\\nuniform vec4 uAmbientColor; // ambient color, alpha channel used for intensity.\\r\\n\\r\\nuniform vec4 uLightColor;   // light color, alpha channel used for intensity.\\r\\nuniform vec3 uLightFalloff; // light attenuation coefficients (constant, linear, quadratic)\\r\\nuniform float uLightHeight; // light height above the viewport\\r\\n\\n\\r\\nuniform float uLightRadius;\\r\\n\\r\\nvoid main()\\r\\n{\\r\\n    vec2 texCoord = gl_FragCoord.xy / uViewSize;\\r\\n    texCoord.y = 1.0 - texCoord.y; // FBOs positions are flipped.\\r\\n\\r\\n    vec4 normalColor = texture2D(uNormalSampler, texCoord);\\r\\n    normalColor.g = 1.0 - normalColor.g; // Green layer is flipped Y coords.\\r\\n\\r\\n    // bail out early when normal has no data\\r\\n    if (normalColor.a == 0.0) discard;\\r\\n\\r\\n    vec2 lightPosition = translationMatrix[2].xy / uViewSize;\\r\\n\\r\\n    // the directional vector of the light\\r\\n    vec3 lightVector = vec3(lightPosition - texCoord, uLightHeight);\\r\\n\\r\\n    // correct for aspect ratio\\r\\n    lightVector.x *= uViewSize.x / uViewSize.y;\\r\\n\\r\\n    // compute Distance\\r\\n    float D = length(lightVector);\\r\\n\\r\\n    // bail out early when pixel outside of light sphere\\r\\n    if (D > uLightRadius) discard;\\r\\n\\r\\n    // normalize vectors\\r\\n    vec3 N = normalize(normalColor.xyz * 2.0 - 1.0);\\r\\n    vec3 L = normalize(lightVector);\\r\\n    \\r\\n    // pre-multiply light color with intensity\\r\\n    // then perform \\\"N dot L\\\" to determine our diffuse\\r\\n    vec3 diffuse = (uLightColor.rgb * uLightColor.a) * max(dot(N, L), 0.0);\\r\\n\\r\\n    // calculate attenuation\\r\\n    float attenuation = 1.0 / (uLightFalloff.x + (uLightFalloff.y * D) + (uLightFalloff.z * D * D));\\r\\n    \\r\\n    // calculate final intesity and color, then combine\\r\\n    vec3 intensity = diffuse * attenuation;\\r\\n    vec4 diffuseColor = texture2D(uSampler, texCoord);\\r\\n    vec3 finalColor = diffuseColor.rgb * intensity;\\r\\n\\r\\n    gl_FragColor = vec4(finalColor, diffuseColor.a);\\r\\n}\",\r\n        // custom uniforms\r\n        {\r\n            // height of the light above the viewport\r\n            uLightRadius:   { type: '1f', value: 1 }\r\n        }\r\n    );\r\n}\r\n\r\nPointLightShader.prototype = Object.create(LightShader.prototype);\r\nPointLightShader.prototype.constructor = PointLightShader;\r\nmodule.exports = PointLightShader;\r\n\r\nPIXI.ShaderManager.registerPlugin('pointLightShader', PointLightShader);\r\n","/**\r\n *\r\n * @class\r\n * @private\r\n * @memberof PIXI.lights\r\n * @extends PIXI.ObjectRenderer\r\n * @param renderer {WebGLRenderer} The renderer this sprite batch works for.\r\n */\r\nfunction LightRenderer(renderer)\r\n{\r\n    PIXI.ObjectRenderer.call(this, renderer);\r\n\r\n    // the total number of indices in our batch, there are 6 points per quad.\r\n    var numIndices = LightRenderer.MAX_LIGHTS * 6;\r\n\r\n    /**\r\n     * Holds the indices\r\n     *\r\n     * @member {Uint16Array}\r\n     */\r\n    this.indices = new Uint16Array(numIndices);\r\n\r\n    //TODO this could be a single buffer shared amongst all renderers as we reuse this set up in most renderers\r\n    for (var i = 0, j = 0; i < numIndices; i += 6, j += 4)\r\n    {\r\n        this.indices[i + 0] = j + 0;\r\n        this.indices[i + 1] = j + 1;\r\n        this.indices[i + 2] = j + 2;\r\n        this.indices[i + 3] = j + 0;\r\n        this.indices[i + 4] = j + 2;\r\n        this.indices[i + 5] = j + 3;\r\n    }\r\n\r\n    /**\r\n     * The current size of the batch, each render() call adds to this number.\r\n     *\r\n     * @member {number}\r\n     */\r\n    this.currentBatchSize = 0;\r\n\r\n    /**\r\n     * The current lights in the batch.\r\n     *\r\n     * @member {Light[]}\r\n     */\r\n    this.lights = [];\r\n}\r\n\r\nLightRenderer.MAX_LIGHTS = 500;\r\n\r\nLightRenderer.prototype = Object.create(PIXI.ObjectRenderer.prototype);\r\nLightRenderer.prototype.constructor = LightRenderer;\r\nmodule.exports = LightRenderer;\r\n\r\nPIXI.WebGLRenderer.registerPlugin('lights', LightRenderer);\r\n\r\n/**\r\n * Renders the light object.\r\n *\r\n * @param light {Light} the light to render\r\n */\r\nLightRenderer.prototype.render = function (light)\r\n{\r\n    this.lights[this.currentBatchSize++] = light;\r\n};\r\n\r\nLightRenderer.prototype.flush = function ()\r\n{\r\n    var renderer = this.renderer,\r\n        gl = renderer.gl,\r\n        diffuseTexture = renderer.diffuseTexture,\r\n        normalsTexture = renderer.normalsTexture,\r\n        lastShader = null;\r\n\r\n    for (var i = 0; i < this.currentBatchSize; ++i)\r\n    {\r\n        var light = this.lights[i],\r\n            shader = light.shader || this.renderer.shaderManager.plugins[light.shaderName];\r\n\r\n        if (!light._vertexBuffer)\r\n        {\r\n            this._initWebGL(light);\r\n        }\r\n\r\n        // set shader if needed\r\n        if (shader !== lastShader) {\r\n            lastShader = shader;\r\n            renderer.shaderManager.setShader(shader);\r\n        }\r\n\r\n        renderer.blendModeManager.setBlendMode(light.blendMode);\r\n\r\n        // set uniforms, can do some optimizations here.\r\n        shader.uniforms.uViewSize.value[0] = renderer.width;\r\n        shader.uniforms.uViewSize.value[1] = renderer.height;\r\n\r\n        light.worldTransform.toArray(true, shader.uniforms.translationMatrix.value);\r\n        renderer.currentRenderTarget.projectionMatrix.toArray(true, shader.uniforms.projectionMatrix.value);\r\n\r\n        if (light.useViewportQuad) {\r\n            // update verts to ensure it is a fullscreen quad even if the renderer is resized. This should be optimized\r\n            light.vertices[2] = light.vertices[4] = renderer.width;\r\n            light.vertices[5] = light.vertices[7] = renderer.height;\r\n        }\r\n\r\n        light.syncShader(shader);\r\n\r\n        shader.syncUniforms();\r\n\r\n        // have to set these manually due to the way pixi base shader makes assumptions about texture units\r\n        gl.uniform1i(shader.uniforms.uSampler._location, 0);\r\n        gl.uniform1i(shader.uniforms.uNormalSampler._location, 1);\r\n\r\n        if (!light.needsUpdate)\r\n        {\r\n            // update vertex data\r\n            gl.bindBuffer(gl.ARRAY_BUFFER, light._vertexBuffer);\r\n            gl.bufferSubData(gl.ARRAY_BUFFER, 0, light.vertices);\r\n            gl.vertexAttribPointer(shader.attributes.aVertexPosition, 2, gl.FLOAT, false, 0, 0);\r\n\r\n            // bind diffuse texture\r\n            gl.activeTexture(gl.TEXTURE0);\r\n            gl.bindTexture(gl.TEXTURE_2D, diffuseTexture.baseTexture._glTextures[gl.id]);\r\n\r\n            // bind normal texture\r\n            gl.activeTexture(gl.TEXTURE1);\r\n            gl.bindTexture(gl.TEXTURE_2D, normalsTexture.baseTexture._glTextures[gl.id]);\r\n\r\n            // update indices\r\n            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, light._indexBuffer);\r\n            gl.bufferSubData(gl.ELEMENT_ARRAY_BUFFER, 0, light.indices);\r\n        }\r\n        else\r\n        {\r\n            light.needsUpdate = false;\r\n\r\n            // upload vertex data\r\n            gl.bindBuffer(gl.ARRAY_BUFFER, light._vertexBuffer);\r\n            gl.bufferData(gl.ARRAY_BUFFER, light.vertices, gl.STATIC_DRAW);\r\n            gl.vertexAttribPointer(shader.attributes.aVertexPosition, 2, gl.FLOAT, false, 0, 0);\r\n\r\n            // bind diffuse texture\r\n            gl.activeTexture(gl.TEXTURE0);\r\n            gl.bindTexture(gl.TEXTURE_2D, diffuseTexture.baseTexture._glTextures[gl.id]);\r\n\r\n            // bind normal texture\r\n            gl.activeTexture(gl.TEXTURE1);\r\n            gl.bindTexture(gl.TEXTURE_2D, normalsTexture.baseTexture._glTextures[gl.id]);\r\n\r\n            // static upload of index buffer\r\n            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, light._indexBuffer);\r\n            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, light.indices, gl.STATIC_DRAW);\r\n        }\r\n\r\n        gl.drawElements(renderer.drawModes[light.drawMode], light.indices.length, gl.UNSIGNED_SHORT, 0);\r\n    }\r\n\r\n    this.currentBatchSize = 0;\r\n};\r\n\r\n/**\r\n * Prepares all the buffers to render this light.\r\n *\r\n * @param light {Light} The light object to prepare for rendering.\r\n */\r\nLightRenderer.prototype._initWebGL = function (light)\r\n{\r\n    var gl = this.renderer.gl;\r\n\r\n    // create the buffers\r\n    light._vertexBuffer = gl.createBuffer();\r\n    light._indexBuffer = gl.createBuffer();\r\n\r\n    gl.bindBuffer(gl.ARRAY_BUFFER, light._vertexBuffer);\r\n    gl.bufferData(gl.ARRAY_BUFFER, light.vertices, gl.DYNAMIC_DRAW);\r\n\r\n    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, light._indexBuffer);\r\n    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, light.indices, gl.STATIC_DRAW);\r\n};\r\n\r\nLightRenderer.prototype.destroy = function ()\r\n{\r\n    \r\n};\r\n","/**\r\n * The WebGLDeferredRenderer draws the scene and all its content onto a webGL enabled canvas. This renderer\r\n * should be used for browsers that support webGL. This Render works by automatically managing webGLBatchs.\r\n * So no need for Sprite Batches or Sprite Clouds.\r\n * Don't forget to add the view to your DOM or you will not see anything :)\r\n *\r\n * @class\r\n * @memberof PIXI.lights\r\n * @extends PIXI.SystemRenderer\r\n * @param [width=0] {number} the width of the canvas view\r\n * @param [height=0] {number} the height of the canvas view\r\n * @param [options] {object} The optional renderer parameters\r\n * @param [options.view] {HTMLCanvasElement} the canvas to use as a view, optional\r\n * @param [options.transparent=false] {boolean} If the render view is transparent, default false\r\n * @param [options.autoResize=false] {boolean} If the render view is automatically resized, default false\r\n * @param [options.antialias=false] {boolean} sets antialias. If not available natively then FXAA antialiasing is used\r\n * @param [options.forceFXAA=false] {boolean} forces FXAA antialiasing to be used over native. FXAA is faster, but may not always lok as great\r\n * @param [options.resolution=1] {number} the resolution of the renderer retina would be 2\r\n * @param [options.clearBeforeRender=true] {boolean} This sets if the CanvasRenderer will clear the canvas or\r\n *      not before the new render pass.\r\n * @param [options.preserveDrawingBuffer=false] {boolean} enables drawing buffer preservation, enable this if\r\n *      you need to call toDataUrl on the webgl context.\r\n */\r\nfunction WebGLDeferredRenderer(width, height, options)\r\n{\r\n    options = options || {};\r\n\r\n    this.renderingNormals = false;\r\n\r\n    PIXI.WebGLRenderer.call(this, width, height, options);\r\n}\r\n\r\nWebGLDeferredRenderer.prototype = Object.create(PIXI.WebGLRenderer.prototype);\r\nWebGLDeferredRenderer.prototype.constructor = WebGLDeferredRenderer;\r\nmodule.exports = WebGLDeferredRenderer;\r\n\r\n/** @lends PIXI.DisplayObject# */\r\nObject.assign(WebGLDeferredRenderer.prototype, {\r\n    /**\r\n     * Initializes the context and necessary framebuffers.\r\n     */\r\n    _initContext: function ()\r\n    {\r\n        // call parent init\r\n        PIXI.WebGLRenderer.prototype._initContext.call(this);\r\n\r\n        // first create our render targets.\r\n        this.diffuseTexture = new PIXI.RenderTexture(this, this.width, this.height, null, this.resolution);\r\n        this.normalsTexture = new PIXI.RenderTexture(this, this.width, this.height, null, this.resolution);\r\n    },\r\n\r\n    render: function (object)\r\n    {\r\n        // render diffuse\r\n        this.renderingNormals = false;\r\n        this.diffuseTexture.render(object);\r\n\r\n        // render normals\r\n        this.renderingNormals = true;\r\n        this.normalsTexture.render(object);\r\n\r\n        // render lights\r\n        this.setRenderTarget(this.renderTarget);\r\n        this.setObjectRenderer(this.plugins.lights);\r\n        this.plugins.lights.flush();\r\n    }\r\n});\r\n","/**\r\n * Creates vertices and indices arrays to describe this circle.\r\n * \r\n * @param [totalSegments=40] {number} Total segments to build for the circle mesh.\r\n * @param [verticesOutput] {Float32Array} An array to output the vertices into. Length must be\r\n *  `((totalSegments + 2) * 2)` or more. If not passed it is created for you.\r\n * @param [indicesOutput] {Uint16Array} An array to output the indices into, in gl.TRIANGLE_FAN format. Length must\r\n *  be `(totalSegments + 3)` or more. If not passed it is created for you.\r\n */\r\nPIXI.math.Circle.prototype.getMesh = function (totalSegments, vertices, indices)\r\n{\r\n    totalSegments = totalSegments || 40;\r\n\r\n    vertices = vertices || new Float32Array((totalSegments + 1) * 2);\r\n    indices = indices || new Uint16Array(totalSegments + 1);\r\n\r\n    var seg = (Math.PI * 2) / totalSegments,\r\n        indicesIndex = -1;\r\n\r\n    indices[++indicesIndex] = indicesIndex;\r\n\r\n    for (var i = 0; i <= totalSegments; ++i)\r\n    {\r\n        var index = i*2;\r\n        var angle = seg * i;\r\n\r\n        vertices[index] = Math.cos(angle) * this.radius;\r\n        vertices[index+1] = Math.sin(angle) * this.radius;\r\n\r\n        indices[++indicesIndex] = indicesIndex;\r\n    }\r\n\r\n    indices[indicesIndex] = 1;\r\n\r\n    return {\r\n        vertices: vertices,\r\n        indices: indices\r\n    };\r\n};\r\n"]}