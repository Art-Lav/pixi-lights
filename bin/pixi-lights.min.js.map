{"version":3,"sources":["node_modules/browser-pack/_prelude.js","src/index","pixi-lights.min.js","src/lights/WireframeShader.js","src/lights/ambientLight/AmbientLight.js","src/lights/ambientLight/AmbientLightShader.js","src/lights/directionalLight/DirectionalLight.js","src/lights/directionalLight/DirectionalLightShader.js","src/lights/light/Light.js","src/lights/light/LightShader.js","src/lights/pointLight/PointLight.js","src/lights/pointLight/PointLightShader.js","src/main.js","src/renderers/LightRenderer.js","src/shapeMeshMixin.js"],"names":["e","t","n","r","s","o","u","a","require","i","f","Error","code","l","exports","call","length","1","module","PIXI","lights","Light","LightShader","AmbientLight","AmbientLightShader","PointLight","PointLightShader","DirectionalLight","DirectionalLightShader","LightRenderer","WireframeShader","Object","assign","./lights/WireframeShader","./lights/ambientLight/AmbientLight","./lights/ambientLight/AmbientLightShader","./lights/directionalLight/DirectionalLight","./lights/directionalLight/DirectionalLightShader","./lights/light/Light","./lights/light/LightShader","./lights/pointLight/PointLight","./lights/pointLight/PointLightShader","./main","./renderers/LightRenderer","./shapeMeshMixin","2","gl","Shader","this","join","aVertexPosition","main","prototype","create","constructor","registerPlugin","../main","3","color","brightness","shaderName","../light/Light","4","../../main","../light/LightShader","5","target","_directionVector","Point","_updateTransform","updateTransform","_syncShader","syncShader","containerUpdateTransform","vec","wt","worldTransform","tx","x","ty","y","len","Math","sqrt","shader","uLightDirection","uniforms","6","type","value","Float32Array","7","vertices","indices","Container","Uint16Array","blendMode","BLEND_MODES","ADD","drawMode","DRAW_MODES","TRIANGLES","dirty","lightHeight","falloff","useViewportQuad","_color","_colorRgba","parentGroup","lightGroup","_glDatas","defineProperties","get","set","val","utils","hex2rgb","uUseViewportQuad","uLightColor","uLightHeight","uLightFalloff","_renderWebGL","renderer","setObjectRenderer","plugins","render","8","vertexSrc","fragmentSrc","customUniforms","customAttributes","translationMatrix","projectionMatrix","uSampler","uNormalSampler","uViewSize","attributes","defaultVertexSrc","9","radius","Infinity","shape","Circle","mesh","getMesh","TRIANGLE_FAN","uLightRadius","10","11","name","fun","diffuseGroup","display","Group","normalGroup","useRenderTexture","12","ObjectRenderer","numIndices","MAX_LIGHTS","j","shaders","glCore","WebGLRenderer","onContextChange","key","push","glData","CONTEXT_UID","bindVao","vertexBuffer","GLBuffer","createVertexBuffer","STREAM_DRAW","indexBuffer","createIndexBuffer","STATIC_DRAW","vao","VertexArrayObject","addIndex","addAttribute","FLOAT","screen","width","height","upload","flush","diffuseTexture","normalTexture","lastLayer","lastShader","light","layer","_activeParentLayer","stage","_activeStageParent","_activeLayers","texLayer","group","getRenderTexture","bindTexture","bindShader","state","setBlendMode","toArray","draw","stop","13","totalSegments","seg","PI","indicesIndex","index","angle","cos","sin"],"mappings":"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","file":"pixi-lights.min.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","PIXI.lights = {\n    Light:                  require('./lights/light/Light'),\n    LightShader:            require('./lights/light/LightShader'),\n\n    AmbientLight:           require('./lights/ambientLight/AmbientLight'),\n    AmbientLightShader:     require('./lights/ambientLight/AmbientLightShader'),\n\n    PointLight:             require('./lights/pointLight/PointLight'),\n    PointLightShader:       require('./lights/pointLight/PointLightShader'),\n\n    DirectionalLight:             require('./lights/directionalLight/DirectionalLight'),\n    DirectionalLightShader:       require('./lights/directionalLight/DirectionalLightShader'),\n\n    LightRenderer:          require('./renderers/LightRenderer'),\n\n    WireframeShader:        require('./lights/WireframeShader')\n};\n\nObject.assign(PIXI.lights, require('./main'));\n\nmodule.exports = PIXI.lights;\n\nrequire('./shapeMeshMixin');\n","(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\nPIXI.lights = {\n    Light:                  require('./lights/light/Light'),\n    LightShader:            require('./lights/light/LightShader'),\n\n    AmbientLight:           require('./lights/ambientLight/AmbientLight'),\n    AmbientLightShader:     require('./lights/ambientLight/AmbientLightShader'),\n\n    PointLight:             require('./lights/pointLight/PointLight'),\n    PointLightShader:       require('./lights/pointLight/PointLightShader'),\n\n    DirectionalLight:             require('./lights/directionalLight/DirectionalLight'),\n    DirectionalLightShader:       require('./lights/directionalLight/DirectionalLightShader'),\n\n    LightRenderer:          require('./renderers/LightRenderer'),\n\n    WireframeShader:        require('./lights/WireframeShader')\n};\n\nObject.assign(PIXI.lights, require('./main'));\n\nmodule.exports = PIXI.lights;\n\nrequire('./shapeMeshMixin');\n\n},{\"./lights/WireframeShader\":2,\"./lights/ambientLight/AmbientLight\":3,\"./lights/ambientLight/AmbientLightShader\":4,\"./lights/directionalLight/DirectionalLight\":5,\"./lights/directionalLight/DirectionalLightShader\":6,\"./lights/light/Light\":7,\"./lights/light/LightShader\":8,\"./lights/pointLight/PointLight\":9,\"./lights/pointLight/PointLightShader\":10,\"./main\":11,\"./renderers/LightRenderer\":12,\"./shapeMeshMixin\":13}],2:[function(require,module,exports){\nvar main = require('../main');\n\n\n/**\n * @class\n * @extends PIXI.Shader\n * @memberof PIXI.lights\n * @param shaderManager {ShaderManager} The WebGL shader manager this shader works for.\n */\nfunction WireframeShader(gl) {\n    PIXI.Shader.call(this,\n        gl,\n        // vertex shader\n        [\n            'attribute vec2 aVertexPosition;',\n            'uniform mat3 projectionMatrix;',\n\n            'void main(void) {',\n            '    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);',\n            '}'\n        ].join('\\n'),\n        // fragment shader\n        [\n            'void main() {',\n            '    gl_FragColor = vec4(0, 0, 0, 1);',\n            '}'\n        ].join('\\n'),\n        /*// uniforms\n        {\n            translationMatrix:  { type: 'mat3', value: new Float32Array(9) },\n            projectionMatrix:   { type: 'mat3', value: new Float32Array(9) }\n        },*/\n        // attributes\n        {\n            aVertexPosition: 0\n        }\n    );\n}\n\nWireframeShader.prototype = Object.create(PIXI.Shader.prototype);\nWireframeShader.prototype.constructor = WireframeShader;\nmodule.exports = WireframeShader;\n\nmain.registerPlugin('wireframeShader', WireframeShader);\n\n},{\"../main\":11}],3:[function(require,module,exports){\nvar Light = require('../light/Light');\n\n/**\n * @class\n * @extends PIXI.lights.Light\n * @memberof PIXI.lights\n *\n * @param [color=0xFFFFFF] {number} The color of the light.\n * @param [brightness=0.5] {number} The brightness of the light.\n */\nfunction AmbientLight(color, brightness) {\n    // ambient light is drawn using a full-screen quad\n    Light.call(this, color, brightness);\n\n    this.shaderName = 'ambientLightShader';\n}\n\nAmbientLight.prototype = Object.create(Light.prototype);\nAmbientLight.prototype.constructor = AmbientLight;\nmodule.exports = AmbientLight;\n\n},{\"../light/Light\":7}],4:[function(require,module,exports){\nvar main = require('../../main');\r\nvar LightShader = require('../light/LightShader');\r\n\r\n\r\n/**\r\n * @class\r\n * @extends PIXI.Shader\r\n * @memberof PIXI.lights\r\n * @param shaderManager {ShaderManager} The WebGL shader manager this shader works for.\r\n */\r\nfunction AmbientLightShader(gl) {\r\n    LightShader.call(this,\r\n        gl,\r\n        // vertex shader\r\n        null,\r\n        // fragment shader\r\n        \"precision highp float;\\n#define GLSLIFY 1\\n\\nuniform sampler2D uSampler;\\nuniform sampler2D uNormalSampler;\\n\\nuniform mat3 translationMatrix;\\n\\nuniform vec2 uViewSize;     // size of the viewport\\n\\nuniform vec4 uLightColor;   // light color, alpha channel used for intensity.\\nuniform vec3 uLightFalloff; // light attenuation coefficients (constant, linear, quadratic)\\nuniform float uLightHeight; // light height above the viewport\\n\\n\\nvoid main(void)\\n{\\nvec2 texCoord = gl_FragCoord.xy / uViewSize;\\ntexCoord.y = 1.0 - texCoord.y; // FBOs positions are flipped.\\n\\nvec4 normalColor = texture2D(uNormalSampler, texCoord);\\nnormalColor.g = 1.0 - normalColor.g; // Green layer is flipped Y coords.\\n\\n// bail out early when normal has no data\\nif (normalColor.a == 0.0) discard;\\n\\n\\n    // simplified lambert shading that makes assumptions for ambient color\\n\\n    // compute Distance\\n    float D = 1.0;\\n\\n    // normalize vectors\\n    vec3 N = normalize(normalColor.xyz * 2.0 - 1.0);\\n    vec3 L = vec3(1.0, 1.0, 1.0);\\n\\n    // pre-multiply light color with intensity\\n    // then perform \\\"N dot L\\\" to determine our diffuse\\n    vec3 diffuse = (uLightColor.rgb * uLightColor.a) * max(dot(N, L), 0.0);\\n\\n    vec4 diffuseColor = texture2D(uSampler, texCoord);\\n    vec3 finalColor = diffuseColor.rgb * diffuse;\\n\\n    gl_FragColor = vec4(finalColor, diffuseColor.a);\\n}\\n\"\r\n    );\r\n}\r\n\r\nAmbientLightShader.prototype = Object.create(LightShader.prototype);\r\nAmbientLightShader.prototype.constructor = AmbientLightShader;\r\nmodule.exports = AmbientLightShader;\r\n\r\nmain.registerPlugin('ambientLightShader', AmbientLightShader);\r\n\n},{\"../../main\":11,\"../light/LightShader\":8}],5:[function(require,module,exports){\nvar Light = require('../light/Light');\n\n/**\n * @class\n * @extends PIXI.lights.Light\n * @memberof PIXI.lights\n *\n * @param [color=0xFFFFFF] {number} The color of the light.\n * @param [brightness=1] {number} The intensity of the light.\n * @param [target] {PIXI.DisplayObject|PIXI.Point} The object in the scene to target.\n */\nfunction DirectionalLight(color, brightness, target) {\n    Light.call(this, color, brightness);\n\n    this.target = target;\n    this._directionVector = new PIXI.Point();\n\n    this._updateTransform = Light.prototype.updateTransform;\n    this._syncShader = Light.prototype.syncShader;\n\n    this.shaderName = 'directionalLightShader';\n}\n\nDirectionalLight.prototype = Object.create(Light.prototype);\nDirectionalLight.prototype.constructor = DirectionalLight;\nmodule.exports = DirectionalLight;\n\nDirectionalLight.prototype.updateTransform = function () {\n    this.containerUpdateTransform();\n\n    var vec = this._directionVector,\n        wt = this.worldTransform,\n        tx = this.target.worldTransform ? this.target.worldTransform.tx : this.target.x,\n        ty = this.target.worldTransform ? this.target.worldTransform.ty : this.target.y;\n\n    // calculate direction from this light to the target\n    vec.x = wt.tx - tx;\n    vec.y = wt.ty - ty;\n\n    // normalize\n    var len = Math.sqrt(vec.x * vec.x + vec.y * vec.y);\n    vec.x /= len;\n    vec.y /= len;\n};\n\nDirectionalLight.prototype.syncShader = function (shader) {\n    this._syncShader(shader);\n\n    var uLightDirection = shader.uniforms.uLightDirection;\n    uLightDirection[0] = this._directionVector.x;\n    uLightDirection[1] = this._directionVector.y;\n    shader.uniforms.uLightDirection = uLightDirection;\n};\n\n},{\"../light/Light\":7}],6:[function(require,module,exports){\nvar main = require('../../main');\nvar LightShader = require('../light/LightShader');\n\n\n/**\n * @class\n * @extends PIXI.Shader\n * @memberof PIXI.lights\n * @param shaderManager {ShaderManager} The WebGL shader manager this shader works for.\n */\nfunction DirectionalLightShader(gl) {\n    LightShader.call(this,\n        gl,\n        // vertex shader\n        null,\n        // fragment shader\n        \"precision highp float;\\n#define GLSLIFY 1\\n\\n// imports the common uniforms like samplers, and ambient/light color\\nuniform sampler2D uSampler;\\nuniform sampler2D uNormalSampler;\\n\\nuniform mat3 translationMatrix;\\n\\nuniform vec2 uViewSize;     // size of the viewport\\n\\nuniform vec4 uLightColor;   // light color, alpha channel used for intensity.\\nuniform vec3 uLightFalloff; // light attenuation coefficients (constant, linear, quadratic)\\nuniform float uLightHeight; // light height above the viewport\\n\\n\\nuniform vec2 uLightDirection;\\n\\nvoid main()\\n{\\nvec2 texCoord = gl_FragCoord.xy / uViewSize;\\ntexCoord.y = 1.0 - texCoord.y; // FBOs positions are flipped.\\n\\nvec4 normalColor = texture2D(uNormalSampler, texCoord);\\nnormalColor.g = 1.0 - normalColor.g; // Green layer is flipped Y coords.\\n\\n// bail out early when normal has no data\\nif (normalColor.a == 0.0) discard;\\n\\n\\n    // the directional vector of the light\\n    vec3 lightVector = vec3(uLightDirection, uLightHeight);\\n\\n    // compute Distance\\n    float D = length(lightVector);\\n\\n// normalize vectors\\nvec3 N = normalize(normalColor.xyz * 2.0 - 1.0);\\nvec3 L = normalize(lightVector);\\n\\n// pre-multiply light color with intensity\\n// then perform \\\"N dot L\\\" to determine our diffuse\\nvec3 diffuse = (uLightColor.rgb * uLightColor.a) * max(dot(N, L), 0.0);\\n\\n\\n    // calculate attenuation\\n    float attenuation = 1.0;\\n\\n// calculate final intesity and color, then combine\\nvec3 intensity = diffuse * attenuation;\\nvec4 diffuseColor = texture2D(uSampler, texCoord);\\nvec3 finalColor = diffuseColor.rgb * intensity;\\n\\ngl_FragColor = vec4(finalColor, diffuseColor.a);\\n\\n}\\n\",\n        // custom uniforms\n        {\n            // the directional vector of the light\n            uLightDirection: { type: '2f', value: new Float32Array(2) }\n        }\n    );\n}\n\nDirectionalLightShader.prototype = Object.create(LightShader.prototype);\nDirectionalLightShader.prototype.constructor = DirectionalLightShader;\nmodule.exports = DirectionalLightShader;\n\nmain.registerPlugin('directionalLightShader', DirectionalLightShader);\n\n},{\"../../main\":11,\"../light/LightShader\":8}],7:[function(require,module,exports){\n/**\n * Excuse the mess, haven't cleaned this up yet!\n */\n\nvar main = require('../../main');\n\n/**\n * @class\n * @extends PIXI.DisplayObject\n * @memberof PIXI.lights\n *\n * @param [color=0xFFFFFF] {number} The color of the light.\n * @param [brightness=1] {number} The brightness of the light, in range [0, 1].\n */\nfunction Light(color, brightness, vertices, indices) {\n    if (this.constructor === Light) {\n        throw new Error('Light is an abstract base class, it should not be created directly!');\n    }\n\n    PIXI.Container.call(this);\n\n    /**\n     * An array of vertices\n     *\n     * @member {Float32Array}\n     */\n    this.vertices = vertices || new Float32Array(8);\n\n    /**\n     * An array containing the indices of the vertices\n     *\n     * @member {Uint16Array}\n     */\n    this.indices = indices || new Uint16Array([0,1,2, 0,2,3]);\n\n    /**\n     * The blend mode to be applied to the light.\n     *\n     * @member {number}\n     * @default CONST.BLEND_MODES.ADD;\n     */\n    this.blendMode = PIXI.BLEND_MODES.ADD;\n\n    /**\n     * The draw mode to be applied to the light geometry.\n     *\n     * @member {number}\n     * @default CONST.DRAW_MODES.TRIANGLES;\n     */\n    this.drawMode = PIXI.DRAW_MODES.TRIANGLES;\n\n    /**\n     * When incremented the renderer will re-upload indices\n     *\n     * @member {number}\n     */\n    this.dirty = 0;\n\n    /**\n     * The height of the light from the viewport.\n     *\n     * @member {number}\n     * @default 0.075\n     */\n    this.lightHeight = 0.075;\n\n    /**\n     * The falloff attenuation coeficients.\n     *\n     * @member {number[]}\n     * @default [0.75, 3, 20]\n     */\n    this.falloff = [0.75, 3, 20];\n\n    /**\n     * The name of the shader plugin to use.\n     *\n     * @member {string}\n     */\n    this.shaderName = null;\n\n    /**\n     * By default the light uses a viewport sized quad as the mesh.\n     */\n    this.useViewportQuad = true;\n\n    // color and brightness are exposed through setters\n    this._color = 0x4d4d59;\n    this._colorRgba = [0.3, 0.3, 0.35, 0.8];\n\n    // run the color setter\n    if (color || color === 0) {\n        this.color = color;\n    }\n\n    // run the brightness setter\n    if (brightness || brightness === 0) {\n        this.brightness = brightness;\n    }\n\n    this.parentGroup = main.lightGroup;\n\n\n    /**\n     * WebGL data for this light\n     * @member {Object}\n     * @private\n     */\n    this._glDatas = {};\n\n    this.shaderName = 'lights';\n}\n\nLight.prototype = Object.create(PIXI.Container.prototype);\nLight.prototype.constructor = Light;\nmodule.exports = Light;\n\nObject.defineProperties(Light.prototype, {\n    /**\n     * The color of the lighting.\n     *\n     * @member {number}\n     * @memberof Light#\n     */\n    color: {\n        get: function ()\n        {\n            return this._color;\n        },\n        set: function (val)\n        {\n            this._color = val;\n            PIXI.utils.hex2rgb(val, this._colorRgba);\n        }\n    },\n\n    /**\n     * The brightness of this lighting. Normalized in the range [0, 1].\n     *\n     * @member {number}\n     * @memberof Light#\n     */\n    brightness: {\n        get: function ()\n        {\n            return this._colorRgba[3];\n        },\n        set: function (val)\n        {\n            this._colorRgba[3] = val;\n        }\n    }\n});\n\nLight.prototype.syncShader = function (shader) {\n    shader.uniforms.uUseViewportQuad = this.useViewportQuad;\n\n    var uLightColor = shader.uniforms.uLightColor;\n    if (uLightColor) {\n        uLightColor[0] = this._colorRgba[0];\n        uLightColor[1] = this._colorRgba[1];\n        uLightColor[2] = this._colorRgba[2];\n        uLightColor[3] = this._colorRgba[3];\n        shader.uniforms.uLightColor = uLightColor;\n    }\n\n    shader.uniforms.uLightHeight = this.lightHeight;\n\n    var uLightFalloff = shader.uniforms.uLightFalloff;\n    if (uLightFalloff) {\n        uLightFalloff[0] = this.falloff[0];\n        uLightFalloff[1] = this.falloff[1];\n        uLightFalloff[2] = this.falloff[2];\n        shader.uniforms.uLightFalloff = uLightFalloff;\n    }\n};\n\nLight.prototype._renderWebGL = function (renderer)\n{\n    renderer.setObjectRenderer(renderer.plugins.lights);\n    renderer.plugins.lights.render(this);\n};\n\n},{\"../../main\":11}],8:[function(require,module,exports){\n\r\n\r\n/**\r\n * @class\r\n * @extends PIXI.Shader\r\n * @memberof PIXI.lights\r\n * @param shaderManager {ShaderManager} The WebGL shader manager this shader works for.\r\n */\r\nfunction LightShader(gl, vertexSrc, fragmentSrc, customUniforms, customAttributes) {\r\n    var uniforms = {\r\n        translationMatrix:  { type: 'mat3', value: new Float32Array(9) },\r\n        projectionMatrix:   { type: 'mat3', value: new Float32Array(9) },\r\n\r\n        // textures from the previously rendered FBOs\r\n        uSampler:       { type: 'sampler2D', value: null },\r\n        uNormalSampler: { type: 'sampler2D', value: null },\r\n\r\n        // should we apply the translation matrix or not.\r\n        uUseViewportQuad: { type: 'bool', value: true },\r\n\r\n        // size of the renderer viewport\r\n        uViewSize:      { type: '2f', value: new Float32Array(2) },\r\n\r\n        // light color, alpha channel used for intensity.\r\n        uLightColor:    { type: '4f', value: new Float32Array([1, 1, 1, 1]) },\r\n\r\n        // light falloff attenuation coefficients\r\n        uLightFalloff:  { type: '3f', value: new Float32Array([0, 0, 0]) },\r\n\r\n        // height of the light above the viewport\r\n        uLightHeight: { type: '1f', value: 0.075 }\r\n    };\r\n\r\n    if (customUniforms)\r\n    {\r\n        for (var u in customUniforms)\r\n        {\r\n            uniforms[u] = customUniforms[u];\r\n        }\r\n    }\r\n\r\n    var attributes = {\r\n        aVertexPosition: 0\r\n    };\r\n\r\n    if (customAttributes)\r\n    {\r\n        for (var a in customAttributes)\r\n        {\r\n            attributes[a] = customAttributes[a];\r\n        }\r\n    }\r\n\r\n    PIXI.Shader.call(this, gl, vertexSrc || LightShader.defaultVertexSrc, fragmentSrc, attributes);\r\n}\r\n\r\nLightShader.prototype = Object.create(PIXI.Shader.prototype);\r\nLightShader.prototype.constructor = LightShader;\r\nmodule.exports = LightShader;\r\n\r\nLightShader.defaultVertexSrc = \"#define GLSLIFY 1\\nattribute vec2 aVertexPosition;\\n\\nuniform bool uUseViewportQuad;\\nuniform mat3 translationMatrix;\\nuniform mat3 projectionMatrix;\\n\\nvoid main(void) {\\n    if (uUseViewportQuad) {\\n        gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\\n    }\\n    else\\n    {\\n        gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\\n    }\\n}\\n\";\r\n\n},{}],9:[function(require,module,exports){\nvar Light = require('../light/Light');\n\n/**\n * @class\n * @extends PIXI.lights.Light\n * @memberof PIXI.lights\n *\n * @param [color=0xFFFFFF] {number} The color of the light.\n * @param [brightness=1] {number} The intensity of the light.\n * @param [radius=Infinity] {number} The distance the light reaches. You will likely need\n *  to change the falloff of the light as well if you change this value. Infinity will\n *  use the entire viewport as the drawing surface.\n */\nfunction PointLight(color, brightness, radius) {\n    radius = radius || Infinity;\n\n    if (radius !== Infinity) {\n        var shape = new PIXI.Circle(0, 0, radius),\n            mesh = shape.getMesh();\n\n        Light.call(this, color, brightness, mesh.vertices, mesh.indices);\n\n        this.useViewportQuad = false;\n        this.drawMode = PIXI.DRAW_MODES.TRIANGLE_FAN;\n    }\n    else {\n        Light.call(this, color, brightness);\n    }\n\n    this._syncShader = Light.prototype.syncShader;\n\n    this.radius = radius;\n    this.shaderName = 'pointLightShader';\n}\n\nPointLight.prototype = Object.create(Light.prototype);\nPointLight.prototype.constructor = PointLight;\nmodule.exports = PointLight;\n\nPointLight.prototype.syncShader = function (shader) {\n    this._syncShader(shader);\n\n    shader.uniforms.uLightRadius = this.radius;\n}\n\n},{\"../light/Light\":7}],10:[function(require,module,exports){\nvar main = require('../../main');\r\nvar LightShader = require('../light/LightShader');\r\n\r\n\r\n/**\r\n * @class\r\n * @extends PIXI.Shader\r\n * @memberof PIXI.lights\r\n * @param shaderManager {ShaderManager} The WebGL shader manager this shader works for.\r\n */\r\nfunction PointLightShader(gl) {\r\n    LightShader.call(this,\r\n        gl,\r\n        // vertex shader\r\n        null,\r\n        // fragment shader\r\n        \"precision highp float;\\n#define GLSLIFY 1\\n\\n// imports the common uniforms like samplers, and ambient color\\nuniform sampler2D uSampler;\\nuniform sampler2D uNormalSampler;\\n\\nuniform mat3 translationMatrix;\\n\\nuniform vec2 uViewSize;     // size of the viewport\\n\\nuniform vec4 uLightColor;   // light color, alpha channel used for intensity.\\nuniform vec3 uLightFalloff; // light attenuation coefficients (constant, linear, quadratic)\\nuniform float uLightHeight; // light height above the viewport\\n\\n\\nuniform float uLightRadius;\\n\\nvoid main()\\n{\\nvec2 texCoord = gl_FragCoord.xy / uViewSize;\\ntexCoord.y = 1.0 - texCoord.y; // FBOs positions are flipped.\\n\\nvec4 normalColor = texture2D(uNormalSampler, texCoord);\\nnormalColor.g = 1.0 - normalColor.g; // Green layer is flipped Y coords.\\n\\n// bail out early when normal has no data\\nif (normalColor.a == 0.0) discard;\\n\\n\\n    vec2 lightPosition = translationMatrix[2].xy / uViewSize;\\n\\n    // the directional vector of the light\\n    vec3 lightVector = vec3(lightPosition - texCoord, uLightHeight);\\n\\n    // correct for aspect ratio\\n    lightVector.x *= uViewSize.x / uViewSize.y;\\n\\n    // compute Distance\\n    float D = length(lightVector);\\n\\n    // bail out early when pixel outside of light sphere\\n    if (D > uLightRadius) discard;\\n\\n// normalize vectors\\nvec3 N = normalize(normalColor.xyz * 2.0 - 1.0);\\nvec3 L = normalize(lightVector);\\n\\n// pre-multiply light color with intensity\\n// then perform \\\"N dot L\\\" to determine our diffuse\\nvec3 diffuse = (uLightColor.rgb * uLightColor.a) * max(dot(N, L), 0.0);\\n\\n\\n    // calculate attenuation\\n    float attenuation = 1.0 / (uLightFalloff.x + (uLightFalloff.y * D) + (uLightFalloff.z * D * D));\\n\\n// calculate final intesity and color, then combine\\nvec3 intensity = diffuse * attenuation;\\nvec4 diffuseColor = texture2D(uSampler, texCoord);\\nvec3 finalColor = diffuseColor.rgb * intensity;\\n\\ngl_FragColor = vec4(finalColor, diffuseColor.a);\\n\\n}\\n\",\r\n        // custom uniforms\r\n        {\r\n            // height of the light above the viewport\r\n            uLightRadius:   { type: '1f', value: 1 }\r\n        }\r\n    );\r\n}\r\n\r\nPointLightShader.prototype = Object.create(LightShader.prototype);\r\nPointLightShader.prototype.constructor = PointLightShader;\r\nmodule.exports = PointLightShader;\r\n\r\nmain.registerPlugin('pointLightShader', PointLightShader);\r\n\n},{\"../../main\":11,\"../light/LightShader\":8}],11:[function(require,module,exports){\nmodule.exports = {\n    plugins: {},\n    registerPlugin: function(name, fun) {\n        this.plugins[name] = fun;\n    },\n    diffuseGroup: new PIXI.display.Group(),\n    normalGroup: new PIXI.display.Group(),\n    lightGroup: new PIXI.display.Group()\n};\n\nmodule.exports.diffuseGroup.useRenderTexture = true;\nmodule.exports.normalGroup.useRenderTexture = true;\n\n},{}],12:[function(require,module,exports){\nvar main = require('../main');\nvar glCore = PIXI.glCore;\n\n/**\n *\n * @class\n * @private\n * @memberof PIXI.lights\n * @extends PIXI.ObjectRenderer\n * @param renderer {WebGLRenderer} The renderer this sprite batch works for.\n */\nfunction LightRenderer(renderer) {\n    PIXI.ObjectRenderer.call(this, renderer);\n\n    // the total number of indices in our batch, there are 6 points per quad.\n    var numIndices = LightRenderer.MAX_LIGHTS * 6;\n\n    /**\n     * Holds the indices\n     *\n     * @member {Uint16Array}\n     */\n    this.indices = new Uint16Array(numIndices);\n\n    //TODO this could be a single buffer shared amongst all renderers as we reuse this set up in most renderers\n    for (var i = 0, j = 0; i < numIndices; i += 6, j += 4) {\n        this.indices[i + 0] = j + 0;\n        this.indices[i + 1] = j + 1;\n        this.indices[i + 2] = j + 2;\n        this.indices[i + 3] = j + 0;\n        this.indices[i + 4] = j + 2;\n        this.indices[i + 5] = j + 3;\n    }\n\n    this.shaders = {};\n\n    /**\n     * The current lights in the batch.\n     *\n     * @member {Light[]}\n     */\n    this.lights = [];\n}\n\nLightRenderer.MAX_LIGHTS = 500;\n\nLightRenderer.prototype = Object.create(PIXI.ObjectRenderer.prototype);\nLightRenderer.prototype.constructor = LightRenderer;\nmodule.exports = LightRenderer;\n\nPIXI.WebGLRenderer.registerPlugin('lights', LightRenderer);\n\nLightRenderer.prototype.onContextChange = function () {\n    this.gl = this.renderer.gl;\n    for (var key in main.plugins) {\n        this.shaders[key] = new (main.plugins[key])(this.gl);\n    }\n};\n\n/**\n * Renders the light object.\n *\n * @param light {Light} the light to render\n */\nLightRenderer.prototype.render = function (mesh) {\n    var renderer = this.renderer;\n    var gl = renderer.gl;\n\n    this.lights.push(mesh);\n    /**\n     * Prepares all the buffers to render this light.\n     */\n    var glData = mesh._glDatas[renderer.CONTEXT_UID];\n\n    if (!glData) {\n        renderer.bindVao(null);\n\n        glData = {\n            shader: this.shaders[mesh.shaderName],\n            vertexBuffer: glCore.GLBuffer.createVertexBuffer(gl, mesh.vertices, gl.STREAM_DRAW),\n            indexBuffer: glCore.GLBuffer.createIndexBuffer(gl, mesh.indices, gl.STATIC_DRAW),\n            // build the vao object that will render..\n            vao: null,\n            dirty: mesh.dirty\n        };\n\n        // build the vao object that will render..\n        glData.vao = new glCore.VertexArrayObject(gl)\n            .addIndex(glData.indexBuffer)\n            .addAttribute(glData.vertexBuffer, glData.shader.attributes.aVertexPosition, gl.FLOAT, false, 2 * 4, 0)\n\n        mesh._glDatas[renderer.CONTEXT_UID] = glData;\n    }\n\n    renderer.bindVao(glData.vao);\n\n    if (mesh.useViewportQuad) {\n        mesh.vertices[2] = mesh.vertices[4] = renderer.screen.width;\n        mesh.vertices[5] = mesh.vertices[7] = renderer.screen.height;\n    }\n    glData.vertexBuffer.upload(mesh.vertices);\n\n    if (glData.dirty !== mesh.dirty) {\n        glData.dirty = mesh.dirty;\n        glData.indexBuffer.upload(mesh.indices);\n    }\n};\n\nLightRenderer.prototype.flush = function () {\n    var diffuseTexture = null,\n        normalTexture = null,\n        lastLayer = null,\n        lastShader = null,\n        renderer = this.renderer;\n\n    for (var i = 0; i < this.lights.length; ++i) {\n        var light = this.lights[i],\n            layer = this.lights[i]._activeParentLayer;\n\n        if (!layer) {\n            continue;\n        }\n\n        if (lastLayer !== layer) {\n            lastLayer = layer;\n            var stage = layer._activeStageParent;\n\n            if (layer.diffuseTexture &&\n                layer.normalTexture) {\n                diffuseTexture = layer.diffuseTexture;\n                normalTexture = layer.normalTexture;\n            } else {\n                for (var j = 0; j < stage._activeLayers.length; j++) {\n                    var texLayer = stage._activeLayers[j];\n                    if (texLayer.group === main.normalGroup) {\n                        normalTexture = texLayer.getRenderTexture();\n                    }\n                    if (texLayer.group === main.diffuseGroup) {\n                        diffuseTexture = texLayer.getRenderTexture();\n                    }\n                }\n            }\n\n            renderer.bindTexture(diffuseTexture, 0, true);\n            renderer.bindTexture(normalTexture, 1, true);\n        }\n\n        var glData = light._glDatas[renderer.CONTEXT_UID],\n            shader = glData.shader;\n\n        if (lastShader !== shader) {\n            lastShader = shader;\n            renderer.bindShader(shader);\n\n            shader.uniforms.uSampler = 0;\n            shader.uniforms.uNormalSampler = 1;\n\n            var uViewSize = shader.uniforms.uViewSize;\n            uViewSize[0] = renderer.screen.width;\n            uViewSize[1] = renderer.screen.height;\n            shader.uniforms.uViewSize = uViewSize;\n        }\n\n        renderer.bindVao(glData.vao);\n\n        light.syncShader(shader);\n        renderer.state.setBlendMode(light.blendMode);\n        shader.uniforms.translationMatrix = light.worldTransform.toArray(true);\n\n        glData.vao.draw(light.drawMode, light.indices.length, 0);\n    }\n\n    this.lights.length = 0;\n};\n\nLightRenderer.prototype.stop = function() {\n    this.flush();\n};\n\n},{\"../main\":11}],13:[function(require,module,exports){\n/**\r\n * Creates vertices and indices arrays to describe this circle.\r\n * \r\n * @param [totalSegments=40] {number} Total segments to build for the circle mesh.\r\n * @param [verticesOutput] {Float32Array} An array to output the vertices into. Length must be\r\n *  `((totalSegments + 2) * 2)` or more. If not passed it is created for you.\r\n * @param [indicesOutput] {Uint16Array} An array to output the indices into, in gl.TRIANGLE_FAN format. Length must\r\n *  be `(totalSegments + 3)` or more. If not passed it is created for you.\r\n */\r\nPIXI.Circle.prototype.getMesh = function (totalSegments, vertices, indices)\r\n{\r\n    totalSegments = totalSegments || 40;\r\n\r\n    vertices = vertices || new Float32Array((totalSegments + 1) * 2);\r\n    indices = indices || new Uint16Array(totalSegments + 1);\r\n\r\n    var seg = (Math.PI * 2) / totalSegments,\r\n        indicesIndex = -1;\r\n\r\n    indices[++indicesIndex] = indicesIndex;\r\n\r\n    for (var i = 0; i <= totalSegments; ++i)\r\n    {\r\n        var index = i*2;\r\n        var angle = seg * i;\r\n\r\n        vertices[index] = Math.cos(angle) * this.radius;\r\n        vertices[index+1] = Math.sin(angle) * this.radius;\r\n\r\n        indices[++indicesIndex] = indicesIndex;\r\n    }\r\n\r\n    indices[indicesIndex] = 1;\r\n\r\n    return {\r\n        vertices: vertices,\r\n        indices: indices\r\n    };\r\n};\r\n\n},{}]},{},[1])\n\n","var main = require('../main');\n\n\n/**\n * @class\n * @extends PIXI.Shader\n * @memberof PIXI.lights\n * @param shaderManager {ShaderManager} The WebGL shader manager this shader works for.\n */\nfunction WireframeShader(gl) {\n    PIXI.Shader.call(this,\n        gl,\n        // vertex shader\n        [\n            'attribute vec2 aVertexPosition;',\n            'uniform mat3 projectionMatrix;',\n\n            'void main(void) {',\n            '    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);',\n            '}'\n        ].join('\\n'),\n        // fragment shader\n        [\n            'void main() {',\n            '    gl_FragColor = vec4(0, 0, 0, 1);',\n            '}'\n        ].join('\\n'),\n        /*// uniforms\n        {\n            translationMatrix:  { type: 'mat3', value: new Float32Array(9) },\n            projectionMatrix:   { type: 'mat3', value: new Float32Array(9) }\n        },*/\n        // attributes\n        {\n            aVertexPosition: 0\n        }\n    );\n}\n\nWireframeShader.prototype = Object.create(PIXI.Shader.prototype);\nWireframeShader.prototype.constructor = WireframeShader;\nmodule.exports = WireframeShader;\n\nmain.registerPlugin('wireframeShader', WireframeShader);\n","var Light = require('../light/Light');\n\n/**\n * @class\n * @extends PIXI.lights.Light\n * @memberof PIXI.lights\n *\n * @param [color=0xFFFFFF] {number} The color of the light.\n * @param [brightness=0.5] {number} The brightness of the light.\n */\nfunction AmbientLight(color, brightness) {\n    // ambient light is drawn using a full-screen quad\n    Light.call(this, color, brightness);\n\n    this.shaderName = 'ambientLightShader';\n}\n\nAmbientLight.prototype = Object.create(Light.prototype);\nAmbientLight.prototype.constructor = AmbientLight;\nmodule.exports = AmbientLight;\n","var main = require('../../main');\r\nvar LightShader = require('../light/LightShader');\r\n\r\n\r\n/**\r\n * @class\r\n * @extends PIXI.Shader\r\n * @memberof PIXI.lights\r\n * @param shaderManager {ShaderManager} The WebGL shader manager this shader works for.\r\n */\r\nfunction AmbientLightShader(gl) {\r\n    LightShader.call(this,\r\n        gl,\r\n        // vertex shader\r\n        null,\r\n        // fragment shader\r\n        \"precision highp float;\\n#define GLSLIFY 1\\n\\nuniform sampler2D uSampler;\\nuniform sampler2D uNormalSampler;\\n\\nuniform mat3 translationMatrix;\\n\\nuniform vec2 uViewSize;     // size of the viewport\\n\\nuniform vec4 uLightColor;   // light color, alpha channel used for intensity.\\nuniform vec3 uLightFalloff; // light attenuation coefficients (constant, linear, quadratic)\\nuniform float uLightHeight; // light height above the viewport\\n\\n\\nvoid main(void)\\n{\\nvec2 texCoord = gl_FragCoord.xy / uViewSize;\\ntexCoord.y = 1.0 - texCoord.y; // FBOs positions are flipped.\\n\\nvec4 normalColor = texture2D(uNormalSampler, texCoord);\\nnormalColor.g = 1.0 - normalColor.g; // Green layer is flipped Y coords.\\n\\n// bail out early when normal has no data\\nif (normalColor.a == 0.0) discard;\\n\\n\\n    // simplified lambert shading that makes assumptions for ambient color\\n\\n    // compute Distance\\n    float D = 1.0;\\n\\n    // normalize vectors\\n    vec3 N = normalize(normalColor.xyz * 2.0 - 1.0);\\n    vec3 L = vec3(1.0, 1.0, 1.0);\\n\\n    // pre-multiply light color with intensity\\n    // then perform \\\"N dot L\\\" to determine our diffuse\\n    vec3 diffuse = (uLightColor.rgb * uLightColor.a) * max(dot(N, L), 0.0);\\n\\n    vec4 diffuseColor = texture2D(uSampler, texCoord);\\n    vec3 finalColor = diffuseColor.rgb * diffuse;\\n\\n    gl_FragColor = vec4(finalColor, diffuseColor.a);\\n}\\n\"\r\n    );\r\n}\r\n\r\nAmbientLightShader.prototype = Object.create(LightShader.prototype);\r\nAmbientLightShader.prototype.constructor = AmbientLightShader;\r\nmodule.exports = AmbientLightShader;\r\n\r\nmain.registerPlugin('ambientLightShader', AmbientLightShader);\r\n","var Light = require('../light/Light');\n\n/**\n * @class\n * @extends PIXI.lights.Light\n * @memberof PIXI.lights\n *\n * @param [color=0xFFFFFF] {number} The color of the light.\n * @param [brightness=1] {number} The intensity of the light.\n * @param [target] {PIXI.DisplayObject|PIXI.Point} The object in the scene to target.\n */\nfunction DirectionalLight(color, brightness, target) {\n    Light.call(this, color, brightness);\n\n    this.target = target;\n    this._directionVector = new PIXI.Point();\n\n    this._updateTransform = Light.prototype.updateTransform;\n    this._syncShader = Light.prototype.syncShader;\n\n    this.shaderName = 'directionalLightShader';\n}\n\nDirectionalLight.prototype = Object.create(Light.prototype);\nDirectionalLight.prototype.constructor = DirectionalLight;\nmodule.exports = DirectionalLight;\n\nDirectionalLight.prototype.updateTransform = function () {\n    this.containerUpdateTransform();\n\n    var vec = this._directionVector,\n        wt = this.worldTransform,\n        tx = this.target.worldTransform ? this.target.worldTransform.tx : this.target.x,\n        ty = this.target.worldTransform ? this.target.worldTransform.ty : this.target.y;\n\n    // calculate direction from this light to the target\n    vec.x = wt.tx - tx;\n    vec.y = wt.ty - ty;\n\n    // normalize\n    var len = Math.sqrt(vec.x * vec.x + vec.y * vec.y);\n    vec.x /= len;\n    vec.y /= len;\n};\n\nDirectionalLight.prototype.syncShader = function (shader) {\n    this._syncShader(shader);\n\n    var uLightDirection = shader.uniforms.uLightDirection;\n    uLightDirection[0] = this._directionVector.x;\n    uLightDirection[1] = this._directionVector.y;\n    shader.uniforms.uLightDirection = uLightDirection;\n};\n","var main = require('../../main');\nvar LightShader = require('../light/LightShader');\n\n\n/**\n * @class\n * @extends PIXI.Shader\n * @memberof PIXI.lights\n * @param shaderManager {ShaderManager} The WebGL shader manager this shader works for.\n */\nfunction DirectionalLightShader(gl) {\n    LightShader.call(this,\n        gl,\n        // vertex shader\n        null,\n        // fragment shader\n        \"precision highp float;\\n#define GLSLIFY 1\\n\\n// imports the common uniforms like samplers, and ambient/light color\\nuniform sampler2D uSampler;\\nuniform sampler2D uNormalSampler;\\n\\nuniform mat3 translationMatrix;\\n\\nuniform vec2 uViewSize;     // size of the viewport\\n\\nuniform vec4 uLightColor;   // light color, alpha channel used for intensity.\\nuniform vec3 uLightFalloff; // light attenuation coefficients (constant, linear, quadratic)\\nuniform float uLightHeight; // light height above the viewport\\n\\n\\nuniform vec2 uLightDirection;\\n\\nvoid main()\\n{\\nvec2 texCoord = gl_FragCoord.xy / uViewSize;\\ntexCoord.y = 1.0 - texCoord.y; // FBOs positions are flipped.\\n\\nvec4 normalColor = texture2D(uNormalSampler, texCoord);\\nnormalColor.g = 1.0 - normalColor.g; // Green layer is flipped Y coords.\\n\\n// bail out early when normal has no data\\nif (normalColor.a == 0.0) discard;\\n\\n\\n    // the directional vector of the light\\n    vec3 lightVector = vec3(uLightDirection, uLightHeight);\\n\\n    // compute Distance\\n    float D = length(lightVector);\\n\\n// normalize vectors\\nvec3 N = normalize(normalColor.xyz * 2.0 - 1.0);\\nvec3 L = normalize(lightVector);\\n\\n// pre-multiply light color with intensity\\n// then perform \\\"N dot L\\\" to determine our diffuse\\nvec3 diffuse = (uLightColor.rgb * uLightColor.a) * max(dot(N, L), 0.0);\\n\\n\\n    // calculate attenuation\\n    float attenuation = 1.0;\\n\\n// calculate final intesity and color, then combine\\nvec3 intensity = diffuse * attenuation;\\nvec4 diffuseColor = texture2D(uSampler, texCoord);\\nvec3 finalColor = diffuseColor.rgb * intensity;\\n\\ngl_FragColor = vec4(finalColor, diffuseColor.a);\\n\\n}\\n\",\n        // custom uniforms\n        {\n            // the directional vector of the light\n            uLightDirection: { type: '2f', value: new Float32Array(2) }\n        }\n    );\n}\n\nDirectionalLightShader.prototype = Object.create(LightShader.prototype);\nDirectionalLightShader.prototype.constructor = DirectionalLightShader;\nmodule.exports = DirectionalLightShader;\n\nmain.registerPlugin('directionalLightShader', DirectionalLightShader);\n","/**\n * Excuse the mess, haven't cleaned this up yet!\n */\n\nvar main = require('../../main');\n\n/**\n * @class\n * @extends PIXI.DisplayObject\n * @memberof PIXI.lights\n *\n * @param [color=0xFFFFFF] {number} The color of the light.\n * @param [brightness=1] {number} The brightness of the light, in range [0, 1].\n */\nfunction Light(color, brightness, vertices, indices) {\n    if (this.constructor === Light) {\n        throw new Error('Light is an abstract base class, it should not be created directly!');\n    }\n\n    PIXI.Container.call(this);\n\n    /**\n     * An array of vertices\n     *\n     * @member {Float32Array}\n     */\n    this.vertices = vertices || new Float32Array(8);\n\n    /**\n     * An array containing the indices of the vertices\n     *\n     * @member {Uint16Array}\n     */\n    this.indices = indices || new Uint16Array([0,1,2, 0,2,3]);\n\n    /**\n     * The blend mode to be applied to the light.\n     *\n     * @member {number}\n     * @default CONST.BLEND_MODES.ADD;\n     */\n    this.blendMode = PIXI.BLEND_MODES.ADD;\n\n    /**\n     * The draw mode to be applied to the light geometry.\n     *\n     * @member {number}\n     * @default CONST.DRAW_MODES.TRIANGLES;\n     */\n    this.drawMode = PIXI.DRAW_MODES.TRIANGLES;\n\n    /**\n     * When incremented the renderer will re-upload indices\n     *\n     * @member {number}\n     */\n    this.dirty = 0;\n\n    /**\n     * The height of the light from the viewport.\n     *\n     * @member {number}\n     * @default 0.075\n     */\n    this.lightHeight = 0.075;\n\n    /**\n     * The falloff attenuation coeficients.\n     *\n     * @member {number[]}\n     * @default [0.75, 3, 20]\n     */\n    this.falloff = [0.75, 3, 20];\n\n    /**\n     * The name of the shader plugin to use.\n     *\n     * @member {string}\n     */\n    this.shaderName = null;\n\n    /**\n     * By default the light uses a viewport sized quad as the mesh.\n     */\n    this.useViewportQuad = true;\n\n    // color and brightness are exposed through setters\n    this._color = 0x4d4d59;\n    this._colorRgba = [0.3, 0.3, 0.35, 0.8];\n\n    // run the color setter\n    if (color || color === 0) {\n        this.color = color;\n    }\n\n    // run the brightness setter\n    if (brightness || brightness === 0) {\n        this.brightness = brightness;\n    }\n\n    this.parentGroup = main.lightGroup;\n\n\n    /**\n     * WebGL data for this light\n     * @member {Object}\n     * @private\n     */\n    this._glDatas = {};\n\n    this.shaderName = 'lights';\n}\n\nLight.prototype = Object.create(PIXI.Container.prototype);\nLight.prototype.constructor = Light;\nmodule.exports = Light;\n\nObject.defineProperties(Light.prototype, {\n    /**\n     * The color of the lighting.\n     *\n     * @member {number}\n     * @memberof Light#\n     */\n    color: {\n        get: function ()\n        {\n            return this._color;\n        },\n        set: function (val)\n        {\n            this._color = val;\n            PIXI.utils.hex2rgb(val, this._colorRgba);\n        }\n    },\n\n    /**\n     * The brightness of this lighting. Normalized in the range [0, 1].\n     *\n     * @member {number}\n     * @memberof Light#\n     */\n    brightness: {\n        get: function ()\n        {\n            return this._colorRgba[3];\n        },\n        set: function (val)\n        {\n            this._colorRgba[3] = val;\n        }\n    }\n});\n\nLight.prototype.syncShader = function (shader) {\n    shader.uniforms.uUseViewportQuad = this.useViewportQuad;\n\n    var uLightColor = shader.uniforms.uLightColor;\n    if (uLightColor) {\n        uLightColor[0] = this._colorRgba[0];\n        uLightColor[1] = this._colorRgba[1];\n        uLightColor[2] = this._colorRgba[2];\n        uLightColor[3] = this._colorRgba[3];\n        shader.uniforms.uLightColor = uLightColor;\n    }\n\n    shader.uniforms.uLightHeight = this.lightHeight;\n\n    var uLightFalloff = shader.uniforms.uLightFalloff;\n    if (uLightFalloff) {\n        uLightFalloff[0] = this.falloff[0];\n        uLightFalloff[1] = this.falloff[1];\n        uLightFalloff[2] = this.falloff[2];\n        shader.uniforms.uLightFalloff = uLightFalloff;\n    }\n};\n\nLight.prototype._renderWebGL = function (renderer)\n{\n    renderer.setObjectRenderer(renderer.plugins.lights);\n    renderer.plugins.lights.render(this);\n};\n","\r\n\r\n/**\r\n * @class\r\n * @extends PIXI.Shader\r\n * @memberof PIXI.lights\r\n * @param shaderManager {ShaderManager} The WebGL shader manager this shader works for.\r\n */\r\nfunction LightShader(gl, vertexSrc, fragmentSrc, customUniforms, customAttributes) {\r\n    var uniforms = {\r\n        translationMatrix:  { type: 'mat3', value: new Float32Array(9) },\r\n        projectionMatrix:   { type: 'mat3', value: new Float32Array(9) },\r\n\r\n        // textures from the previously rendered FBOs\r\n        uSampler:       { type: 'sampler2D', value: null },\r\n        uNormalSampler: { type: 'sampler2D', value: null },\r\n\r\n        // should we apply the translation matrix or not.\r\n        uUseViewportQuad: { type: 'bool', value: true },\r\n\r\n        // size of the renderer viewport\r\n        uViewSize:      { type: '2f', value: new Float32Array(2) },\r\n\r\n        // light color, alpha channel used for intensity.\r\n        uLightColor:    { type: '4f', value: new Float32Array([1, 1, 1, 1]) },\r\n\r\n        // light falloff attenuation coefficients\r\n        uLightFalloff:  { type: '3f', value: new Float32Array([0, 0, 0]) },\r\n\r\n        // height of the light above the viewport\r\n        uLightHeight: { type: '1f', value: 0.075 }\r\n    };\r\n\r\n    if (customUniforms)\r\n    {\r\n        for (var u in customUniforms)\r\n        {\r\n            uniforms[u] = customUniforms[u];\r\n        }\r\n    }\r\n\r\n    var attributes = {\r\n        aVertexPosition: 0\r\n    };\r\n\r\n    if (customAttributes)\r\n    {\r\n        for (var a in customAttributes)\r\n        {\r\n            attributes[a] = customAttributes[a];\r\n        }\r\n    }\r\n\r\n    PIXI.Shader.call(this, gl, vertexSrc || LightShader.defaultVertexSrc, fragmentSrc, attributes);\r\n}\r\n\r\nLightShader.prototype = Object.create(PIXI.Shader.prototype);\r\nLightShader.prototype.constructor = LightShader;\r\nmodule.exports = LightShader;\r\n\r\nLightShader.defaultVertexSrc = \"#define GLSLIFY 1\\nattribute vec2 aVertexPosition;\\n\\nuniform bool uUseViewportQuad;\\nuniform mat3 translationMatrix;\\nuniform mat3 projectionMatrix;\\n\\nvoid main(void) {\\n    if (uUseViewportQuad) {\\n        gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\\n    }\\n    else\\n    {\\n        gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\\n    }\\n}\\n\";\r\n","var Light = require('../light/Light');\n\n/**\n * @class\n * @extends PIXI.lights.Light\n * @memberof PIXI.lights\n *\n * @param [color=0xFFFFFF] {number} The color of the light.\n * @param [brightness=1] {number} The intensity of the light.\n * @param [radius=Infinity] {number} The distance the light reaches. You will likely need\n *  to change the falloff of the light as well if you change this value. Infinity will\n *  use the entire viewport as the drawing surface.\n */\nfunction PointLight(color, brightness, radius) {\n    radius = radius || Infinity;\n\n    if (radius !== Infinity) {\n        var shape = new PIXI.Circle(0, 0, radius),\n            mesh = shape.getMesh();\n\n        Light.call(this, color, brightness, mesh.vertices, mesh.indices);\n\n        this.useViewportQuad = false;\n        this.drawMode = PIXI.DRAW_MODES.TRIANGLE_FAN;\n    }\n    else {\n        Light.call(this, color, brightness);\n    }\n\n    this._syncShader = Light.prototype.syncShader;\n\n    this.radius = radius;\n    this.shaderName = 'pointLightShader';\n}\n\nPointLight.prototype = Object.create(Light.prototype);\nPointLight.prototype.constructor = PointLight;\nmodule.exports = PointLight;\n\nPointLight.prototype.syncShader = function (shader) {\n    this._syncShader(shader);\n\n    shader.uniforms.uLightRadius = this.radius;\n}\n","var main = require('../../main');\r\nvar LightShader = require('../light/LightShader');\r\n\r\n\r\n/**\r\n * @class\r\n * @extends PIXI.Shader\r\n * @memberof PIXI.lights\r\n * @param shaderManager {ShaderManager} The WebGL shader manager this shader works for.\r\n */\r\nfunction PointLightShader(gl) {\r\n    LightShader.call(this,\r\n        gl,\r\n        // vertex shader\r\n        null,\r\n        // fragment shader\r\n        \"precision highp float;\\n#define GLSLIFY 1\\n\\n// imports the common uniforms like samplers, and ambient color\\nuniform sampler2D uSampler;\\nuniform sampler2D uNormalSampler;\\n\\nuniform mat3 translationMatrix;\\n\\nuniform vec2 uViewSize;     // size of the viewport\\n\\nuniform vec4 uLightColor;   // light color, alpha channel used for intensity.\\nuniform vec3 uLightFalloff; // light attenuation coefficients (constant, linear, quadratic)\\nuniform float uLightHeight; // light height above the viewport\\n\\n\\nuniform float uLightRadius;\\n\\nvoid main()\\n{\\nvec2 texCoord = gl_FragCoord.xy / uViewSize;\\ntexCoord.y = 1.0 - texCoord.y; // FBOs positions are flipped.\\n\\nvec4 normalColor = texture2D(uNormalSampler, texCoord);\\nnormalColor.g = 1.0 - normalColor.g; // Green layer is flipped Y coords.\\n\\n// bail out early when normal has no data\\nif (normalColor.a == 0.0) discard;\\n\\n\\n    vec2 lightPosition = translationMatrix[2].xy / uViewSize;\\n\\n    // the directional vector of the light\\n    vec3 lightVector = vec3(lightPosition - texCoord, uLightHeight);\\n\\n    // correct for aspect ratio\\n    lightVector.x *= uViewSize.x / uViewSize.y;\\n\\n    // compute Distance\\n    float D = length(lightVector);\\n\\n    // bail out early when pixel outside of light sphere\\n    if (D > uLightRadius) discard;\\n\\n// normalize vectors\\nvec3 N = normalize(normalColor.xyz * 2.0 - 1.0);\\nvec3 L = normalize(lightVector);\\n\\n// pre-multiply light color with intensity\\n// then perform \\\"N dot L\\\" to determine our diffuse\\nvec3 diffuse = (uLightColor.rgb * uLightColor.a) * max(dot(N, L), 0.0);\\n\\n\\n    // calculate attenuation\\n    float attenuation = 1.0 / (uLightFalloff.x + (uLightFalloff.y * D) + (uLightFalloff.z * D * D));\\n\\n// calculate final intesity and color, then combine\\nvec3 intensity = diffuse * attenuation;\\nvec4 diffuseColor = texture2D(uSampler, texCoord);\\nvec3 finalColor = diffuseColor.rgb * intensity;\\n\\ngl_FragColor = vec4(finalColor, diffuseColor.a);\\n\\n}\\n\",\r\n        // custom uniforms\r\n        {\r\n            // height of the light above the viewport\r\n            uLightRadius:   { type: '1f', value: 1 }\r\n        }\r\n    );\r\n}\r\n\r\nPointLightShader.prototype = Object.create(LightShader.prototype);\r\nPointLightShader.prototype.constructor = PointLightShader;\r\nmodule.exports = PointLightShader;\r\n\r\nmain.registerPlugin('pointLightShader', PointLightShader);\r\n","module.exports = {\n    plugins: {},\n    registerPlugin: function(name, fun) {\n        this.plugins[name] = fun;\n    },\n    diffuseGroup: new PIXI.display.Group(),\n    normalGroup: new PIXI.display.Group(),\n    lightGroup: new PIXI.display.Group()\n};\n\nmodule.exports.diffuseGroup.useRenderTexture = true;\nmodule.exports.normalGroup.useRenderTexture = true;\n","var main = require('../main');\nvar glCore = PIXI.glCore;\n\n/**\n *\n * @class\n * @private\n * @memberof PIXI.lights\n * @extends PIXI.ObjectRenderer\n * @param renderer {WebGLRenderer} The renderer this sprite batch works for.\n */\nfunction LightRenderer(renderer) {\n    PIXI.ObjectRenderer.call(this, renderer);\n\n    // the total number of indices in our batch, there are 6 points per quad.\n    var numIndices = LightRenderer.MAX_LIGHTS * 6;\n\n    /**\n     * Holds the indices\n     *\n     * @member {Uint16Array}\n     */\n    this.indices = new Uint16Array(numIndices);\n\n    //TODO this could be a single buffer shared amongst all renderers as we reuse this set up in most renderers\n    for (var i = 0, j = 0; i < numIndices; i += 6, j += 4) {\n        this.indices[i + 0] = j + 0;\n        this.indices[i + 1] = j + 1;\n        this.indices[i + 2] = j + 2;\n        this.indices[i + 3] = j + 0;\n        this.indices[i + 4] = j + 2;\n        this.indices[i + 5] = j + 3;\n    }\n\n    this.shaders = {};\n\n    /**\n     * The current lights in the batch.\n     *\n     * @member {Light[]}\n     */\n    this.lights = [];\n}\n\nLightRenderer.MAX_LIGHTS = 500;\n\nLightRenderer.prototype = Object.create(PIXI.ObjectRenderer.prototype);\nLightRenderer.prototype.constructor = LightRenderer;\nmodule.exports = LightRenderer;\n\nPIXI.WebGLRenderer.registerPlugin('lights', LightRenderer);\n\nLightRenderer.prototype.onContextChange = function () {\n    this.gl = this.renderer.gl;\n    for (var key in main.plugins) {\n        this.shaders[key] = new (main.plugins[key])(this.gl);\n    }\n};\n\n/**\n * Renders the light object.\n *\n * @param light {Light} the light to render\n */\nLightRenderer.prototype.render = function (mesh) {\n    var renderer = this.renderer;\n    var gl = renderer.gl;\n\n    this.lights.push(mesh);\n    /**\n     * Prepares all the buffers to render this light.\n     */\n    var glData = mesh._glDatas[renderer.CONTEXT_UID];\n\n    if (!glData) {\n        renderer.bindVao(null);\n\n        glData = {\n            shader: this.shaders[mesh.shaderName],\n            vertexBuffer: glCore.GLBuffer.createVertexBuffer(gl, mesh.vertices, gl.STREAM_DRAW),\n            indexBuffer: glCore.GLBuffer.createIndexBuffer(gl, mesh.indices, gl.STATIC_DRAW),\n            // build the vao object that will render..\n            vao: null,\n            dirty: mesh.dirty\n        };\n\n        // build the vao object that will render..\n        glData.vao = new glCore.VertexArrayObject(gl)\n            .addIndex(glData.indexBuffer)\n            .addAttribute(glData.vertexBuffer, glData.shader.attributes.aVertexPosition, gl.FLOAT, false, 2 * 4, 0)\n\n        mesh._glDatas[renderer.CONTEXT_UID] = glData;\n    }\n\n    renderer.bindVao(glData.vao);\n\n    if (mesh.useViewportQuad) {\n        mesh.vertices[2] = mesh.vertices[4] = renderer.screen.width;\n        mesh.vertices[5] = mesh.vertices[7] = renderer.screen.height;\n    }\n    glData.vertexBuffer.upload(mesh.vertices);\n\n    if (glData.dirty !== mesh.dirty) {\n        glData.dirty = mesh.dirty;\n        glData.indexBuffer.upload(mesh.indices);\n    }\n};\n\nLightRenderer.prototype.flush = function () {\n    var diffuseTexture = null,\n        normalTexture = null,\n        lastLayer = null,\n        lastShader = null,\n        renderer = this.renderer;\n\n    for (var i = 0; i < this.lights.length; ++i) {\n        var light = this.lights[i],\n            layer = this.lights[i]._activeParentLayer;\n\n        if (!layer) {\n            continue;\n        }\n\n        if (lastLayer !== layer) {\n            lastLayer = layer;\n            var stage = layer._activeStageParent;\n\n            if (layer.diffuseTexture &&\n                layer.normalTexture) {\n                diffuseTexture = layer.diffuseTexture;\n                normalTexture = layer.normalTexture;\n            } else {\n                for (var j = 0; j < stage._activeLayers.length; j++) {\n                    var texLayer = stage._activeLayers[j];\n                    if (texLayer.group === main.normalGroup) {\n                        normalTexture = texLayer.getRenderTexture();\n                    }\n                    if (texLayer.group === main.diffuseGroup) {\n                        diffuseTexture = texLayer.getRenderTexture();\n                    }\n                }\n            }\n\n            renderer.bindTexture(diffuseTexture, 0, true);\n            renderer.bindTexture(normalTexture, 1, true);\n        }\n\n        var glData = light._glDatas[renderer.CONTEXT_UID],\n            shader = glData.shader;\n\n        if (lastShader !== shader) {\n            lastShader = shader;\n            renderer.bindShader(shader);\n\n            shader.uniforms.uSampler = 0;\n            shader.uniforms.uNormalSampler = 1;\n\n            var uViewSize = shader.uniforms.uViewSize;\n            uViewSize[0] = renderer.screen.width;\n            uViewSize[1] = renderer.screen.height;\n            shader.uniforms.uViewSize = uViewSize;\n        }\n\n        renderer.bindVao(glData.vao);\n\n        light.syncShader(shader);\n        renderer.state.setBlendMode(light.blendMode);\n        shader.uniforms.translationMatrix = light.worldTransform.toArray(true);\n\n        glData.vao.draw(light.drawMode, light.indices.length, 0);\n    }\n\n    this.lights.length = 0;\n};\n\nLightRenderer.prototype.stop = function() {\n    this.flush();\n};\n","/**\r\n * Creates vertices and indices arrays to describe this circle.\r\n * \r\n * @param [totalSegments=40] {number} Total segments to build for the circle mesh.\r\n * @param [verticesOutput] {Float32Array} An array to output the vertices into. Length must be\r\n *  `((totalSegments + 2) * 2)` or more. If not passed it is created for you.\r\n * @param [indicesOutput] {Uint16Array} An array to output the indices into, in gl.TRIANGLE_FAN format. Length must\r\n *  be `(totalSegments + 3)` or more. If not passed it is created for you.\r\n */\r\nPIXI.Circle.prototype.getMesh = function (totalSegments, vertices, indices)\r\n{\r\n    totalSegments = totalSegments || 40;\r\n\r\n    vertices = vertices || new Float32Array((totalSegments + 1) * 2);\r\n    indices = indices || new Uint16Array(totalSegments + 1);\r\n\r\n    var seg = (Math.PI * 2) / totalSegments,\r\n        indicesIndex = -1;\r\n\r\n    indices[++indicesIndex] = indicesIndex;\r\n\r\n    for (var i = 0; i <= totalSegments; ++i)\r\n    {\r\n        var index = i*2;\r\n        var angle = seg * i;\r\n\r\n        vertices[index] = Math.cos(angle) * this.radius;\r\n        vertices[index+1] = Math.sin(angle) * this.radius;\r\n\r\n        indices[++indicesIndex] = indicesIndex;\r\n    }\r\n\r\n    indices[indicesIndex] = 1;\r\n\r\n    return {\r\n        vertices: vertices,\r\n        indices: indices\r\n    };\r\n};\r\n"],"sourceRoot":"./"}