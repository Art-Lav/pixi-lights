{"version":3,"sources":["node_modules/browserify/node_modules/browser-pack/_prelude.js","src/index","pixi-lights.min.js","src/light_2/lightSpriteMixin.js","src/light_2/lights/Light.js","src/light_2/lights/LightShader.js","src/light_2/lights/point/PointLight.js","src/light_2/lights/point/PointLightShader.js","src/light_2/renderers/LightRenderer.js","src/light_2/renderers/WebGLDeferredRenderer.js"],"names":["e","t","n","r","s","o","u","a","require","i","f","Error","code","l","exports","call","length",1,"module","PIXI","lights","Light","LightShader","PointLight","PointLightShader","LightRenderer","WebGLDeferredRenderer","./light_2/lightSpriteMixin","./light_2/lights/Light","./light_2/lights/LightShader","./light_2/lights/point/PointLight","./light_2/lights/point/PointLightShader","./light_2/renderers/LightRenderer","./light_2/renderers/WebGLDeferredRenderer",2,"Sprite","prototype","_renderWebGL","renderer","this","_originalTexture","_texture","renderingNormals","normalTexture","setObjectRenderer","plugins","sprite","render",3,"color","vertices","indices","constructor","DisplayObject","uvs","Float32Array","Uint16Array","blendMode","BLEND_MODES","NORMAL","_vertexBuffer","_indexBuffer","_uvBuffer","needsUpdate","_color","_colorRgba","height","falloff","shaderName","Object","create","defineProperties","get","set","val","utils","hex2rgb","renderWebGL","destroy",4,"shaderManager","vertexSrc","fragmentSrc","customUniforms","customAttributes","uniforms","alpha","type","value","translationMatrix","projectionMatrix","uSampler","uNormalSampler","uViewSize","uAmbientColor","uLightColor","uLightFalloff","attributes","aVertexPosition","aTextureCoord","Shader","defaultVertexSrc","defaultFragmentSrc",5,"intensity","distance","decay","../Light",6,"uLightHeight","ShaderManager","registerPlugin","../LightShader",7,"ObjectRenderer","numIndices","MAX_LIGHTS","j","currentBatchSize","WebGLRenderer","light","flush","gl","diffuseTexture","normalsTexture","lastShader","shader","_initWebGL","setShader","blendModeManager","setBlendMode","worldTransform","toArray","currentRenderTarget","worldAlpha","width","_lightAmbientColorRgba","syncUniforms","uniform1i","_location","bindBuffer","ARRAY_BUFFER","bufferData","STATIC_DRAW","vertexAttribPointer","FLOAT","activeTexture","TEXTURE0","bindTexture","TEXTURE_2D","baseTexture","_glTextures","id","TEXTURE1","ELEMENT_ARRAY_BUFFER","bufferSubData","drawElements","TRIANGLES","UNSIGNED_SHORT","createBuffer","DYNAMIC_DRAW",8,"options","_lightAmbientColor","ambientColor","ambientIntensity","_doWebGLRender","assign","_initContext","RenderTexture","resolution","object","setRenderTarget","renderTarget"],"mappings":"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","file":"pixi-lights.min.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","module.exports = PIXI.lights = {\r\n//    LitSprite: require('./light_1/LitSprite'),\r\n//    LightingRenderer: require('./light_1/webgl/LightingRenderer')\r\n\r\n    Light:                  require('./light_2/lights/Light'),\r\n    LightShader:            require('./light_2/lights/LightShader'),\r\n\r\n    PointLight:             require('./light_2/lights/point/PointLight'),\r\n    PointLightShader:       require('./light_2/lights/point/PointLightShader'),\r\n\r\n    LightRenderer:          require('./light_2/renderers/LightRenderer'),\r\n    WebGLDeferredRenderer:  require('./light_2/renderers/WebGLDeferredRenderer')\r\n};\r\n\r\nrequire('./light_2/lightSpriteMixin');\r\n",null,"var tempTexture = null;\r\n\r\n /**\r\n * Renders the object using the WebGL renderer\r\n *\r\n * @param renderer {WebGLRenderer}\r\n * @private\r\n */\r\nPIXI.Sprite.prototype._renderWebGL = function (renderer)\r\n{\r\n    if (!this._originalTexture) {\r\n        this._originalTexture = this._texture;\r\n    }\r\n\r\n    if (renderer.renderingNormals && this.normalTexture)\r\n    {\r\n        this._texture = this.normalTexture;\r\n    }\r\n    else\r\n    {\r\n        this._texture = this._originalTexture;\r\n    }\r\n\r\n    renderer.setObjectRenderer(renderer.plugins.sprite);\r\n    renderer.plugins.sprite.render(this);\r\n};\r\n","/**\r\n * @class\r\n * @extends PIXI.DisplayObject\r\n * @memberof PIXI.lights\r\n *\r\n * @param [color=0xFFFFFF] {number} The color of the light.\r\n */\r\nfunction Light(color, vertices, indices) {\r\n    if (this.constructor === Light) {\r\n        throw new Error('Light is an abstract base and should not be created directly!');\r\n    }\r\n\r\n    PIXI.DisplayObject.call(this);\r\n\r\n    /**\r\n     * The Uvs of the Mesh\r\n     *\r\n     * @member {Float32Array}\r\n     */\r\n    this.uvs = new Float32Array([0,0, 1,0, 1,1, 0,1]);\r\n\r\n    /**\r\n     * An array of vertices\r\n     *\r\n     * @member {Float32Array}\r\n     */\r\n    this.vertices = vertices || new Float32Array([0,   0,\r\n                                                  1024, 0,\r\n                                                  1024, 512,\r\n                                                  0,   512]);\r\n\r\n    /**\r\n     * An array containing the indices of the vertices\r\n     *\r\n     * @member {Uint16Array}\r\n     */\r\n    this.indices = new Uint16Array([0,1,2, 0,2,3]);\r\n\r\n    /**\r\n     * The blend mode to be applied to the sprite. Set to blendModes.NORMAL to remove any blend mode.\r\n     *\r\n     * @member {number}\r\n     * @default CONST.BLEND_MODES.NORMAL;\r\n     */\r\n    this.blendMode = PIXI.BLEND_MODES.NORMAL;\r\n\r\n    this._vertexBuffer = null;\r\n    this._indexBuffer = null;\r\n    this._uvBuffer = null;\r\n\r\n    this.needsUpdate = true;\r\n\r\n    // light stuff...\r\n\r\n    this._color = 0xFFFFFF;\r\n    this._colorRgba = [1, 1, 1, 1];\r\n\r\n    if (color || color === 0) {\r\n        this.color = color;\r\n    }\r\n\r\n    this.height = 0.075;\r\n\r\n    this.falloff = [0.4, 7.0, 40.0];\r\n\r\n    // hack around bug in interaction manager. It dies when processing raw DOs\r\n//    this.children = [];\r\n\r\n    this.shaderName = null;\r\n}\r\n\r\nLight.prototype = Object.create(PIXI.DisplayObject.prototype);\r\nLight.prototype.constructor = Light;\r\nmodule.exports = Light;\r\n\r\nObject.defineProperties(Light.prototype, {\r\n    /**\r\n     * The color of lighting\r\n     *\r\n     * @member {number}\r\n     * @memberof Light#\r\n     */\r\n    color: {\r\n        get: function ()\r\n        {\r\n            return this._color;\r\n        },\r\n        set: function (val)\r\n        {\r\n            this._color = val;\r\n            PIXI.utils.hex2rgb(val, this._colorRgba);\r\n        }\r\n    }\r\n});\r\n\r\n/**\r\n * Renders the object using the WebGL renderer\r\n *\r\n * @param renderer {WebGLRenderer}\r\n * @private\r\n */\r\n//Light.prototype.renderWebGL = function (renderer)\r\n//{\r\n//    // I actually don't want to interrupt the current batch, so don't set light as the current object renderer.\r\n//    // light renderer works a bit differently in that ALL lights are in a single batch no matter what.\r\n//\r\n//    // renderer.setObjectRenderer(renderer.plugins.lights);\r\n//\r\n////    if (renderer.renderingNormals) {\r\n////        renderer.plugins.lights.render(this);\r\n//        renderer.lights.push(this);\r\n////    }\r\n//};\r\n\r\nLight.prototype.renderWebGL = function (renderer)\r\n{\r\n    // add lights to their renderer on the normals pass\r\n    if (!renderer.renderingNormals) {\r\n        return;\r\n    }\r\n\r\n//    renderer.setObjectRenderer(renderer.plugins.lights);\r\n    renderer.plugins.lights.render(this);\r\n};\r\n\r\nLight.prototype.destroy = function ()\r\n{\r\n    PIXI.DisplayObject.prototype.destroy.call(this);\r\n\r\n    // TODO: Destroy buffers!\r\n}\r\n","\r\n\r\n/**\r\n * @class\r\n * @extends PIXI.Shader\r\n * @memberof PIXI.lights\r\n * @param shaderManager {ShaderManager} The WebGL shader manager this shader works for.\r\n */\r\nfunction LightShader(shaderManager, vertexSrc, fragmentSrc, customUniforms, customAttributes) {\r\n    var uniforms = {\r\n        alpha:              { type: '1f', value: 0 },\r\n        translationMatrix:  { type: 'mat3', value: new Float32Array(9) },\r\n        projectionMatrix:   { type: 'mat3', value: new Float32Array(9) },\r\n\r\n        // textures from the previously rendered FBOs\r\n        uSampler:       { type: 'sampler2D', value: null },\r\n        uNormalSampler: { type: 'sampler2D', value: null },\r\n\r\n        // size of the renderer viewport\r\n        uViewSize:      { type: '2f', value: new Float32Array(2) },\r\n\r\n        // ambient lighting color, alpha channel used for intensity\r\n        uAmbientColor:  { type: '4f', value: new Float32Array(4) },\r\n\r\n        // light color, alpha channel used for intensity.\r\n        uLightColor:    { type: '4f', value: new Float32Array([1, 1, 1, 1]) },\r\n\r\n        // light falloff attenuation coefficients\r\n        uLightFalloff:  { type: '3f', value: new Float32Array([0, 0, 0]) }\r\n    };\r\n\r\n    if (customUniforms)\r\n    {\r\n        for (var u in customUniforms)\r\n        {\r\n            uniforms[u] = customUniforms[u];\r\n        }\r\n    }\r\n\r\n    var attributes = {\r\n        aVertexPosition: 0,\r\n        aTextureCoord: 0\r\n    };\r\n\r\n    if (customAttributes)\r\n    {\r\n        for (var a in customAttributes)\r\n        {\r\n            attributes[a] = customAttributes[a];\r\n        }\r\n    }\r\n\r\n    PIXI.Shader.call(this, shaderManager, vertexSrc || LightShader.defaultVertexSrc, fragmentSrc || LightShader.defaultFragmentSrc, uniforms, attributes);\r\n}\r\n\r\nLightShader.prototype = Object.create(PIXI.Shader.prototype);\r\nLightShader.prototype.constructor = LightShader;\r\nmodule.exports = LightShader;\r\n\r\nLightShader.defaultVertexSrc = \"#define GLSLIFY 1\\n\\nprecision lowp float;\\r\\n\\r\\nattribute vec2 aVertexPosition;\\r\\nattribute vec2 aTextureCoord;\\r\\n\\r\\nuniform mat3 translationMatrix;\\r\\nuniform mat3 projectionMatrix;\\r\\n\\r\\nvarying vec2 vTextureCoord;\\r\\n\\r\\nvoid main(void) {\\r\\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\\r\\n    vTextureCoord = aTextureCoord;\\r\\n}\\r\\n\";\r\nLightShader.defaultFragmentSrc = \"#define GLSLIFY 1\\n\\nprecision lowp float;\\r\\n\\r\\nvarying vec2 vTextureCoord;\\r\\n\\nuniform sampler2D uSampler;\\r\\nuniform sampler2D uNormalSampler;\\r\\n\\r\\nuniform mat3 translationMatrix;\\r\\n\\r\\nuniform float alpha;\\r\\n\\r\\nuniform vec2 uViewSize;\\r\\n\\r\\nuniform vec4 uAmbientColor; // ambient color, alpha channel used for intensity.\\r\\n\\r\\nuniform vec2 uLightPosition;// light position, normalized to viewport.\\r\\nuniform vec4 uLightColor;   // light color, alpha channel used for intensity.\\r\\nuniform vec3 uLightFalloff; // light falloff attenuation coefficients.\\r\\n\\n\\r\\nvoid main(void){\\r\\n//vec4 diffuseColor = texture2D(uSampler, vTextureCoord);\\r\\n//vec4 normalColor = texture2D(uNormalSampler, vTextureCoord);\\r\\n\\r\\nvec2 texCoord = gl_FragCoord.xy / uViewSize;\\r\\n\\r\\nvec4 diffuseColor = texture2D(uSampler, texCoord);\\r\\nvec4 normalColor = texture2D(uNormalSampler, texCoord);\\r\\n\\r\\n// if no normal color here, just discard\\r\\nif (normalColor.a == 0.0) discard;\\r\\n\\n\\r\\n    gl_FragColor = vec4(mix(diffuseColor.rgb, normalColor.rgb, 0.5), diffuseColor.a);\\r\\n}\\r\\n\";\r\n","var Light = require('../Light');\r\n\r\n/**\r\n * @class\r\n * @extends PIXI.lights.Light\r\n * @memberof PIXI.lights\r\n *\r\n * @param [color=0xFFFFFF] {number} The color of the light.\r\n * @param [intensity=1] {number} The intensity of the light.\r\n * @param [distance=0] {number} The distance the light reaches.\r\n * @param [decay=1] {number} The decay factor of the light. Physically correct lights should be 2.\r\n */\r\nfunction PointLight(color, intensity, distance, decay) {\r\n    Light.call(this, color);\r\n\r\n    this.shaderName = 'pointLightShader';\r\n}\r\n\r\nPointLight.prototype = Object.create(Light.prototype);\r\nPointLight.prototype.constructor = PointLight;\r\nmodule.exports = PointLight;\r\n","var LightShader = require('../LightShader');\r\n\r\n\r\n/**\r\n * @class\r\n * @extends PIXI.Shader\r\n * @memberof PIXI.lights\r\n * @param shaderManager {ShaderManager} The WebGL shader manager this shader works for.\r\n */\r\nfunction PointLightShader(shaderManager) {\r\n    LightShader.call(this,\r\n        shaderManager,\r\n        // vertex shader\r\n        null,\r\n        // fragment shader\r\n        \"#define GLSLIFY 1\\n\\nprecision lowp float;\\r\\n\\r\\n// imports the common uniforms like samplers, and ambient color\\r\\nvarying vec2 vTextureCoord;\\r\\n\\nuniform sampler2D uSampler;\\r\\nuniform sampler2D uNormalSampler;\\r\\n\\r\\nuniform mat3 translationMatrix;\\r\\n\\r\\nuniform float alpha;\\r\\n\\r\\nuniform vec2 uViewSize;\\r\\n\\r\\nuniform vec4 uAmbientColor; // ambient color, alpha channel used for intensity.\\r\\n\\r\\nuniform vec2 uLightPosition;// light position, normalized to viewport.\\r\\nuniform vec4 uLightColor;   // light color, alpha channel used for intensity.\\r\\nuniform vec3 uLightFalloff; // light falloff attenuation coefficients.\\r\\n\\n\\r\\nuniform float uLightHeight;\\r\\n\\r\\nvoid main()\\r\\n{\\r\\n// sets diffuseColor and normalColor from their respective textures\\r\\n//vec4 diffuseColor = texture2D(uSampler, vTextureCoord);\\r\\n//vec4 normalColor = texture2D(uNormalSampler, vTextureCoord);\\r\\n\\r\\nvec2 texCoord = gl_FragCoord.xy / uViewSize;\\r\\n\\r\\nvec4 diffuseColor = texture2D(uSampler, texCoord);\\r\\nvec4 normalColor = texture2D(uNormalSampler, texCoord);\\r\\n\\r\\n// if no normal color here, just discard\\r\\nif (normalColor.a == 0.0) discard;\\r\\n\\n\\r\\n    vec2 lightPosition = translationMatrix[2].xy;\\r\\n\\r\\n    // the directional vector of the light\\r\\n    vec3 lightVector = vec3((lightPosition / uViewSize) - (gl_FragCoord.xy / uViewSize), uLightHeight);\\r\\n\\r\\n    // correct for aspect ratio\\r\\n//    lightVector.x *= uViewSize.x / uViewSize.y;\\r\\n\\r\\n// does lambertian illumination calculations and sets \\\"finalColor\\\"\\r\\n// compute Distance\\r\\nfloat D = length(lightVector);\\r\\n\\r\\n// normalize vectors\\r\\nvec3 N = normalize(normalColor.xyz * 2.0 - 1.0);\\r\\nvec3 L = normalize(lightVector);\\r\\n\\r\\n// pre-multiply light color with intensity\\r\\n// then perform \\\"N dot L\\\" to determine our diffuse\\r\\nvec3 diffuse = (uLightColor.rgb * uLightColor.a) * max(dot(N, L), 0.0);\\r\\n\\r\\n// pre-multiply ambient color with intensity\\r\\nvec3 ambient = uAmbientColor.rgb * uAmbientColor.a;\\r\\n\\r\\n// calculate attenuation\\r\\nfloat attenuation = 1.0 / (uLightFalloff.x + (uLightFalloff.y * D) + (uLightFalloff.z * D * D));\\r\\n\\r\\n// calculate final intesity and color, then combine\\r\\nvec3 intensity = ambient + diffuse * attenuation;\\r\\nvec3 finalColor = diffuseColor.rgb * intensity;\\r\\n\\n\\r\\n    gl_FragColor = vec4(finalColor, diffuseColor.a);\\r\\n}\",\r\n        // custom uniforms\r\n        {\r\n            // height of the light above the viewport\r\n            uLightHeight: { type: '1f', value: 0.075 }\r\n        }\r\n    );\r\n}\r\n\r\nPointLightShader.prototype = Object.create(LightShader.prototype);\r\nPointLightShader.prototype.constructor = PointLightShader;\r\nmodule.exports = PointLightShader;\r\n\r\nPIXI.ShaderManager.registerPlugin('pointLightShader', PointLightShader);\r\n","/**\r\n *\r\n * @class\r\n * @private\r\n * @memberof PIXI.lights\r\n * @extends PIXI.ObjectRenderer\r\n * @param renderer {WebGLRenderer} The renderer this sprite batch works for.\r\n */\r\nfunction LightRenderer(renderer)\r\n{\r\n    PIXI.ObjectRenderer.call(this, renderer);\r\n\r\n    // the total number of indices in our batch, there are 6 points per quad.\r\n    var numIndices = LightRenderer.MAX_LIGHTS * 6;\r\n\r\n    /**\r\n     * Holds the indices\r\n     *\r\n     * @member {Uint16Array}\r\n     */\r\n    this.indices = new Uint16Array(numIndices);\r\n\r\n    //TODO this could be a single buffer shared amongst all renderers as we reuse this set up in most renderers\r\n    for (var i = 0, j = 0; i < numIndices; i += 6, j += 4)\r\n    {\r\n        this.indices[i + 0] = j + 0;\r\n        this.indices[i + 1] = j + 1;\r\n        this.indices[i + 2] = j + 2;\r\n        this.indices[i + 3] = j + 0;\r\n        this.indices[i + 4] = j + 2;\r\n        this.indices[i + 5] = j + 3;\r\n    }\r\n\r\n    /**\r\n     * The current size of the batch, each render() call adds to this number.\r\n     *\r\n     * @member {number}\r\n     */\r\n    this.currentBatchSize = 0;\r\n\r\n    /**\r\n     * The current lights in the batch.\r\n     *\r\n     * @member {Light[]}\r\n     */\r\n    this.lights = [];\r\n}\r\n\r\nLightRenderer.MAX_LIGHTS = 500;\r\n\r\nLightRenderer.prototype = Object.create(PIXI.ObjectRenderer.prototype);\r\nLightRenderer.prototype.constructor = LightRenderer;\r\nmodule.exports = LightRenderer;\r\n\r\nPIXI.WebGLRenderer.registerPlugin('lights', LightRenderer);\r\n\r\n/**\r\n * Renders the light object.\r\n *\r\n * @param light {Light} the light to render\r\n */\r\nLightRenderer.prototype.render = function (light)\r\n{\r\n    this.lights[this.currentBatchSize++] = light;\r\n};\r\n\r\nLightRenderer.prototype.flush = function ()\r\n{\r\n    var renderer = this.renderer,\r\n        gl = renderer.gl,\r\n        diffuseTexture = renderer.diffuseTexture,\r\n        normalsTexture = renderer.normalsTexture,\r\n        lastShader = null;\r\n\r\n    for (var i = 0; i < this.currentBatchSize; ++i)\r\n    {\r\n        var light = this.lights[i],\r\n            shader = light.shader || this.renderer.shaderManager.plugins[light.shaderName];\r\n\r\n        if (!light._vertexBuffer)\r\n        {\r\n            this._initWebGL(light);\r\n        }\r\n\r\n        // set shader if needed\r\n        if (shader !== lastShader) {\r\n            lastShader = shader;\r\n            renderer.shaderManager.setShader(shader);\r\n        }\r\n\r\n        renderer.blendModeManager.setBlendMode(light.blendMode);\r\n\r\n        // set uniforms\r\n        light.worldTransform.toArray(true, shader.uniforms.translationMatrix.value);\r\n        renderer.currentRenderTarget.projectionMatrix.toArray(true, shader.uniforms.projectionMatrix.value);\r\n\r\n        shader.uniforms.alpha.value = light.worldAlpha;\r\n\r\n        shader.uniforms.uViewSize.value[0] = renderer.width;\r\n        shader.uniforms.uViewSize.value[1] = renderer.height;\r\n\r\n        shader.uniforms.uAmbientColor.value[0] = renderer._lightAmbientColorRgba[0];\r\n        shader.uniforms.uAmbientColor.value[1] = renderer._lightAmbientColorRgba[1];\r\n        shader.uniforms.uAmbientColor.value[2] = renderer._lightAmbientColorRgba[2];\r\n        shader.uniforms.uAmbientColor.value[3] = renderer._lightAmbientColorRgba[3];\r\n\r\n        shader.uniforms.uLightColor.value[0] = light._colorRgba[0];\r\n        shader.uniforms.uLightColor.value[1] = light._colorRgba[1];\r\n        shader.uniforms.uLightColor.value[2] = light._colorRgba[2];\r\n        shader.uniforms.uLightColor.value[3] = light._colorRgba[3];\r\n\r\n        shader.uniforms.uLightFalloff.value[0] = light.falloff[0];\r\n        shader.uniforms.uLightFalloff.value[1] = light.falloff[1];\r\n        shader.uniforms.uLightFalloff.value[2] = light.falloff[2];\r\n\r\n        shader.syncUniforms();\r\n\r\n        // have to set these manually due to the way pixi base shader makes assumptions about texture units\r\n        gl.uniform1i(shader.uniforms.uSampler._location, 0);\r\n        gl.uniform1i(shader.uniforms.uNormalSampler._location, 1);\r\n\r\n        if (!light.needsUpdate)\r\n        {\r\n            // update vertex data\r\n            gl.bindBuffer(gl.ARRAY_BUFFER, light._vertexBuffer);\r\n            gl.bufferSubData(gl.ARRAY_BUFFER, 0, light.vertices);\r\n            gl.vertexAttribPointer(shader.attributes.aVertexPosition, 2, gl.FLOAT, false, 0, 0);\r\n\r\n            // update the uvs\r\n            gl.bindBuffer(gl.ARRAY_BUFFER, light._uvBuffer);\r\n            gl.vertexAttribPointer(shader.attributes.aTextureCoord, 2, gl.FLOAT, false, 0, 0);\r\n\r\n            // bind diffuse texture\r\n            gl.activeTexture(gl.TEXTURE0);\r\n            gl.bindTexture(gl.TEXTURE_2D, diffuseTexture.baseTexture._glTextures[gl.id]);\r\n\r\n            // bind normal texture\r\n            gl.activeTexture(gl.TEXTURE1);\r\n            gl.bindTexture(gl.TEXTURE_2D, normalsTexture.baseTexture._glTextures[gl.id]);\r\n\r\n            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, light._indexBuffer);\r\n            gl.bufferSubData(gl.ELEMENT_ARRAY_BUFFER, 0, light.indices);\r\n        }\r\n        else\r\n        {\r\n            light.needsUpdate = false;\r\n\r\n            // upload vertex data\r\n            gl.bindBuffer(gl.ARRAY_BUFFER, light._vertexBuffer);\r\n            gl.bufferData(gl.ARRAY_BUFFER, light.vertices, gl.STATIC_DRAW);\r\n            gl.vertexAttribPointer(shader.attributes.aVertexPosition, 2, gl.FLOAT, false, 0, 0);\r\n\r\n            // upload uv data\r\n            gl.bindBuffer(gl.ARRAY_BUFFER, light._uvBuffer);\r\n            gl.bufferData(gl.ARRAY_BUFFER, light.uvs, gl.STATIC_DRAW);\r\n            gl.vertexAttribPointer(shader.attributes.aTextureCoord, 2, gl.FLOAT, false, 0, 0);\r\n\r\n            // bind diffuse texture\r\n            gl.activeTexture(gl.TEXTURE0);\r\n            gl.bindTexture(gl.TEXTURE_2D, diffuseTexture.baseTexture._glTextures[gl.id]);\r\n\r\n            // bind normal texture\r\n            gl.activeTexture(gl.TEXTURE1);\r\n            gl.bindTexture(gl.TEXTURE_2D, normalsTexture.baseTexture._glTextures[gl.id]);\r\n\r\n            // static upload of index buffer\r\n            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, light._indexBuffer);\r\n            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, light.indices, gl.STATIC_DRAW);\r\n        }\r\n\r\n        gl.drawElements(gl.TRIANGLES, light.indices.length, gl.UNSIGNED_SHORT, 0);\r\n    }\r\n\r\n    this.currentBatchSize = 0;\r\n};\r\n\r\n/**\r\n * Prepares all the buffers to render this light.\r\n *\r\n * @param light {Light} The light object to prepare for rendering.\r\n */\r\nLightRenderer.prototype._initWebGL = function (light)\r\n{\r\n    var gl = this.renderer.gl;\r\n\r\n    // create the buffers\r\n    light._vertexBuffer = gl.createBuffer();\r\n    light._indexBuffer = gl.createBuffer();\r\n    light._uvBuffer = gl.createBuffer();\r\n\r\n    gl.bindBuffer(gl.ARRAY_BUFFER, light._vertexBuffer);\r\n    gl.bufferData(gl.ARRAY_BUFFER, light.vertices, gl.DYNAMIC_DRAW);\r\n\r\n    gl.bindBuffer(gl.ARRAY_BUFFER, light._uvBuffer);\r\n    gl.bufferData(gl.ARRAY_BUFFER,  light.uvs, gl.STATIC_DRAW);\r\n\r\n    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, light._indexBuffer);\r\n    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, light.indices, gl.STATIC_DRAW);\r\n};\r\n\r\nLightRenderer.prototype.destroy = function ()\r\n{\r\n    \r\n};\r\n","/**\r\n * The WebGLDeferredRenderer draws the scene and all its content onto a webGL enabled canvas. This renderer\r\n * should be used for browsers that support webGL. This Render works by automatically managing webGLBatchs.\r\n * So no need for Sprite Batches or Sprite Clouds.\r\n * Don't forget to add the view to your DOM or you will not see anything :)\r\n *\r\n * @class\r\n * @memberof PIXI.lights\r\n * @extends PIXI.SystemRenderer\r\n * @param [width=0] {number} the width of the canvas view\r\n * @param [height=0] {number} the height of the canvas view\r\n * @param [options] {object} The optional renderer parameters\r\n * @param [options.view] {HTMLCanvasElement} the canvas to use as a view, optional\r\n * @param [options.transparent=false] {boolean} If the render view is transparent, default false\r\n * @param [options.autoResize=false] {boolean} If the render view is automatically resized, default false\r\n * @param [options.antialias=false] {boolean} sets antialias. If not available natively then FXAA antialiasing is used\r\n * @param [options.forceFXAA=false] {boolean} forces FXAA antialiasing to be used over native. FXAA is faster, but may not always lok as great\r\n * @param [options.resolution=1] {number} the resolution of the renderer retina would be 2\r\n * @param [options.clearBeforeRender=true] {boolean} This sets if the CanvasRenderer will clear the canvas or\r\n *      not before the new render pass.\r\n * @param [options.preserveDrawingBuffer=false] {boolean} enables drawing buffer preservation, enable this if\r\n *      you need to call toDataUrl on the webgl context.\r\n */\r\nfunction WebGLDeferredRenderer(width, height, options)\r\n{\r\n    options = options || {};\r\n\r\n    this._lightAmbientColor = 0x000000;\r\n    this._lightAmbientColorRgba = [0, 0, 0, 0];\r\n\r\n    this.ambientColor = options.ambientColor || this._lightAmbientColor;\r\n    this.ambientIntensity = options.ambientIntensity || this._lightAmbientColorRgba[3];\r\n\r\n    this.renderingNormals = false;\r\n\r\n    this._doWebGLRender = PIXI.WebGLRenderer.prototype.render;\r\n\r\n    PIXI.WebGLRenderer.call(this, width, height, options);\r\n}\r\n\r\nWebGLDeferredRenderer.prototype = Object.create(PIXI.WebGLRenderer.prototype);\r\nWebGLDeferredRenderer.prototype.constructor = WebGLDeferredRenderer;\r\nmodule.exports = WebGLDeferredRenderer;\r\n\r\nObject.defineProperties(WebGLDeferredRenderer.prototype, {\r\n    /**\r\n     * The color of ambient lighting\r\n     *\r\n     * @member {number}\r\n     * @memberof WebGLDeferredRenderer#\r\n     */\r\n    ambientColor: {\r\n        get: function ()\r\n        {\r\n            return this._lightAmbientColor;\r\n        },\r\n        set: function (val)\r\n        {\r\n            this._lightAmbientColor = val;\r\n            PIXI.utils.hex2rgb(val, this._lightAmbientColorRgba);\r\n        }\r\n    },\r\n    /**\r\n     * The intensity of ambient lighting\r\n     *\r\n     * @member {number}\r\n     * @memberof WebGLDeferredRenderer#\r\n     */\r\n    ambientIntensity: {\r\n        get: function ()\r\n        {\r\n            return this._lightAmbientColorRgba[3];\r\n        },\r\n        set: function (val)\r\n        {\r\n            this._lightAmbientColorRgba[3] = val;\r\n        }\r\n    }\r\n});\r\n\r\n/** @lends PIXI.DisplayObject# */\r\nObject.assign(WebGLDeferredRenderer.prototype, {\r\n    /**\r\n     * Initializes the context and necessary framebuffers.\r\n     */\r\n    _initContext: function ()\r\n    {\r\n        // call parent init\r\n        PIXI.WebGLRenderer.prototype._initContext.call(this);\r\n\r\n        // first create our render targets.\r\n        this.diffuseTexture = new PIXI.RenderTexture(this, this.width, this.height, null, this.resolution);\r\n        this.normalsTexture = new PIXI.RenderTexture(this, this.width, this.height, null, this.resolution);\r\n    },\r\n\r\n    render: function (object)\r\n    {\r\n        // render diffuse\r\n        this.renderingNormals = false;\r\n        this.diffuseTexture.render(object);\r\n//        this.renderTarget = this.diffuseRenderTarget;\r\n//        this._doWebGLRender(object);\r\n\r\n        // render normals\r\n        this.renderingNormals = true;\r\n        this.normalsTexture.render(object);\r\n//        this.renderTarget = this.normalsRenderTarget;\r\n//        this._doWebGLRender(object);\r\n\r\n        // render lights\r\n        this.setRenderTarget(this.renderTarget);\r\n        this.setObjectRenderer(this.plugins.lights);\r\n        this.plugins.lights.flush();\r\n\r\n        // composite to viewport\r\n//        this._composite();\r\n    }\r\n});\r\n"],"sourceRoot":"./"}