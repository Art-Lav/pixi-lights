!function t(e,i,r){function o(a,l){if(!i[a]){if(!e[a]){var s="function"==typeof require&&require;if(!l&&s)return s(a,!0);if(n)return n(a,!0);var h=new Error("Cannot find module '"+a+"'");throw h.code="MODULE_NOT_FOUND",h}var u=i[a]={exports:{}};e[a][0].call(u.exports,function(t){var i=e[a][1][t];return o(i?i:t)},u,u.exports,t,e,i,r)}return i[a].exports}for(var n="function"==typeof require&&require,a=0;a<r.length;a++)o(r[a]);return o}({1:[function(t,e,i){PIXI.lights={Light:t("./lights/light/Light"),LightShader:t("./lights/light/LightShader"),AmbientLight:t("./lights/ambientLight/AmbientLight"),AmbientLightShader:t("./lights/ambientLight/AmbientLightShader"),PointLight:t("./lights/pointLight/PointLight"),PointLightShader:t("./lights/pointLight/PointLightShader"),DirectionalLight:t("./lights/directionalLight/DirectionalLight"),DirectionalLightShader:t("./lights/directionalLight/DirectionalLightShader"),LightRenderer:t("./renderers/LightRenderer"),WireframeShader:t("./lights/WireframeShader")},Object.assign(PIXI.lights,t("./main")),e.exports=PIXI.lights,t("./shapeMeshMixin")},{"./lights/WireframeShader":2,"./lights/ambientLight/AmbientLight":3,"./lights/ambientLight/AmbientLightShader":4,"./lights/directionalLight/DirectionalLight":5,"./lights/directionalLight/DirectionalLightShader":6,"./lights/light/Light":7,"./lights/light/LightShader":8,"./lights/pointLight/PointLight":9,"./lights/pointLight/PointLightShader":10,"./main":11,"./renderers/LightRenderer":12,"./shapeMeshMixin":13}],2:[function(t,e,i){function r(t){PIXI.Shader.call(this,t,["attribute vec2 aVertexPosition;","uniform mat3 projectionMatrix;","void main(void) {","    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);","}"].join("\n"),["void main() {","    gl_FragColor = vec4(0, 0, 0, 1);","}"].join("\n"),{aVertexPosition:0})}var o=t("../main");r.prototype=Object.create(PIXI.Shader.prototype),r.prototype.constructor=r,e.exports=r,o.registerPlugin("wireframeShader",r)},{"../main":11}],3:[function(t,e,i){function r(t,e){o.call(this,t,e),this.shaderName="ambientLightShader"}var o=t("../light/Light");r.prototype=Object.create(o.prototype),r.prototype.constructor=r,e.exports=r},{"../light/Light":7}],4:[function(t,e,i){function r(t){n.call(this,t,null,'precision highp float;\n#define GLSLIFY 1\n\nuniform sampler2D uSampler;\nuniform sampler2D uNormalSampler;\n\nuniform mat3 translationMatrix;\n\nuniform vec2 uViewSize;     // size of the viewport\n\nuniform vec4 uLightColor;   // light color, alpha channel used for intensity.\nuniform vec3 uLightFalloff; // light attenuation coefficients (constant, linear, quadratic)\nuniform float uLightHeight; // light height above the viewport\n\n\nvoid main(void)\n{\nvec2 texCoord = gl_FragCoord.xy / uViewSize;\ntexCoord.y = 1.0 - texCoord.y; // FBOs positions are flipped.\n\nvec4 normalColor = texture2D(uNormalSampler, texCoord);\nnormalColor.g = 1.0 - normalColor.g; // Green layer is flipped Y coords.\n\n// bail out early when normal has no data\nif (normalColor.a == 0.0) discard;\n\n\n    // simplified lambert shading that makes assumptions for ambient color\n\n    // compute Distance\n    float D = 1.0;\n\n    // normalize vectors\n    vec3 N = normalize(normalColor.xyz * 2.0 - 1.0);\n    vec3 L = vec3(1.0, 1.0, 1.0);\n\n    // pre-multiply light color with intensity\n    // then perform "N dot L" to determine our diffuse\n    vec3 diffuse = (uLightColor.rgb * uLightColor.a) * max(dot(N, L), 0.0);\n\n    vec4 diffuseColor = texture2D(uSampler, texCoord);\n    vec3 finalColor = diffuseColor.rgb * diffuse;\n\n    gl_FragColor = vec4(finalColor, diffuseColor.a);\n}\n')}var o=t("../../main"),n=t("../light/LightShader");r.prototype=Object.create(n.prototype),r.prototype.constructor=r,e.exports=r,o.registerPlugin("ambientLightShader",r)},{"../../main":11,"../light/LightShader":8}],5:[function(t,e,i){function r(t,e,i){o.call(this,t,e),this.target=i,this._directionVector=new PIXI.Point,this._updateTransform=o.prototype.updateTransform,this._syncShader=o.prototype.syncShader,this.shaderName="directionalLightShader"}var o=t("../light/Light");r.prototype=Object.create(o.prototype),r.prototype.constructor=r,e.exports=r,r.prototype.updateTransform=function(){this.containerUpdateTransform();var t=this._directionVector,e=this.worldTransform,i=this.target.worldTransform?this.target.worldTransform.tx:this.target.x,r=this.target.worldTransform?this.target.worldTransform.ty:this.target.y;t.x=e.tx-i,t.y=e.ty-r;var o=Math.sqrt(t.x*t.x+t.y*t.y);t.x/=o,t.y/=o},r.prototype.syncShader=function(t){this._syncShader(t);var e=t.uniforms.uLightDirection;e[0]=this._directionVector.x,e[1]=this._directionVector.y,t.uniforms.uLightDirection=e}},{"../light/Light":7}],6:[function(t,e,i){function r(t){n.call(this,t,null,'precision highp float;\n#define GLSLIFY 1\n\n// imports the common uniforms like samplers, and ambient/light color\nuniform sampler2D uSampler;\nuniform sampler2D uNormalSampler;\n\nuniform mat3 translationMatrix;\n\nuniform vec2 uViewSize;     // size of the viewport\n\nuniform vec4 uLightColor;   // light color, alpha channel used for intensity.\nuniform vec3 uLightFalloff; // light attenuation coefficients (constant, linear, quadratic)\nuniform float uLightHeight; // light height above the viewport\n\n\nuniform vec2 uLightDirection;\n\nvoid main()\n{\nvec2 texCoord = gl_FragCoord.xy / uViewSize;\ntexCoord.y = 1.0 - texCoord.y; // FBOs positions are flipped.\n\nvec4 normalColor = texture2D(uNormalSampler, texCoord);\nnormalColor.g = 1.0 - normalColor.g; // Green layer is flipped Y coords.\n\n// bail out early when normal has no data\nif (normalColor.a == 0.0) discard;\n\n\n    // the directional vector of the light\n    vec3 lightVector = vec3(uLightDirection, uLightHeight);\n\n    // compute Distance\n    float D = length(lightVector);\n\n// normalize vectors\nvec3 N = normalize(normalColor.xyz * 2.0 - 1.0);\nvec3 L = normalize(lightVector);\n\n// pre-multiply light color with intensity\n// then perform "N dot L" to determine our diffuse\nvec3 diffuse = (uLightColor.rgb * uLightColor.a) * max(dot(N, L), 0.0);\n\n\n    // calculate attenuation\n    float attenuation = 1.0;\n\n// calculate final intesity and color, then combine\nvec3 intensity = diffuse * attenuation;\nvec4 diffuseColor = texture2D(uSampler, texCoord);\nvec3 finalColor = diffuseColor.rgb * intensity;\n\ngl_FragColor = vec4(finalColor, diffuseColor.a);\n\n}\n',{uLightDirection:{type:"2f",value:new Float32Array(2)}})}var o=t("../../main"),n=t("../light/LightShader");r.prototype=Object.create(n.prototype),r.prototype.constructor=r,e.exports=r,o.registerPlugin("directionalLightShader",r)},{"../../main":11,"../light/LightShader":8}],7:[function(t,e,i){function r(t,e,i,n){if(this.constructor===r)throw new Error("Light is an abstract base class, it should not be created directly!");PIXI.Container.call(this),this.vertices=i||new Float32Array(8),this.indices=n||new Uint16Array([0,1,2,0,2,3]),this.blendMode=PIXI.BLEND_MODES.ADD,this.drawMode=PIXI.DRAW_MODES.TRIANGLES,this.dirty=0,this.lightHeight=.075,this.falloff=[.75,3,20],this.shaderName=null,this.useViewportQuad=!0,this._color=5066073,this._colorRgba=[.3,.3,.35,.8],(t||0===t)&&(this.color=t),(e||0===e)&&(this.brightness=e),this.parentGroup=o.lightGroup,this._glDatas={},this.shaderName="lights"}var o=t("../../main");r.prototype=Object.create(PIXI.Container.prototype),r.prototype.constructor=r,e.exports=r,Object.defineProperties(r.prototype,{color:{get:function(){return this._color},set:function(t){this._color=t,PIXI.utils.hex2rgb(t,this._colorRgba)}},brightness:{get:function(){return this._colorRgba[3]},set:function(t){this._colorRgba[3]=t}}}),r.prototype.syncShader=function(t){t.uniforms.uUseViewportQuad=this.useViewportQuad;var e=t.uniforms.uLightColor;e&&(e[0]=this._colorRgba[0],e[1]=this._colorRgba[1],e[2]=this._colorRgba[2],e[3]=this._colorRgba[3],t.uniforms.uLightColor=e),t.uniforms.uLightHeight=this.lightHeight;var i=t.uniforms.uLightFalloff;i&&(i[0]=this.falloff[0],i[1]=this.falloff[1],i[2]=this.falloff[2],t.uniforms.uLightFalloff=i)},r.prototype._renderWebGL=function(t){t.setObjectRenderer(t.plugins.lights),t.plugins.lights.render(this)}},{"../../main":11}],8:[function(t,e,i){function r(t,e,i,o,n){var a={translationMatrix:{type:"mat3",value:new Float32Array(9)},projectionMatrix:{type:"mat3",value:new Float32Array(9)},uSampler:{type:"sampler2D",value:null},uNormalSampler:{type:"sampler2D",value:null},uUseViewportQuad:{type:"bool",value:!0},uViewSize:{type:"2f",value:new Float32Array(2)},uLightColor:{type:"4f",value:new Float32Array([1,1,1,1])},uLightFalloff:{type:"3f",value:new Float32Array([0,0,0])},uLightHeight:{type:"1f",value:.075}};if(o)for(var l in o)a[l]=o[l];var s={aVertexPosition:0};if(n)for(var h in n)s[h]=n[h];PIXI.Shader.call(this,t,e||r.defaultVertexSrc,i,s)}r.prototype=Object.create(PIXI.Shader.prototype),r.prototype.constructor=r,e.exports=r,r.defaultVertexSrc="#define GLSLIFY 1\nattribute vec2 aVertexPosition;\n\nuniform bool uUseViewportQuad;\nuniform mat3 translationMatrix;\nuniform mat3 projectionMatrix;\n\nvoid main(void) {\n    if (uUseViewportQuad) {\n        gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    }\n    else\n    {\n        gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    }\n}\n"},{}],9:[function(t,e,i){function r(t,e,i){if(i=i||1/0,i!==1/0){var r=new PIXI.Circle(0,0,i),n=r.getMesh();o.call(this,t,e,n.vertices,n.indices),this.useViewportQuad=!1,this.drawMode=PIXI.DRAW_MODES.TRIANGLE_FAN}else o.call(this,t,e);this._syncShader=o.prototype.syncShader,this.radius=i,this.shaderName="pointLightShader"}var o=t("../light/Light");r.prototype=Object.create(o.prototype),r.prototype.constructor=r,e.exports=r,r.prototype.syncShader=function(t){this._syncShader(t),t.uniforms.uLightRadius=this.radius}},{"../light/Light":7}],10:[function(t,e,i){function r(t){n.call(this,t,null,'precision highp float;\n#define GLSLIFY 1\n\n// imports the common uniforms like samplers, and ambient color\nuniform sampler2D uSampler;\nuniform sampler2D uNormalSampler;\n\nuniform mat3 translationMatrix;\n\nuniform vec2 uViewSize;     // size of the viewport\n\nuniform vec4 uLightColor;   // light color, alpha channel used for intensity.\nuniform vec3 uLightFalloff; // light attenuation coefficients (constant, linear, quadratic)\nuniform float uLightHeight; // light height above the viewport\n\n\nuniform float uLightRadius;\n\nvoid main()\n{\nvec2 texCoord = gl_FragCoord.xy / uViewSize;\ntexCoord.y = 1.0 - texCoord.y; // FBOs positions are flipped.\n\nvec4 normalColor = texture2D(uNormalSampler, texCoord);\nnormalColor.g = 1.0 - normalColor.g; // Green layer is flipped Y coords.\n\n// bail out early when normal has no data\nif (normalColor.a == 0.0) discard;\n\n\n    vec2 lightPosition = translationMatrix[2].xy / uViewSize;\n\n    // the directional vector of the light\n    vec3 lightVector = vec3(lightPosition - texCoord, uLightHeight);\n\n    // correct for aspect ratio\n    lightVector.x *= uViewSize.x / uViewSize.y;\n\n    // compute Distance\n    float D = length(lightVector);\n\n    // bail out early when pixel outside of light sphere\n    if (D > uLightRadius) discard;\n\n// normalize vectors\nvec3 N = normalize(normalColor.xyz * 2.0 - 1.0);\nvec3 L = normalize(lightVector);\n\n// pre-multiply light color with intensity\n// then perform "N dot L" to determine our diffuse\nvec3 diffuse = (uLightColor.rgb * uLightColor.a) * max(dot(N, L), 0.0);\n\n\n    // calculate attenuation\n    float attenuation = 1.0 / (uLightFalloff.x + (uLightFalloff.y * D) + (uLightFalloff.z * D * D));\n\n// calculate final intesity and color, then combine\nvec3 intensity = diffuse * attenuation;\nvec4 diffuseColor = texture2D(uSampler, texCoord);\nvec3 finalColor = diffuseColor.rgb * intensity;\n\ngl_FragColor = vec4(finalColor, diffuseColor.a);\n\n}\n',{uLightRadius:{type:"1f",value:1}})}var o=t("../../main"),n=t("../light/LightShader");r.prototype=Object.create(n.prototype),r.prototype.constructor=r,e.exports=r,o.registerPlugin("pointLightShader",r)},{"../../main":11,"../light/LightShader":8}],11:[function(t,e,i){e.exports={plugins:{},registerPlugin:function(t,e){this.plugins[t]=e},diffuseGroup:new PIXI.display.Group,normalGroup:new PIXI.display.Group,lightGroup:new PIXI.display.Group},e.exports.diffuseGroup.useRenderTexture=!0,e.exports.normalGroup.useRenderTexture=!0},{}],12:[function(t,e,i){function r(t){PIXI.ObjectRenderer.call(this,t);var e=6*r.MAX_LIGHTS;this.indices=new Uint16Array(e);for(var i=0,o=0;i<e;i+=6,o+=4)this.indices[i+0]=o+0,this.indices[i+1]=o+1,this.indices[i+2]=o+2,this.indices[i+3]=o+0,this.indices[i+4]=o+2,this.indices[i+5]=o+3;this.shaders={},this.lights=[]}var o=t("../main"),n=PIXI.glCore;r.MAX_LIGHTS=500,r.prototype=Object.create(PIXI.ObjectRenderer.prototype),r.prototype.constructor=r,e.exports=r,PIXI.WebGLRenderer.registerPlugin("lights",r),r.prototype.onContextChange=function(){this.gl=this.renderer.gl;for(var t in o.plugins)this.shaders[t]=new o.plugins[t](this.gl)},r.prototype.render=function(t){var e=this.renderer,i=e.gl;this.lights.push(t);var r=t._glDatas[e.CONTEXT_UID];r||(e.bindVao(null),r={shader:this.shaders[t.shaderName],vertexBuffer:n.GLBuffer.createVertexBuffer(i,t.vertices,i.STREAM_DRAW),indexBuffer:n.GLBuffer.createIndexBuffer(i,t.indices,i.STATIC_DRAW),vao:null,dirty:t.dirty},r.vao=new n.VertexArrayObject(i).addIndex(r.indexBuffer).addAttribute(r.vertexBuffer,r.shader.attributes.aVertexPosition,i.FLOAT,!1,8,0),t._glDatas[e.CONTEXT_UID]=r),e.bindVao(r.vao),t.useViewportQuad&&(t.vertices[2]=t.vertices[4]=e.screen.width,t.vertices[5]=t.vertices[7]=e.screen.height),r.vertexBuffer.upload(t.vertices),r.dirty!==t.dirty&&(r.dirty=t.dirty,r.indexBuffer.upload(t.indices))},r.prototype.flush=function(){for(var t=null,e=null,i=null,r=null,n=this.renderer,a=0;a<this.lights.length;++a){var l=this.lights[a],s=this.lights[a]._activeParentLayer;if(s){if(i!==s){i=s;var h=s._activeStageParent;if(s.diffuseTexture&&s.normalTexture)t=s.diffuseTexture,e=s.normalTexture;else for(var u=0;u<h._activeLayers.length;u++){var c=h._activeLayers[u];c.group===o.normalGroup&&(e=c.getRenderTexture()),c.group===o.diffuseGroup&&(t=c.getRenderTexture())}n.bindTexture(t,0,!0),n.bindTexture(e,1,!0)}var f=l._glDatas[n.CONTEXT_UID],g=f.shader;if(r!==g){r=g,n.bindShader(g),g.uniforms.uSampler=0,g.uniforms.uNormalSampler=1;var d=g.uniforms.uViewSize;d[0]=n.screen.width,d[1]=n.screen.height,g.uniforms.uViewSize=d}n.bindVao(f.vao),l.syncShader(g),n.state.setBlendMode(l.blendMode),g.uniforms.translationMatrix=l.worldTransform.toArray(!0),f.vao.draw(l.drawMode,l.indices.length,0)}}this.lights.length=0},r.prototype.stop=function(){this.flush()}},{"../main":11}],13:[function(t,e,i){PIXI.Circle.prototype.getMesh=function(t,e,i){t=t||40,e=e||new Float32Array(2*(t+1)),i=i||new Uint16Array(t+1);var r=2*Math.PI/t,o=-1;i[++o]=o;for(var n=0;n<=t;++n){var a=2*n,l=r*n;e[a]=Math.cos(l)*this.radius,e[a+1]=Math.sin(l)*this.radius,i[++o]=o}return i[o]=1,{vertices:e,indices:i}}},{}]},{},[1]);