{"version":3,"sources":["node_modules/browserify/node_modules/browser-pack/_prelude.js","src/index","src/light_2/LightRenderer.js","src/light_2/WebGLDeferredRenderer.js","src/light_2/lightSpriteMixin.js"],"names":[],"mappings":"AAAA;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"pixi-lights.js","sourceRoot":"./","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","module.exports = PIXI.light = {\r\n//    LitSprite: require('./light_1/LitSprite'),\r\n//    LightingRenderer: require('./light_1/webgl/LightingRenderer')\r\n\r\n    LightRenderer: require('./light_2/LightRenderer'),\r\n    WebGLDeferredRenderer: require('./light_2/WebGLDeferredRenderer')\r\n};\r\n\r\nrequire('./light_2/lightSpriteMixin');\r\n","function LightRenderer(renderer)\r\n{\r\n    PIXI.ObjectRenderer.call(this, renderer);\r\n\r\n    /**\r\n     * The number of lights this renderer can draw at a time.\r\n     *\r\n     * @member {number}\r\n     */\r\n    this.size = LightRenderer.MAX_LIGHTS;\r\n\r\n    // the total number of indices in our batch, 6 points per quad.\r\n    var numIndices = this.size * 6;\r\n\r\n    /**\r\n     * Holds the indices of the geometry (quads) to draw.\r\n     *\r\n     * @member {Uint16Array}\r\n     */\r\n    this.indices = new Uint16Array(numIndices);\r\n\r\n    // fill the indices with the quads to draw\r\n    for (var i=0, j=0; i < numIndices; i += 6, j += 4)\r\n    {\r\n        this.indices[i + 0] = j + 0;\r\n        this.indices[i + 1] = j + 1;\r\n        this.indices[i + 2] = j + 2;\r\n        this.indices[i + 3] = j + 0;\r\n        this.indices[i + 4] = j + 2;\r\n        this.indices[i + 5] = j + 3;\r\n    }\r\n}\r\n\r\nLightRenderer.MAX_LIGHTS = 500;\r\n\r\nLightRenderer.prototype = Object.create(PIXI.ObjectRenderer.prototype);\r\nLightRenderer.prototype.constructor = LightRenderer;\r\nmodule.exports = LightRenderer;\r\n\r\nPIXI.WebGLRenderer.registerPlugin('light', LightRenderer);\r\n\r\n/**\r\n * Sets up the renderer context and necessary buffers.\r\n *\r\n * @private\r\n * @param gl {WebGLRenderingContext} the current WebGL drawing context\r\n */\r\nLightRenderer.prototype.onContextChange = function ()\r\n{}\r\n\r\n/**\r\n * Renders the light object.\r\n *\r\n * @param light {Light} The light to render.\r\n */\r\nLightRenderer.prototype.render = function (light)\r\n{}\r\n\r\n/**\r\n * Renders the content and empties the current batch.\r\n *\r\n */\r\nLightRenderer.prototype.flush = function ()\r\n{}\r\n\r\n/**\r\n * Draws the currently batched lights.\r\n *\r\n * @private\r\n * @param texture {Texture}\r\n * @param size {number}\r\n * @param startIndex {number}\r\n */\r\nLightRenderer.prototype.renderBatch = function (texture, size, startIndex)\r\n{}\r\n\r\n/**\r\n * Destroys the SpriteBatch.\r\n *\r\n */\r\nLightRenderer.prototype.destroy = function ()\r\n{}\r\n","/**\r\n * The WebGLDeferredRenderer draws the scene and all its content onto a webGL enabled canvas. This renderer\r\n * should be used for browsers that support webGL. This Render works by automatically managing webGLBatchs.\r\n * So no need for Sprite Batches or Sprite Clouds.\r\n * Don't forget to add the view to your DOM or you will not see anything :)\r\n *\r\n * @class\r\n * @memberof PIXI\r\n * @extends PIXI.SystemRenderer\r\n * @param [width=0] {number} the width of the canvas view\r\n * @param [height=0] {number} the height of the canvas view\r\n * @param [options] {object} The optional renderer parameters\r\n * @param [options.view] {HTMLCanvasElement} the canvas to use as a view, optional\r\n * @param [options.transparent=false] {boolean} If the render view is transparent, default false\r\n * @param [options.autoResize=false] {boolean} If the render view is automatically resized, default false\r\n * @param [options.antialias=false] {boolean} sets antialias. If not available natively then FXAA antialiasing is used\r\n * @param [options.forceFXAA=false] {boolean} forces FXAA antialiasing to be used over native. FXAA is faster, but may not always lok as great\r\n * @param [options.resolution=1] {number} the resolution of the renderer retina would be 2\r\n * @param [options.clearBeforeRender=true] {boolean} This sets if the CanvasRenderer will clear the canvas or\r\n *      not before the new render pass.\r\n * @param [options.preserveDrawingBuffer=false] {boolean} enables drawing buffer preservation, enable this if\r\n *      you need to call toDataUrl on the webgl context.\r\n */\r\nfunction WebGLDeferredRenderer(width, height, options)\r\n{\r\n    PIXI.WebGLRenderer.call(this, width, height, options);\r\n \r\n    this.viewportRenderTarget = this.renderTarget;\r\n\r\n    this.diffuseRenderTarget = null;\r\n    this.normalsRenderTarget = null;\r\n    this.lightsRenderTarget = null;\r\n\r\n    this.lights = [];\r\n\r\n    this.renderingNormals = false;\r\n\r\n    this._doWebGLRender = PIXI.WebGLRenderer.prototype.render;\r\n}\r\n\r\nWebGLDeferredRenderer.prototype = Object.create(PIXI.WebGLRenderer.prototype);\r\nWebGLDeferredRenderer.prototype.constructor = WebGLDeferredRenderer;\r\n\r\nmodule.exports = WebGLDeferredRenderer;\r\n\r\n/** @lends PIXI.DisplayObject# */\r\nObject.assign(WebGLDeferredRenderer.prototype, {\r\n    /**\r\n     * Initializes the context and necessary framebuffers.\r\n     */\r\n    _initContext: function ()\r\n    {\r\n        PIXI.WebGLRenderer.prototype._initContext.call(this);\r\n\r\n        this.diffuseRenderTarget = new PIXI.RenderTarget(this.gl, this.width, this.height, null, this.resolution, false);\r\n        this.normalsRenderTarget = new PIXI.RenderTarget(this.gl, this.width, this.height, null, this.resolution, false);\r\n        this.lightsRenderTarget  = new PIXI.RenderTarget(this.gl, this.width, this.height, null, this.resolution, false);\r\n\r\n        // render targets bind when they get created, so we need to reset back to the default one.\r\n        this.renderTarget.activate();\r\n    },\r\n\r\n    render: function (object)\r\n    {\r\n        // render diffuse\r\n        this.renderingNormals = false;\r\n        this.renderTarget = this.diffuseRenderTarget;\r\n        this._doWebGLRender(object);\r\n\r\n        // render normals\r\n        this.renderingNormals = true;\r\n        this.renderTarget = this.normalsRenderTarget;\r\n        this._doWebGLRender(object);\r\n\r\n        // render lights\r\n        this.plugins.light.flush();\r\n\r\n        // composite to viewport\r\n//        this._composite();\r\n    },\r\n\r\n    _renderLights: function () {\r\n        \r\n    },\r\n\r\n    _updateLight: function () {\r\n        \r\n    }\r\n});\r\n","var tempTexture = null;\r\n\r\n /**\r\n * Renders the object using the WebGL renderer\r\n *\r\n * @param renderer {WebGLRenderer}\r\n * @private\r\n */\r\nPIXI.Sprite.prototype._renderWebGL = function (renderer)\r\n{\r\n    if (!this._originalTexture) {\r\n        this._originalTexture = this._texture;\r\n    }\r\n\r\n    if (renderer.renderingNormals && this.normalTexture)\r\n    {\r\n        this._texture = this.normalTexture;\r\n    }\r\n    else\r\n    {\r\n        this._texture = this._originalTexture;\r\n    }\r\n\r\n    renderer.setObjectRenderer(renderer.plugins.sprite);\r\n    renderer.plugins.sprite.render(this);\r\n};\r\n"]}